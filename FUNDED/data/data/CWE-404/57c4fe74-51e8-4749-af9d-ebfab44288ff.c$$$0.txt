-----label-----
0
-----code-----
static void binder_transaction_buffer_release(struct binder_proc *proc,
					      struct binder_buffer *buffer,
					      binder_size_t *failed_at)
{
	binder_size_t *offp, *off_start, *off_end;
	int debug_id = buffer->debug_id;

	binder_debug(BINDER_DEBUG_TRANSACTION,
		     "%d buffer release %d, size %zd-%zd, failed at %p\n",
		     proc->pid, buffer->debug_id,
		     buffer->data_size, buffer->offsets_size, failed_at);

	if (buffer->target_node)
		binder_dec_node(buffer->target_node, 1, 0);

	off_start = (binder_size_t *)(buffer->data +
				      ALIGN(buffer->data_size, sizeof(void *)));
	if (failed_at)
		off_end = failed_at;
	else
		off_end = (void *)off_start + buffer->offsets_size;
	for (offp = off_start; offp < off_end; offp++) {
		struct binder_object_header *hdr;
		size_t object_size = binder_validate_object(buffer, *offp);

		if (object_size == 0) {
			pr_err("transaction release %d bad object at offset %lld, size %zd\n",
			       debug_id, (u64)*offp, buffer->data_size);
			continue;
		}
		hdr = (struct binder_object_header *)(buffer->data + *offp);
		switch (hdr->type) {
		case BINDER_TYPE_BINDER:
		case BINDER_TYPE_WEAK_BINDER: {
			struct flat_binder_object *fp;
			struct binder_node *node;

			fp = to_flat_binder_object(hdr);
			node = binder_get_node(proc, fp->binder);
			if (node == NULL) {
				pr_err("transaction release %d bad node %016llx\n",
				       debug_id, (u64)fp->binder);
				break;
			}
			binder_debug(BINDER_DEBUG_TRANSACTION,
				     "        node %d u%016llx\n",
				     node->debug_id, (u64)node->ptr);
			binder_dec_node(node, hdr->type == BINDER_TYPE_BINDER,
					0);
			binder_put_node(node);
		} break;
		case BINDER_TYPE_HANDLE:
		case BINDER_TYPE_WEAK_HANDLE: {
			struct flat_binder_object *fp;
			struct binder_ref_data rdata;
			int ret;

			fp = to_flat_binder_object(hdr);
			ret = binder_dec_ref_for_handle(proc, fp->handle,
				hdr->type == BINDER_TYPE_HANDLE, &rdata);

			if (ret) {
				pr_err("transaction release %d bad handle %d, ret = %d\n",
				 debug_id, fp->handle, ret);
				break;
			}
			binder_debug(BINDER_DEBUG_TRANSACTION,
				     "        ref %d desc %d\n",
				     rdata.debug_id, rdata.desc);
		} break;

		case BINDER_TYPE_FD: {
			struct binder_fd_object *fp = to_binder_fd_object(hdr);

			binder_debug(BINDER_DEBUG_TRANSACTION,
				     "        fd %d\n", fp->fd);
			if (failed_at)
				task_close_fd(proc, fp->fd);
		} break;
		case BINDER_TYPE_PTR:
			/*
			 * Nothing to do here, this will get cleaned up when the
			 * transaction buffer gets freed
			 */
			break;
		case BINDER_TYPE_FDA: {
			struct binder_fd_array_object *fda;
			struct binder_buffer_object *parent;
			uintptr_t parent_buffer;
			u32 *fd_array;
			size_t fd_index;
			binder_size_t fd_buf_size;

			fda = to_binder_fd_array_object(hdr);
			parent = binder_validate_ptr(buffer, fda->parent,
						     off_start,
						     offp - off_start);
			if (!parent) {
				pr_err("transaction release %d bad parent offset",
				       debug_id);
				continue;
			}
			/*
			 * Since the parent was already fixed up, convert it
			 * back to kernel address space to access it
			 */
			parent_buffer = parent->buffer -
				binder_alloc_get_user_buffer_offset(
						&proc->alloc);

			fd_buf_size = sizeof(u32) * fda->num_fds;
			if (fda->num_fds >= SIZE_MAX / sizeof(u32)) {
				pr_err("transaction release %d invalid number of fds (%lld)\n",
				       debug_id, (u64)fda->num_fds);
				continue;
			}
			if (fd_buf_size > parent->length ||
			    fda->parent_offset > parent->length - fd_buf_size) {
				/* No space for all file descriptors here. */
				pr_err("transaction release %d not enough space for %lld fds in buffer\n",
				       debug_id, (u64)fda->num_fds);
				continue;
			}
			fd_array = (u32 *)(parent_buffer + fda->parent_offset);
			for (fd_index = 0; fd_index < fda->num_fds; fd_index++)
				task_close_fd(proc, fd_array[fd_index]);
		} break;
		default:
			pr_err("transaction release %d bad object type %x\n",
				debug_id, hdr->type);
			break;
		}
	}
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
14,16
17,18
17,19
18,19
20,21
20,22
23,24
23,25
23,26
23,27
23,28
23,29
23,30
24,25
25,26
25,27
25,28
25,29
26,27
28,29
28,30
31,32
31,33
34,35
34,36
37,38
38,39
38,40
40,41
40,42
42,43
43,44
43,45
44,45
47,48
48,49
48,50
48,51
48,52
48,53
48,54
48,55
48,56
49,50
51,52
54,55
54,56
55,56
58,59
58,60
59,60
62,63
62,64
63,64
66,67
66,68
67,68
70,71
72,73
72,74
73,74
73,75
74,75
77,78
78,79
78,80
78,81
78,82
79,80
81,82
81,83
82,83
87,88
88,89
88,90
89,90
91,92
91,93
92,93
92,94
93,94
95,96
97,98
98,99
98,100
99,100
99,101
100,101
103,104
103,105
103,106
104,105
106,107
106,108
107,108
110,111
111,112
111,113
113,114
115,116
115,117
115,118
116,117
118,119
119,120
119,121
120,121
122,123
124,125
125,126
125,127
126,127
128,129
128,130
129,130
129,131
130,131
130,132
132,133
134,135
136,137
136,138
137,138
140,141
140,142
140,143
140,144
141,142
142,143
142,144
143,144
145,146
147,148
147,149
148,149
150,151
152,153
153,154
155,156
155,157
155,158
155,159
155,160
156,157
157,158
157,159
158,159
160,161
160,162
163,164
164,165
164,166
165,166
167,168
167,169
169,170
170,171
170,172
170,173
171,172
173,174
175,176
176,177
178,179
178,180
179,180
179,181
180,181
183,184
183,185
184,185
185,186
185,187
185,188
185,189
185,190
186,187
189,190
191,192
191,193
192,193
193,194
195,196
197,198
197,199
198,199
202,203
203,204
203,205
204,205
206,207
206,208
207,208
207,209
208,209
210,211
212,213
213,214
213,215
214,215
214,216
215,216
218,219
219,220
221,222
221,223
222,223
222,224
223,224
226,227
226,228
226,229
226,230
226,231
226,232
226,233
226,234
226,235
226,236
226,237
226,238
226,239
226,240
226,241
226,242
226,243
226,244
226,245
227,228
228,229
230,231
231,232
233,234
233,235
233,236
233,237
233,238
233,239
233,240
233,241
234,235
235,236
235,237
236,237
238,239
238,240
241,242
242,243
242,244
243,244
245,246
245,247
248,249
249,250
249,251
250,251
252,253
252,254
253,254
255,256
257,258
258,259
258,260
259,260
261,262
261,263
261,264
262,263
264,265
266,267
266,268
267,268
270,271
270,272
271,272
271,273
272,273
274,275
276,277
276,278
277,278
278,279
278,280
278,281
278,282
279,280
282,283
284,285
284,286
285,286
285,287
286,287
289,290
289,291
290,291
294,295
295,296
295,297
295,298
295,299
295,300
296,297
298,299
301,302
301,303
302,303
305,306
305,307
306,307
306,308
307,308
310,311
310,312
311,312
314,315
315,316
315,317
315,318
315,319
316,317
318,319
320,321
320,322
321,322
321,323
322,323
325,326
328,329
329,330
329,331
330,331
332,333
335,336
336,337
338,339
339,340
341,342
341,343
341,344
341,345
341,346
341,347
341,348
342,343
343,344
343,345
344,345
346,347
346,348
349,350
350,351
350,352
351,352
353,354
355,356
356,357
356,358
358,359
360,361
361,362
361,363
362,363
364,365
364,366
365,366
367,368
369,370
370,371
370,372
371,372
373,374
373,375
373,376
373,377
373,378
374,375
376,377
378,379
378,380
379,380
382,383
382,384
383,384
383,385
384,385
387,388
389,390
390,391
392,393
392,394
393,394
395,396
395,397
396,397
397,398
397,399
397,400
397,401
397,402
398,399
401,402
403,404
403,405
404,405
407,408
410,411
411,412
411,413
411,414
411,415
411,416
412,413
414,415
417,418
417,419
418,419
421,422
421,423
422,423
426,427
427,428
429,430
429,431
429,432
430,431
431,432
431,433
432,433
434,435
434,436
434,437
437,438
438,439
438,440
439,440
441,442
443,444
444,445
444,446
444,447
444,448
445,446
447,448
450,451
450,452
451,452
454,455
454,456
455,456
457,458
458,459
458,460
458,461
459,460
461,462
463,464
463,465
464,465
468,469
469,470
472,473
473,474
475,476
475,477
475,478
475,479
475,480
475,481
475,482
475,483
475,484
475,485
475,486
475,487
475,488
475,489
475,490
476,477
477,478
477,479
478,479
480,481
480,482
483,484
484,485
484,486
485,486
487,488
487,489
490,491
491,492
491,493
492,493
494,495
496,497
497,498
497,499
498,499
500,501
500,502
503,504
504,505
504,506
505,506
507,508
509,510
510,511
510,512
511,512
513,514
515,516
516,517
516,518
517,518
519,520
519,521
520,521
522,523
524,525
525,526
525,527
526,527
528,529
528,530
528,531
528,532
528,533
529,530
531,532
533,534
533,535
534,535
537,538
539,540
539,541
540,541
542,543
544,545
544,546
545,546
546,547
548,549
548,550
549,550
550,551
550,552
550,553
551,552
554,555
557,558
558,559
558,560
559,560
561,562
561,563
562,563
562,564
563,564
566,567
566,568
567,568
569,570
570,571
570,572
571,572
574,575
575,576
575,577
576,577
578,579
578,580
579,580
580,581
580,582
581,582
584,585
584,586
585,586
588,589
588,590
589,590
589,591
590,591
590,592
591,592
594,595
594,596
595,596
597,598
598,599
598,600
599,600
602,603
602,604
603,604
604,605
604,606
604,607
604,608
605,606
608,609
610,611
610,612
611,612
611,613
612,613
615,616
615,617
616,617
620,621
620,622
621,622
621,623
622,623
622,624
623,624
625,626
625,627
626,627
629,630
629,631
630,631
630,632
631,632
634,635
634,636
635,636
635,637
636,637
639,640
641,642
641,643
642,643
643,644
643,645
643,646
643,647
644,645
647,648
649,650
649,651
650,651
650,652
651,652
654,655
654,656
655,656
659,660
660,661
660,662
661,662
663,664
663,665
664,665
664,666
665,666
667,668
669,670
670,671
670,672
671,672
673,674
673,675
674,675
677,678
677,679
677,680
677,681
678,679
679,680
679,681
680,681
683,684
683,685
684,685
686,687
686,688
687,688
690,691
691,692
693,694
694,695
694,696
694,697
695,696
697,698
699,700
699,701
700,701
702,703
706,707
707,708
707,709
707,710
707,711
708,709
711,712
713,714
713,715
714,715
-----nextToken-----
2,4,7,9,10,13,15,16,19,21,22,27,29,30,32,33,35,36,39,41,45,46,50,52,53,56,57,60,61,64,65,68,69,71,75,76,80,83,84,85,86,90,94,96,101,102,105,108,109,112,114,117,121,123,127,131,133,135,138,139,144,146,149,151,154,159,161,162,166,168,172,174,177,181,182,187,188,190,194,196,199,200,201,205,209,211,216,217,220,224,225,229,232,237,239,240,244,246,247,251,254,256,260,263,265,268,269,273,275,280,281,283,287,288,291,292,293,297,299,300,303,304,308,309,312,313,317,319,323,324,326,327,331,333,334,337,340,345,347,348,352,354,357,359,363,366,368,372,375,377,380,381,385,386,388,391,394,399,400,402,405,406,408,409,413,415,416,419,420,423,424,425,428,433,435,436,440,442,446,448,449,452,453,456,460,462,465,466,467,470,471,474,479,481,482,486,488,489,493,495,499,501,502,506,508,512,514,518,521,523,527,530,532,535,536,538,541,543,547,552,553,555,556,560,564,565,568,572,573,577,582,583,586,587,592,593,596,600,601,606,607,609,613,614,617,618,619,624,627,628,632,633,637,638,640,645,646,648,652,653,656,657,658,662,666,668,672,675,676,681,682,685,688,689,692,696,698,701,703,704,705,709,710,712,715,716,717
-----computeFrom-----
88,89
88,90
98,99
98,100
119,120
119,121
125,126
125,127
128,129
128,130
142,143
142,144
147,148
147,149
179,180
179,181
191,192
191,193
203,204
203,205
213,214
213,215
249,250
249,251
258,259
258,260
271,272
271,273
320,321
320,322
361,362
361,363
370,371
370,372
382,383
382,384
516,517
516,518
525,526
525,527
539,540
539,541
558,559
558,560
561,562
561,563
575,576
575,577
578,579
578,580
589,590
589,591
594,595
594,596
621,622
621,623
622,623
622,624
629,630
629,631
634,635
634,636
660,661
660,662
670,671
670,672
679,680
679,681
683,684
683,685
-----guardedBy-----
592,617
593,618
632,656
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IfStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;FieldReference;IdExpression;Name;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;BinaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ContinueStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ContinueStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;ContinueStatement;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;ContinueStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;BreakStatement;DefaultStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BreakStatement;
-----ast_node-----
static void binder_transaction_buffer_release(struct binder_proc *proc,					      struct binder_buffer *buffer,					      binder_size_t *failed_at){	binder_size_t *offp, *off_start, *off_end;	int debug_id = buffer->debug_id;	binder_debug(BINDER_DEBUG_TRANSACTION,		     "%d buffer release %d, size %zd-%zd, failed at %p\n",		     proc->pid, buffer->debug_id,		     buffer->data_size, buffer->offsets_size, failed_at);	if (buffer->target_node)		binder_dec_node(buffer->target_node, 1, 0);	off_start = (binder_size_t *)(buffer->data +				      ALIGN(buffer->data_size, sizeof(void *)));	if (failed_at)		off_end = failed_at;	else		off_end = (void *)off_start + buffer->offsets_size;	for (offp = off_start; offp < off_end; offp++) {		struct binder_object_header *hdr;		size_t object_size = binder_validate_object(buffer, *offp);		if (object_size == 0) {			pr_err("transaction release %d bad object at offset %lld, size %zd\n",			       debug_id, (u64)*offp, buffer->data_size);			continue;		}		hdr = (struct binder_object_header *)(buffer->data + *offp);		switch (hdr->type) {		case BINDER_TYPE_BINDER:		case BINDER_TYPE_WEAK_BINDER: {			struct flat_binder_object *fp;			struct binder_node *node;			fp = to_flat_binder_object(hdr);			node = binder_get_node(proc, fp->binder);			if (node == NULL) {				pr_err("transaction release %d bad node %016llx\n",				       debug_id, (u64)fp->binder);				break;			}			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        node %d u%016llx\n",				     node->debug_id, (u64)node->ptr);			binder_dec_node(node, hdr->type == BINDER_TYPE_BINDER,					0);			binder_put_node(node);		} break;		case BINDER_TYPE_HANDLE:		case BINDER_TYPE_WEAK_HANDLE: {			struct flat_binder_object *fp;			struct binder_ref_data rdata;			int ret;			fp = to_flat_binder_object(hdr);			ret = binder_dec_ref_for_handle(proc, fp->handle,				hdr->type == BINDER_TYPE_HANDLE, &rdata);			if (ret) {				pr_err("transaction release %d bad handle %d, ret = %d\n",				 debug_id, fp->handle, ret);				break;			}			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        ref %d desc %d\n",				     rdata.debug_id, rdata.desc);		} break;		case BINDER_TYPE_FD: {			struct binder_fd_object *fp = to_binder_fd_object(hdr);			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        fd %d\n", fp->fd);			if (failed_at)				task_close_fd(proc, fp->fd);		} break;		case BINDER_TYPE_PTR:			/*			 * Nothing to do here, this will get cleaned up when the			 * transaction buffer gets freed			 */			break;		case BINDER_TYPE_FDA: {			struct binder_fd_array_object *fda;			struct binder_buffer_object *parent;			uintptr_t parent_buffer;			u32 *fd_array;			size_t fd_index;			binder_size_t fd_buf_size;			fda = to_binder_fd_array_object(hdr);			parent = binder_validate_ptr(buffer, fda->parent,						     off_start,						     offp - off_start);			if (!parent) {				pr_err("transaction release %d bad parent offset",				       debug_id);				continue;			}			/*			 * Since the parent was already fixed up, convert it			 * back to kernel address space to access it			 */			parent_buffer = parent->buffer -				binder_alloc_get_user_buffer_offset(						&proc->alloc);			fd_buf_size = sizeof(u32) * fda->num_fds;			if (fda->num_fds >= SIZE_MAX / sizeof(u32)) {				pr_err("transaction release %d invalid number of fds (%lld)\n",				       debug_id, (u64)fda->num_fds);				continue;			}			if (fd_buf_size > parent->length ||			    fda->parent_offset > parent->length - fd_buf_size) {				/* No space for all file descriptors here. */				pr_err("transaction release %d not enough space for %lld fds in buffer\n",				       debug_id, (u64)fda->num_fds);				continue;			}			fd_array = (u32 *)(parent_buffer + fda->parent_offset);			for (fd_index = 0; fd_index < fda->num_fds; fd_index++)				task_close_fd(proc, fd_array[fd_index]);		} break;		default:			pr_err("transaction release %d bad object type %x\n",				debug_id, hdr->type);			break;		}	}}
static void
binder_transaction_buffer_release(struct binder_proc *proc,					      struct binder_buffer *buffer,					      binder_size_t *failed_at)
binder_transaction_buffer_release
struct binder_proc *proc
struct binder_proc
binder_proc
*proc
*
proc
struct binder_buffer *buffer
struct binder_buffer
binder_buffer
*buffer
*
buffer
binder_size_t *failed_at
binder_size_t
binder_size_t
*failed_at
*
failed_at
{	binder_size_t *offp, *off_start, *off_end;	int debug_id = buffer->debug_id;	binder_debug(BINDER_DEBUG_TRANSACTION,		     "%d buffer release %d, size %zd-%zd, failed at %p\n",		     proc->pid, buffer->debug_id,		     buffer->data_size, buffer->offsets_size, failed_at);	if (buffer->target_node)		binder_dec_node(buffer->target_node, 1, 0);	off_start = (binder_size_t *)(buffer->data +				      ALIGN(buffer->data_size, sizeof(void *)));	if (failed_at)		off_end = failed_at;	else		off_end = (void *)off_start + buffer->offsets_size;	for (offp = off_start; offp < off_end; offp++) {		struct binder_object_header *hdr;		size_t object_size = binder_validate_object(buffer, *offp);		if (object_size == 0) {			pr_err("transaction release %d bad object at offset %lld, size %zd\n",			       debug_id, (u64)*offp, buffer->data_size);			continue;		}		hdr = (struct binder_object_header *)(buffer->data + *offp);		switch (hdr->type) {		case BINDER_TYPE_BINDER:		case BINDER_TYPE_WEAK_BINDER: {			struct flat_binder_object *fp;			struct binder_node *node;			fp = to_flat_binder_object(hdr);			node = binder_get_node(proc, fp->binder);			if (node == NULL) {				pr_err("transaction release %d bad node %016llx\n",				       debug_id, (u64)fp->binder);				break;			}			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        node %d u%016llx\n",				     node->debug_id, (u64)node->ptr);			binder_dec_node(node, hdr->type == BINDER_TYPE_BINDER,					0);			binder_put_node(node);		} break;		case BINDER_TYPE_HANDLE:		case BINDER_TYPE_WEAK_HANDLE: {			struct flat_binder_object *fp;			struct binder_ref_data rdata;			int ret;			fp = to_flat_binder_object(hdr);			ret = binder_dec_ref_for_handle(proc, fp->handle,				hdr->type == BINDER_TYPE_HANDLE, &rdata);			if (ret) {				pr_err("transaction release %d bad handle %d, ret = %d\n",				 debug_id, fp->handle, ret);				break;			}			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        ref %d desc %d\n",				     rdata.debug_id, rdata.desc);		} break;		case BINDER_TYPE_FD: {			struct binder_fd_object *fp = to_binder_fd_object(hdr);			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        fd %d\n", fp->fd);			if (failed_at)				task_close_fd(proc, fp->fd);		} break;		case BINDER_TYPE_PTR:			/*			 * Nothing to do here, this will get cleaned up when the			 * transaction buffer gets freed			 */			break;		case BINDER_TYPE_FDA: {			struct binder_fd_array_object *fda;			struct binder_buffer_object *parent;			uintptr_t parent_buffer;			u32 *fd_array;			size_t fd_index;			binder_size_t fd_buf_size;			fda = to_binder_fd_array_object(hdr);			parent = binder_validate_ptr(buffer, fda->parent,						     off_start,						     offp - off_start);			if (!parent) {				pr_err("transaction release %d bad parent offset",				       debug_id);				continue;			}			/*			 * Since the parent was already fixed up, convert it			 * back to kernel address space to access it			 */			parent_buffer = parent->buffer -				binder_alloc_get_user_buffer_offset(						&proc->alloc);			fd_buf_size = sizeof(u32) * fda->num_fds;			if (fda->num_fds >= SIZE_MAX / sizeof(u32)) {				pr_err("transaction release %d invalid number of fds (%lld)\n",				       debug_id, (u64)fda->num_fds);				continue;			}			if (fd_buf_size > parent->length ||			    fda->parent_offset > parent->length - fd_buf_size) {				/* No space for all file descriptors here. */				pr_err("transaction release %d not enough space for %lld fds in buffer\n",				       debug_id, (u64)fda->num_fds);				continue;			}			fd_array = (u32 *)(parent_buffer + fda->parent_offset);			for (fd_index = 0; fd_index < fda->num_fds; fd_index++)				task_close_fd(proc, fd_array[fd_index]);		} break;		default:			pr_err("transaction release %d bad object type %x\n",				debug_id, hdr->type);			break;		}	}}
binder_size_t *offp, *off_start, *off_end;
binder_size_t *offp, *off_start, *off_end;
binder_size_t
binder_size_t
*offp
*
offp
*off_start
*
off_start
*off_end
*
off_end
int debug_id = buffer->debug_id;
int debug_id = buffer->debug_id;
int
debug_id = buffer->debug_id
debug_id
= buffer->debug_id
buffer->debug_id
buffer
buffer
debug_id
binder_debug(BINDER_DEBUG_TRANSACTION,		     "%d buffer release %d, size %zd-%zd, failed at %p\n",		     proc->pid, buffer->debug_id,		     buffer->data_size, buffer->offsets_size, failed_at);
binder_debug(BINDER_DEBUG_TRANSACTION,		     "%d buffer release %d, size %zd-%zd, failed at %p\n",		     proc->pid, buffer->debug_id,		     buffer->data_size, buffer->offsets_size, failed_at)
binder_debug
binder_debug
BINDER_DEBUG_TRANSACTION
BINDER_DEBUG_TRANSACTION
"%d buffer release %d, size %zd-%zd, failed at %p\n"
proc->pid
proc
proc
pid
buffer->debug_id
buffer
buffer
debug_id
buffer->data_size
buffer
buffer
data_size
buffer->offsets_size
buffer
buffer
offsets_size
failed_at
failed_at
if (buffer->target_node)		binder_dec_node(buffer->target_node, 1, 0);
buffer->target_node
buffer
buffer
target_node
binder_dec_node(buffer->target_node, 1, 0);
binder_dec_node(buffer->target_node, 1, 0)
binder_dec_node
binder_dec_node
buffer->target_node
buffer
buffer
target_node
1
0
off_start = (binder_size_t *)(buffer->data +				      ALIGN(buffer->data_size, sizeof(void *)));
off_start = (binder_size_t *)(buffer->data +				      ALIGN(buffer->data_size, sizeof(void *)))
off_start
off_start
(binder_size_t *)(buffer->data +				      ALIGN(buffer->data_size, sizeof(void *)))
binder_size_t *
binder_size_t
binder_size_t
*
*
(buffer->data +				      ALIGN(buffer->data_size, sizeof(void *)))
buffer->data +				      ALIGN(buffer->data_size, sizeof(void *))
buffer->data
buffer
buffer
data
ALIGN(buffer->data_size, sizeof(void *))
ALIGN
ALIGN
buffer->data_size
buffer
buffer
data_size
sizeof(void *)
void *
void
*
*
if (failed_at)		off_end = failed_at;	else		off_end = (void *)off_start + buffer->offsets_size;
failed_at
failed_at
off_end = failed_at;
off_end = failed_at
off_end
off_end
failed_at
failed_at
off_end = (void *)off_start + buffer->offsets_size;
off_end = (void *)off_start + buffer->offsets_size
off_end
off_end
(void *)off_start + buffer->offsets_size
(void *)off_start
void *
void
*
*
off_start
off_start
buffer->offsets_size
buffer
buffer
offsets_size
for (offp = off_start; offp < off_end; offp++) {		struct binder_object_header *hdr;		size_t object_size = binder_validate_object(buffer, *offp);		if (object_size == 0) {			pr_err("transaction release %d bad object at offset %lld, size %zd\n",			       debug_id, (u64)*offp, buffer->data_size);			continue;		}		hdr = (struct binder_object_header *)(buffer->data + *offp);		switch (hdr->type) {		case BINDER_TYPE_BINDER:		case BINDER_TYPE_WEAK_BINDER: {			struct flat_binder_object *fp;			struct binder_node *node;			fp = to_flat_binder_object(hdr);			node = binder_get_node(proc, fp->binder);			if (node == NULL) {				pr_err("transaction release %d bad node %016llx\n",				       debug_id, (u64)fp->binder);				break;			}			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        node %d u%016llx\n",				     node->debug_id, (u64)node->ptr);			binder_dec_node(node, hdr->type == BINDER_TYPE_BINDER,					0);			binder_put_node(node);		} break;		case BINDER_TYPE_HANDLE:		case BINDER_TYPE_WEAK_HANDLE: {			struct flat_binder_object *fp;			struct binder_ref_data rdata;			int ret;			fp = to_flat_binder_object(hdr);			ret = binder_dec_ref_for_handle(proc, fp->handle,				hdr->type == BINDER_TYPE_HANDLE, &rdata);			if (ret) {				pr_err("transaction release %d bad handle %d, ret = %d\n",				 debug_id, fp->handle, ret);				break;			}			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        ref %d desc %d\n",				     rdata.debug_id, rdata.desc);		} break;		case BINDER_TYPE_FD: {			struct binder_fd_object *fp = to_binder_fd_object(hdr);			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        fd %d\n", fp->fd);			if (failed_at)				task_close_fd(proc, fp->fd);		} break;		case BINDER_TYPE_PTR:			/*			 * Nothing to do here, this will get cleaned up when the			 * transaction buffer gets freed			 */			break;		case BINDER_TYPE_FDA: {			struct binder_fd_array_object *fda;			struct binder_buffer_object *parent;			uintptr_t parent_buffer;			u32 *fd_array;			size_t fd_index;			binder_size_t fd_buf_size;			fda = to_binder_fd_array_object(hdr);			parent = binder_validate_ptr(buffer, fda->parent,						     off_start,						     offp - off_start);			if (!parent) {				pr_err("transaction release %d bad parent offset",				       debug_id);				continue;			}			/*			 * Since the parent was already fixed up, convert it			 * back to kernel address space to access it			 */			parent_buffer = parent->buffer -				binder_alloc_get_user_buffer_offset(						&proc->alloc);			fd_buf_size = sizeof(u32) * fda->num_fds;			if (fda->num_fds >= SIZE_MAX / sizeof(u32)) {				pr_err("transaction release %d invalid number of fds (%lld)\n",				       debug_id, (u64)fda->num_fds);				continue;			}			if (fd_buf_size > parent->length ||			    fda->parent_offset > parent->length - fd_buf_size) {				/* No space for all file descriptors here. */				pr_err("transaction release %d not enough space for %lld fds in buffer\n",				       debug_id, (u64)fda->num_fds);				continue;			}			fd_array = (u32 *)(parent_buffer + fda->parent_offset);			for (fd_index = 0; fd_index < fda->num_fds; fd_index++)				task_close_fd(proc, fd_array[fd_index]);		} break;		default:			pr_err("transaction release %d bad object type %x\n",				debug_id, hdr->type);			break;		}	}
offp = off_start;
offp = off_start
offp
offp
off_start
off_start
offp < off_end
offp
offp
off_end
off_end
offp++
offp
offp
{		struct binder_object_header *hdr;		size_t object_size = binder_validate_object(buffer, *offp);		if (object_size == 0) {			pr_err("transaction release %d bad object at offset %lld, size %zd\n",			       debug_id, (u64)*offp, buffer->data_size);			continue;		}		hdr = (struct binder_object_header *)(buffer->data + *offp);		switch (hdr->type) {		case BINDER_TYPE_BINDER:		case BINDER_TYPE_WEAK_BINDER: {			struct flat_binder_object *fp;			struct binder_node *node;			fp = to_flat_binder_object(hdr);			node = binder_get_node(proc, fp->binder);			if (node == NULL) {				pr_err("transaction release %d bad node %016llx\n",				       debug_id, (u64)fp->binder);				break;			}			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        node %d u%016llx\n",				     node->debug_id, (u64)node->ptr);			binder_dec_node(node, hdr->type == BINDER_TYPE_BINDER,					0);			binder_put_node(node);		} break;		case BINDER_TYPE_HANDLE:		case BINDER_TYPE_WEAK_HANDLE: {			struct flat_binder_object *fp;			struct binder_ref_data rdata;			int ret;			fp = to_flat_binder_object(hdr);			ret = binder_dec_ref_for_handle(proc, fp->handle,				hdr->type == BINDER_TYPE_HANDLE, &rdata);			if (ret) {				pr_err("transaction release %d bad handle %d, ret = %d\n",				 debug_id, fp->handle, ret);				break;			}			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        ref %d desc %d\n",				     rdata.debug_id, rdata.desc);		} break;		case BINDER_TYPE_FD: {			struct binder_fd_object *fp = to_binder_fd_object(hdr);			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        fd %d\n", fp->fd);			if (failed_at)				task_close_fd(proc, fp->fd);		} break;		case BINDER_TYPE_PTR:			/*			 * Nothing to do here, this will get cleaned up when the			 * transaction buffer gets freed			 */			break;		case BINDER_TYPE_FDA: {			struct binder_fd_array_object *fda;			struct binder_buffer_object *parent;			uintptr_t parent_buffer;			u32 *fd_array;			size_t fd_index;			binder_size_t fd_buf_size;			fda = to_binder_fd_array_object(hdr);			parent = binder_validate_ptr(buffer, fda->parent,						     off_start,						     offp - off_start);			if (!parent) {				pr_err("transaction release %d bad parent offset",				       debug_id);				continue;			}			/*			 * Since the parent was already fixed up, convert it			 * back to kernel address space to access it			 */			parent_buffer = parent->buffer -				binder_alloc_get_user_buffer_offset(						&proc->alloc);			fd_buf_size = sizeof(u32) * fda->num_fds;			if (fda->num_fds >= SIZE_MAX / sizeof(u32)) {				pr_err("transaction release %d invalid number of fds (%lld)\n",				       debug_id, (u64)fda->num_fds);				continue;			}			if (fd_buf_size > parent->length ||			    fda->parent_offset > parent->length - fd_buf_size) {				/* No space for all file descriptors here. */				pr_err("transaction release %d not enough space for %lld fds in buffer\n",				       debug_id, (u64)fda->num_fds);				continue;			}			fd_array = (u32 *)(parent_buffer + fda->parent_offset);			for (fd_index = 0; fd_index < fda->num_fds; fd_index++)				task_close_fd(proc, fd_array[fd_index]);		} break;		default:			pr_err("transaction release %d bad object type %x\n",				debug_id, hdr->type);			break;		}	}
struct binder_object_header *hdr;
struct binder_object_header *hdr;
struct binder_object_header
binder_object_header
*hdr
*
hdr
size_t object_size = binder_validate_object(buffer, *offp);
size_t object_size = binder_validate_object(buffer, *offp);
size_t
size_t
object_size = binder_validate_object(buffer, *offp)
object_size
= binder_validate_object(buffer, *offp)
binder_validate_object(buffer, *offp)
binder_validate_object
binder_validate_object
buffer
buffer
*offp
offp
offp
if (object_size == 0) {			pr_err("transaction release %d bad object at offset %lld, size %zd\n",			       debug_id, (u64)*offp, buffer->data_size);			continue;		}
object_size == 0
object_size
object_size
0
{			pr_err("transaction release %d bad object at offset %lld, size %zd\n",			       debug_id, (u64)*offp, buffer->data_size);			continue;		}
pr_err("transaction release %d bad object at offset %lld, size %zd\n",			       debug_id, (u64)*offp, buffer->data_size);
pr_err("transaction release %d bad object at offset %lld, size %zd\n",			       debug_id, (u64)*offp, buffer->data_size)
pr_err
pr_err
"transaction release %d bad object at offset %lld, size %zd\n"
debug_id
debug_id
(u64)*offp
(u64)
u64
u64
offp
offp
buffer->data_size
buffer
buffer
data_size
continue;
hdr = (struct binder_object_header *)(buffer->data + *offp);
hdr = (struct binder_object_header *)(buffer->data + *offp)
hdr
hdr
(struct binder_object_header *)(buffer->data + *offp)
struct binder_object_header *
struct binder_object_header
binder_object_header
*
*
(buffer->data + *offp)
buffer->data + *offp
buffer->data
buffer
buffer
data
*offp
offp
offp
switch (hdr->type) {		case BINDER_TYPE_BINDER:		case BINDER_TYPE_WEAK_BINDER: {			struct flat_binder_object *fp;			struct binder_node *node;			fp = to_flat_binder_object(hdr);			node = binder_get_node(proc, fp->binder);			if (node == NULL) {				pr_err("transaction release %d bad node %016llx\n",				       debug_id, (u64)fp->binder);				break;			}			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        node %d u%016llx\n",				     node->debug_id, (u64)node->ptr);			binder_dec_node(node, hdr->type == BINDER_TYPE_BINDER,					0);			binder_put_node(node);		} break;		case BINDER_TYPE_HANDLE:		case BINDER_TYPE_WEAK_HANDLE: {			struct flat_binder_object *fp;			struct binder_ref_data rdata;			int ret;			fp = to_flat_binder_object(hdr);			ret = binder_dec_ref_for_handle(proc, fp->handle,				hdr->type == BINDER_TYPE_HANDLE, &rdata);			if (ret) {				pr_err("transaction release %d bad handle %d, ret = %d\n",				 debug_id, fp->handle, ret);				break;			}			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        ref %d desc %d\n",				     rdata.debug_id, rdata.desc);		} break;		case BINDER_TYPE_FD: {			struct binder_fd_object *fp = to_binder_fd_object(hdr);			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        fd %d\n", fp->fd);			if (failed_at)				task_close_fd(proc, fp->fd);		} break;		case BINDER_TYPE_PTR:			/*			 * Nothing to do here, this will get cleaned up when the			 * transaction buffer gets freed			 */			break;		case BINDER_TYPE_FDA: {			struct binder_fd_array_object *fda;			struct binder_buffer_object *parent;			uintptr_t parent_buffer;			u32 *fd_array;			size_t fd_index;			binder_size_t fd_buf_size;			fda = to_binder_fd_array_object(hdr);			parent = binder_validate_ptr(buffer, fda->parent,						     off_start,						     offp - off_start);			if (!parent) {				pr_err("transaction release %d bad parent offset",				       debug_id);				continue;			}			/*			 * Since the parent was already fixed up, convert it			 * back to kernel address space to access it			 */			parent_buffer = parent->buffer -				binder_alloc_get_user_buffer_offset(						&proc->alloc);			fd_buf_size = sizeof(u32) * fda->num_fds;			if (fda->num_fds >= SIZE_MAX / sizeof(u32)) {				pr_err("transaction release %d invalid number of fds (%lld)\n",				       debug_id, (u64)fda->num_fds);				continue;			}			if (fd_buf_size > parent->length ||			    fda->parent_offset > parent->length - fd_buf_size) {				/* No space for all file descriptors here. */				pr_err("transaction release %d not enough space for %lld fds in buffer\n",				       debug_id, (u64)fda->num_fds);				continue;			}			fd_array = (u32 *)(parent_buffer + fda->parent_offset);			for (fd_index = 0; fd_index < fda->num_fds; fd_index++)				task_close_fd(proc, fd_array[fd_index]);		} break;		default:			pr_err("transaction release %d bad object type %x\n",				debug_id, hdr->type);			break;		}
hdr->type
hdr
hdr
type
{		case BINDER_TYPE_BINDER:		case BINDER_TYPE_WEAK_BINDER: {			struct flat_binder_object *fp;			struct binder_node *node;			fp = to_flat_binder_object(hdr);			node = binder_get_node(proc, fp->binder);			if (node == NULL) {				pr_err("transaction release %d bad node %016llx\n",				       debug_id, (u64)fp->binder);				break;			}			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        node %d u%016llx\n",				     node->debug_id, (u64)node->ptr);			binder_dec_node(node, hdr->type == BINDER_TYPE_BINDER,					0);			binder_put_node(node);		} break;		case BINDER_TYPE_HANDLE:		case BINDER_TYPE_WEAK_HANDLE: {			struct flat_binder_object *fp;			struct binder_ref_data rdata;			int ret;			fp = to_flat_binder_object(hdr);			ret = binder_dec_ref_for_handle(proc, fp->handle,				hdr->type == BINDER_TYPE_HANDLE, &rdata);			if (ret) {				pr_err("transaction release %d bad handle %d, ret = %d\n",				 debug_id, fp->handle, ret);				break;			}			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        ref %d desc %d\n",				     rdata.debug_id, rdata.desc);		} break;		case BINDER_TYPE_FD: {			struct binder_fd_object *fp = to_binder_fd_object(hdr);			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        fd %d\n", fp->fd);			if (failed_at)				task_close_fd(proc, fp->fd);		} break;		case BINDER_TYPE_PTR:			/*			 * Nothing to do here, this will get cleaned up when the			 * transaction buffer gets freed			 */			break;		case BINDER_TYPE_FDA: {			struct binder_fd_array_object *fda;			struct binder_buffer_object *parent;			uintptr_t parent_buffer;			u32 *fd_array;			size_t fd_index;			binder_size_t fd_buf_size;			fda = to_binder_fd_array_object(hdr);			parent = binder_validate_ptr(buffer, fda->parent,						     off_start,						     offp - off_start);			if (!parent) {				pr_err("transaction release %d bad parent offset",				       debug_id);				continue;			}			/*			 * Since the parent was already fixed up, convert it			 * back to kernel address space to access it			 */			parent_buffer = parent->buffer -				binder_alloc_get_user_buffer_offset(						&proc->alloc);			fd_buf_size = sizeof(u32) * fda->num_fds;			if (fda->num_fds >= SIZE_MAX / sizeof(u32)) {				pr_err("transaction release %d invalid number of fds (%lld)\n",				       debug_id, (u64)fda->num_fds);				continue;			}			if (fd_buf_size > parent->length ||			    fda->parent_offset > parent->length - fd_buf_size) {				/* No space for all file descriptors here. */				pr_err("transaction release %d not enough space for %lld fds in buffer\n",				       debug_id, (u64)fda->num_fds);				continue;			}			fd_array = (u32 *)(parent_buffer + fda->parent_offset);			for (fd_index = 0; fd_index < fda->num_fds; fd_index++)				task_close_fd(proc, fd_array[fd_index]);		} break;		default:			pr_err("transaction release %d bad object type %x\n",				debug_id, hdr->type);			break;		}
case BINDER_TYPE_BINDER:
BINDER_TYPE_BINDER
BINDER_TYPE_BINDER
case BINDER_TYPE_WEAK_BINDER:
BINDER_TYPE_WEAK_BINDER
BINDER_TYPE_WEAK_BINDER
{			struct flat_binder_object *fp;			struct binder_node *node;			fp = to_flat_binder_object(hdr);			node = binder_get_node(proc, fp->binder);			if (node == NULL) {				pr_err("transaction release %d bad node %016llx\n",				       debug_id, (u64)fp->binder);				break;			}			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        node %d u%016llx\n",				     node->debug_id, (u64)node->ptr);			binder_dec_node(node, hdr->type == BINDER_TYPE_BINDER,					0);			binder_put_node(node);		}
struct flat_binder_object *fp;
struct flat_binder_object *fp;
struct flat_binder_object
flat_binder_object
*fp
*
fp
struct binder_node *node;
struct binder_node *node;
struct binder_node
binder_node
*node
*
node
fp = to_flat_binder_object(hdr);
fp = to_flat_binder_object(hdr)
fp
fp
to_flat_binder_object(hdr)
to_flat_binder_object
to_flat_binder_object
hdr
hdr
node = binder_get_node(proc, fp->binder);
node = binder_get_node(proc, fp->binder)
node
node
binder_get_node(proc, fp->binder)
binder_get_node
binder_get_node
proc
proc
fp->binder
fp
fp
binder
if (node == NULL) {				pr_err("transaction release %d bad node %016llx\n",				       debug_id, (u64)fp->binder);				break;			}
node == NULL
node
node
NULL
NULL
{				pr_err("transaction release %d bad node %016llx\n",				       debug_id, (u64)fp->binder);				break;			}
pr_err("transaction release %d bad node %016llx\n",				       debug_id, (u64)fp->binder);
pr_err("transaction release %d bad node %016llx\n",				       debug_id, (u64)fp->binder)
pr_err
pr_err
"transaction release %d bad node %016llx\n"
debug_id
debug_id
(u64)fp->binder
u64
u64
u64

fp->binder
fp
fp
binder
break;
binder_debug(BINDER_DEBUG_TRANSACTION,				     "        node %d u%016llx\n",				     node->debug_id, (u64)node->ptr);
binder_debug(BINDER_DEBUG_TRANSACTION,				     "        node %d u%016llx\n",				     node->debug_id, (u64)node->ptr)
binder_debug
binder_debug
BINDER_DEBUG_TRANSACTION
BINDER_DEBUG_TRANSACTION
"        node %d u%016llx\n"
node->debug_id
node
node
debug_id
(u64)node->ptr
u64
u64
u64

node->ptr
node
node
ptr
binder_dec_node(node, hdr->type == BINDER_TYPE_BINDER,					0);
binder_dec_node(node, hdr->type == BINDER_TYPE_BINDER,					0)
binder_dec_node
binder_dec_node
node
node
hdr->type == BINDER_TYPE_BINDER
hdr->type
hdr
hdr
type
BINDER_TYPE_BINDER
BINDER_TYPE_BINDER
0
binder_put_node(node);
binder_put_node(node)
binder_put_node
binder_put_node
node
node
break;
case BINDER_TYPE_HANDLE:
BINDER_TYPE_HANDLE
BINDER_TYPE_HANDLE
case BINDER_TYPE_WEAK_HANDLE:
BINDER_TYPE_WEAK_HANDLE
BINDER_TYPE_WEAK_HANDLE
{			struct flat_binder_object *fp;			struct binder_ref_data rdata;			int ret;			fp = to_flat_binder_object(hdr);			ret = binder_dec_ref_for_handle(proc, fp->handle,				hdr->type == BINDER_TYPE_HANDLE, &rdata);			if (ret) {				pr_err("transaction release %d bad handle %d, ret = %d\n",				 debug_id, fp->handle, ret);				break;			}			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        ref %d desc %d\n",				     rdata.debug_id, rdata.desc);		}
struct flat_binder_object *fp;
struct flat_binder_object *fp;
struct flat_binder_object
flat_binder_object
*fp
*
fp
struct binder_ref_data rdata;
struct binder_ref_data rdata;
struct binder_ref_data
binder_ref_data
rdata
rdata
int ret;
int ret;
int
ret
ret
fp = to_flat_binder_object(hdr);
fp = to_flat_binder_object(hdr)
fp
fp
to_flat_binder_object(hdr)
to_flat_binder_object
to_flat_binder_object
hdr
hdr
ret = binder_dec_ref_for_handle(proc, fp->handle,				hdr->type == BINDER_TYPE_HANDLE, &rdata);
ret = binder_dec_ref_for_handle(proc, fp->handle,				hdr->type == BINDER_TYPE_HANDLE, &rdata)
ret
ret
binder_dec_ref_for_handle(proc, fp->handle,				hdr->type == BINDER_TYPE_HANDLE, &rdata)
binder_dec_ref_for_handle
binder_dec_ref_for_handle
proc
proc
fp->handle
fp
fp
handle
hdr->type == BINDER_TYPE_HANDLE
hdr->type
hdr
hdr
type
BINDER_TYPE_HANDLE
BINDER_TYPE_HANDLE
&rdata
rdata
rdata
if (ret) {				pr_err("transaction release %d bad handle %d, ret = %d\n",				 debug_id, fp->handle, ret);				break;			}
ret
ret
{				pr_err("transaction release %d bad handle %d, ret = %d\n",				 debug_id, fp->handle, ret);				break;			}
pr_err("transaction release %d bad handle %d, ret = %d\n",				 debug_id, fp->handle, ret);
pr_err("transaction release %d bad handle %d, ret = %d\n",				 debug_id, fp->handle, ret)
pr_err
pr_err
"transaction release %d bad handle %d, ret = %d\n"
debug_id
debug_id
fp->handle
fp
fp
handle
ret
ret
break;
binder_debug(BINDER_DEBUG_TRANSACTION,				     "        ref %d desc %d\n",				     rdata.debug_id, rdata.desc);
binder_debug(BINDER_DEBUG_TRANSACTION,				     "        ref %d desc %d\n",				     rdata.debug_id, rdata.desc)
binder_debug
binder_debug
BINDER_DEBUG_TRANSACTION
BINDER_DEBUG_TRANSACTION
"        ref %d desc %d\n"
rdata.debug_id
rdata
rdata
debug_id
rdata.desc
rdata
rdata
desc
break;
case BINDER_TYPE_FD:
BINDER_TYPE_FD
BINDER_TYPE_FD
{			struct binder_fd_object *fp = to_binder_fd_object(hdr);			binder_debug(BINDER_DEBUG_TRANSACTION,				     "        fd %d\n", fp->fd);			if (failed_at)				task_close_fd(proc, fp->fd);		}
struct binder_fd_object *fp = to_binder_fd_object(hdr);
struct binder_fd_object *fp = to_binder_fd_object(hdr);
struct binder_fd_object
binder_fd_object
*fp = to_binder_fd_object(hdr)
*
fp
= to_binder_fd_object(hdr)
to_binder_fd_object(hdr)
to_binder_fd_object
to_binder_fd_object
hdr
hdr
binder_debug(BINDER_DEBUG_TRANSACTION,				     "        fd %d\n", fp->fd);
binder_debug(BINDER_DEBUG_TRANSACTION,				     "        fd %d\n", fp->fd)
binder_debug
binder_debug
BINDER_DEBUG_TRANSACTION
BINDER_DEBUG_TRANSACTION
"        fd %d\n"
fp->fd
fp
fp
fd
if (failed_at)				task_close_fd(proc, fp->fd);
failed_at
failed_at
task_close_fd(proc, fp->fd);
task_close_fd(proc, fp->fd)
task_close_fd
task_close_fd
proc
proc
fp->fd
fp
fp
fd
break;
case BINDER_TYPE_PTR:
BINDER_TYPE_PTR
BINDER_TYPE_PTR
break;
case BINDER_TYPE_FDA:
BINDER_TYPE_FDA
BINDER_TYPE_FDA
{			struct binder_fd_array_object *fda;			struct binder_buffer_object *parent;			uintptr_t parent_buffer;			u32 *fd_array;			size_t fd_index;			binder_size_t fd_buf_size;			fda = to_binder_fd_array_object(hdr);			parent = binder_validate_ptr(buffer, fda->parent,						     off_start,						     offp - off_start);			if (!parent) {				pr_err("transaction release %d bad parent offset",				       debug_id);				continue;			}			/*			 * Since the parent was already fixed up, convert it			 * back to kernel address space to access it			 */			parent_buffer = parent->buffer -				binder_alloc_get_user_buffer_offset(						&proc->alloc);			fd_buf_size = sizeof(u32) * fda->num_fds;			if (fda->num_fds >= SIZE_MAX / sizeof(u32)) {				pr_err("transaction release %d invalid number of fds (%lld)\n",				       debug_id, (u64)fda->num_fds);				continue;			}			if (fd_buf_size > parent->length ||			    fda->parent_offset > parent->length - fd_buf_size) {				/* No space for all file descriptors here. */				pr_err("transaction release %d not enough space for %lld fds in buffer\n",				       debug_id, (u64)fda->num_fds);				continue;			}			fd_array = (u32 *)(parent_buffer + fda->parent_offset);			for (fd_index = 0; fd_index < fda->num_fds; fd_index++)				task_close_fd(proc, fd_array[fd_index]);		}
struct binder_fd_array_object *fda;
struct binder_fd_array_object *fda;
struct binder_fd_array_object
binder_fd_array_object
*fda
*
fda
struct binder_buffer_object *parent;
struct binder_buffer_object *parent;
struct binder_buffer_object
binder_buffer_object
*parent
*
parent
uintptr_t parent_buffer;
uintptr_t parent_buffer;
uintptr_t
uintptr_t
parent_buffer
parent_buffer
u32 *fd_array;
u32 *fd_array;
u32
u32
*fd_array
*
fd_array
size_t fd_index;
size_t fd_index;
size_t
size_t
fd_index
fd_index
binder_size_t fd_buf_size;
binder_size_t fd_buf_size;
binder_size_t
binder_size_t
fd_buf_size
fd_buf_size
fda = to_binder_fd_array_object(hdr);
fda = to_binder_fd_array_object(hdr)
fda
fda
to_binder_fd_array_object(hdr)
to_binder_fd_array_object
to_binder_fd_array_object
hdr
hdr
parent = binder_validate_ptr(buffer, fda->parent,						     off_start,						     offp - off_start);
parent = binder_validate_ptr(buffer, fda->parent,						     off_start,						     offp - off_start)
parent
parent
binder_validate_ptr(buffer, fda->parent,						     off_start,						     offp - off_start)
binder_validate_ptr
binder_validate_ptr
buffer
buffer
fda->parent
fda
fda
parent
off_start
off_start
offp - off_start
offp
offp
off_start
off_start
if (!parent) {				pr_err("transaction release %d bad parent offset",				       debug_id);				continue;			}
!parent
parent
parent
{				pr_err("transaction release %d bad parent offset",				       debug_id);				continue;			}
pr_err("transaction release %d bad parent offset",				       debug_id);
pr_err("transaction release %d bad parent offset",				       debug_id)
pr_err
pr_err
"transaction release %d bad parent offset"
debug_id
debug_id
continue;
parent_buffer = parent->buffer -				binder_alloc_get_user_buffer_offset(						&proc->alloc);
parent_buffer = parent->buffer -				binder_alloc_get_user_buffer_offset(						&proc->alloc)
parent_buffer
parent_buffer
parent->buffer -				binder_alloc_get_user_buffer_offset(						&proc->alloc)
parent->buffer
parent
parent
buffer
binder_alloc_get_user_buffer_offset(						&proc->alloc)
binder_alloc_get_user_buffer_offset
binder_alloc_get_user_buffer_offset
&proc->alloc
proc->alloc
proc
proc
alloc
fd_buf_size = sizeof(u32) * fda->num_fds;
fd_buf_size = sizeof(u32) * fda->num_fds
fd_buf_size
fd_buf_size
sizeof(u32) * fda->num_fds
sizeof(u32)
u32
u32
u32

fda->num_fds
fda
fda
num_fds
if (fda->num_fds >= SIZE_MAX / sizeof(u32)) {				pr_err("transaction release %d invalid number of fds (%lld)\n",				       debug_id, (u64)fda->num_fds);				continue;			}
fda->num_fds >= SIZE_MAX / sizeof(u32)
fda->num_fds
fda
fda
num_fds
SIZE_MAX / sizeof(u32)
SIZE_MAX
SIZE_MAX
sizeof(u32)
u32
u32
u32

{				pr_err("transaction release %d invalid number of fds (%lld)\n",				       debug_id, (u64)fda->num_fds);				continue;			}
pr_err("transaction release %d invalid number of fds (%lld)\n",				       debug_id, (u64)fda->num_fds);
pr_err("transaction release %d invalid number of fds (%lld)\n",				       debug_id, (u64)fda->num_fds)
pr_err
pr_err
"transaction release %d invalid number of fds (%lld)\n"
debug_id
debug_id
(u64)fda->num_fds
u64
u64
u64

fda->num_fds
fda
fda
num_fds
continue;
if (fd_buf_size > parent->length ||			    fda->parent_offset > parent->length - fd_buf_size) {				/* No space for all file descriptors here. */				pr_err("transaction release %d not enough space for %lld fds in buffer\n",				       debug_id, (u64)fda->num_fds);				continue;			}
fd_buf_size > parent->length ||			    fda->parent_offset > parent->length - fd_buf_size
fd_buf_size > parent->length
fd_buf_size
fd_buf_size
parent->length
parent
parent
length
fda->parent_offset > parent->length - fd_buf_size
fda->parent_offset
fda
fda
parent_offset
parent->length - fd_buf_size
parent->length
parent
parent
length
fd_buf_size
fd_buf_size
{				/* No space for all file descriptors here. */				pr_err("transaction release %d not enough space for %lld fds in buffer\n",				       debug_id, (u64)fda->num_fds);				continue;			}
pr_err("transaction release %d not enough space for %lld fds in buffer\n",				       debug_id, (u64)fda->num_fds);
pr_err("transaction release %d not enough space for %lld fds in buffer\n",				       debug_id, (u64)fda->num_fds)
pr_err
pr_err
"transaction release %d not enough space for %lld fds in buffer\n"
debug_id
debug_id
(u64)fda->num_fds
u64
u64
u64

fda->num_fds
fda
fda
num_fds
continue;
fd_array = (u32 *)(parent_buffer + fda->parent_offset);
fd_array = (u32 *)(parent_buffer + fda->parent_offset)
fd_array
fd_array
(u32 *)(parent_buffer + fda->parent_offset)
u32 *
u32
u32
*
*
(parent_buffer + fda->parent_offset)
parent_buffer + fda->parent_offset
parent_buffer
parent_buffer
fda->parent_offset
fda
fda
parent_offset
for (fd_index = 0; fd_index < fda->num_fds; fd_index++)				task_close_fd(proc, fd_array[fd_index]);
fd_index = 0;
fd_index = 0
fd_index
fd_index
0
fd_index < fda->num_fds
fd_index
fd_index
fda->num_fds
fda
fda
num_fds
fd_index++
fd_index
fd_index
task_close_fd(proc, fd_array[fd_index]);
task_close_fd(proc, fd_array[fd_index])
task_close_fd
task_close_fd
proc
proc
fd_array[fd_index]
fd_array
fd_array
fd_index
fd_index
break;
default:
pr_err("transaction release %d bad object type %x\n",				debug_id, hdr->type);
pr_err("transaction release %d bad object type %x\n",				debug_id, hdr->type)
pr_err
pr_err
"transaction release %d bad object type %x\n"
debug_id
debug_id
hdr->type
hdr
hdr
type
break;
-----joern-----
(144,112,0)
(213,34,0)
(15,90,0)
(147,83,0)
(263,353,0)
(347,75,0)
(49,215,0)
(184,315,0)
(248,65,0)
(240,249,0)
(203,295,0)
(78,124,0)
(325,155,0)
(150,201,0)
(16,97,0)
(295,110,0)
(48,203,0)
(92,269,0)
(244,246,0)
(315,198,0)
(77,279,0)
(218,202,0)
(78,176,0)
(95,1,0)
(119,91,0)
(261,65,0)
(80,160,0)
(362,68,0)
(197,302,0)
(13,202,0)
(99,310,0)
(310,214,0)
(262,323,0)
(254,343,0)
(232,210,0)
(19,257,0)
(150,357,0)
(45,328,0)
(327,302,0)
(205,249,0)
(146,343,0)
(22,197,0)
(164,61,0)
(89,163,0)
(294,202,0)
(336,323,0)
(17,122,0)
(37,41,0)
(188,351,0)
(97,353,0)
(219,14,0)
(153,323,0)
(345,107,0)
(172,200,0)
(195,306,0)
(6,176,0)
(18,153,0)
(64,126,0)
(327,124,0)
(121,97,0)
(343,146,0)
(257,201,0)
(127,21,0)
(330,340,0)
(292,41,0)
(331,42,0)
(187,90,0)
(337,200,0)
(84,203,0)
(343,112,0)
(2,257,0)
(177,122,0)
(154,21,0)
(5,168,0)
(291,358,0)
(255,198,0)
(145,173,0)
(195,340,0)
(169,321,0)
(309,31,0)
(338,263,0)
(210,232,0)
(17,12,0)
(207,180,0)
(211,279,0)
(356,350,0)
(203,7,0)
(143,319,0)
(276,128,0)
(227,219,0)
(23,60,0)
(193,263,0)
(264,101,0)
(245,227,0)
(137,323,0)
(327,78,0)
(353,202,0)
(131,274,0)
(302,124,0)
(231,109,0)
(358,291,0)
(97,352,0)
(319,323,0)
(58,328,0)
(129,323,0)
(46,356,0)
(265,134,0)
(75,353,0)
(321,323,0)
(352,194,0)
(269,203,0)
(42,323,0)
(55,194,0)
(17,106,0)
(303,119,0)
(40,328,0)
(105,169,0)
(239,201,0)
(326,134,0)
(136,132,0)
(231,331,0)
(140,296,0)
(144,217,0)
(57,145,0)
(306,142,0)
(71,323,0)
(169,322,0)
(170,83,0)
(304,8,0)
(168,61,0)
(350,173,0)
(1,263,0)
(131,110,0)
(357,150,0)
(157,261,0)
(14,219,0)
(180,328,0)
(204,351,0)
(300,137,0)
(274,131,0)
(173,68,0)
(120,265,0)
(20,167,0)
(145,222,0)
(137,78,0)
(26,328,0)
(116,328,0)
(154,181,0)
(115,302,0)
(191,227,0)
(339,69,0)
(38,351,0)
(107,232,0)
(359,137,0)
(158,239,0)
(25,328,0)
(166,331,0)
(234,68,0)
(32,327,0)
(34,7,0)
(273,106,0)
(340,195,0)
(249,284,0)
(364,329,0)
(239,158,0)
(215,201,0)
(27,107,0)
(93,106,0)
(152,319,0)
(331,231,0)
(45,246,0)
(113,154,0)
(60,23,0)
(164,262,0)
(332,90,0)
(254,124,0)
(203,68,0)
(129,346,0)
(29,145,0)
(72,295,0)
(56,328,0)
(153,119,0)
(10,150,0)
(53,69,0)
(174,68,0)
(59,131,0)
(167,37,0)
(224,321,0)
(112,343,0)
(278,244,0)
(134,90,0)
(171,106,0)
(196,239,0)
(295,203,0)
(363,138,0)
(50,115,0)
(290,201,0)
(318,14,0)
(360,12,0)
(344,14,0)
(108,146,0)
(284,339,0)
(179,261,0)
(48,201,0)
(339,110,0)
(203,128,0)
(349,202,0)
(37,167,0)
(176,328,0)
(36,68,0)
(142,306,0)
(259,274,0)
(339,3,0)
(86,129,0)
(262,164,0)
(119,153,0)
(217,144,0)
(260,181,0)
(173,290,0)
(160,357,0)
(154,173,0)
(344,302,0)
(101,8,0)
(227,201,0)
(203,48,0)
(323,328,0)
(119,303,0)
(141,61,0)
(124,68,0)
(346,60,0)
(210,246,0)
(107,110,0)
(221,142,0)
(283,351,0)
(281,273,0)
(52,203,0)
(186,71,0)
(122,17,0)
(8,101,0)
(158,115,0)
(151,45,0)
(163,353,0)
(8,96,0)
(350,356,0)
(365,124,0)
(199,202,0)
(24,202,0)
(252,106,0)
(83,322,0)
(305,346,0)
(301,305,0)
(238,17,0)
(65,110,0)
(4,303,0)
(342,106,0)
(331,45,0)
(209,310,0)
(263,193,0)
(265,15,0)
(235,202,0)
(131,163,0)
(102,8,0)
(71,358,0)
(267,122,0)
(146,201,0)
(279,15,0)
(346,351,0)
(236,201,0)
(357,351,0)
(163,131,0)
(214,105,0)
(169,105,0)
(180,231,0)
(97,16,0)
(241,315,0)
(3,339,0)
(236,112,0)
(219,227,0)
(1,184,0)
(101,319,0)
(184,133,0)
(194,352,0)
(104,295,0)
(232,107,0)
(39,175,0)
(161,42,0)
(112,236,0)
(222,346,0)
(222,145,0)
(237,12,0)
(87,128,0)
(145,202,0)
(159,42,0)
(60,158,0)
(155,132,0)
(274,263,0)
(311,352,0)
(181,154,0)
(15,31,0)
(139,254,0)
(308,37,0)
(279,211,0)
(348,215,0)
(316,244,0)
(69,339,0)
(193,346,0)
(334,164,0)
(182,41,0)
(243,202,0)
(74,279,0)
(324,202,0)
(197,150,0)
(90,202,0)
(285,223,0)
(212,78,0)
(103,106,0)
(214,310,0)
(192,15,0)
(42,331,0)
(62,173,0)
(229,328,0)
(296,124,0)
(288,69,0)
(313,339,0)
(101,264,0)
(314,68,0)
(158,60,0)
(356,46,0)
(76,193,0)
(73,78,0)
(128,203,0)
(60,346,0)
(43,3,0)
(312,222,0)
(111,315,0)
(82,154,0)
(112,144,0)
(134,265,0)
(78,137,0)
(105,214,0)
(44,214,0)
(266,327,0)
(54,181,0)
(109,231,0)
(35,211,0)
(251,225,0)
(319,101,0)
(231,180,0)
(261,61,0)
(361,155,0)
(290,173,0)
(203,269,0)
(335,344,0)
(250,146,0)
(228,274,0)
(307,160,0)
(219,296,0)
(296,219,0)
(0,126,0)
(258,195,0)
(296,140,0)
(31,15,0)
(310,176,0)
(246,45,0)
(165,236,0)
(303,175,0)
(321,169,0)
(178,329,0)
(254,139,0)
(41,37,0)
(297,350,0)
(275,17,0)
(162,202,0)
(93,305,0)
(329,201,0)
(206,353,0)
(67,16,0)
(31,346,0)
(299,34,0)
(28,353,0)
(355,269,0)
(354,284,0)
(106,202,0)
(154,273,0)
(148,203,0)
(358,40,0)
(322,83,0)
(98,154,0)
(41,346,0)
(66,321,0)
(289,202,0)
(9,296,0)
(70,303,0)
(133,184,0)
(341,262,0)
(246,210,0)
(155,173,0)
(184,1,0)
(83,176,0)
(339,273,0)
(142,323,0)
(286,40,0)
(78,201,0)
(128,201,0)
(118,328,0)
(51,239,0)
(16,163,0)
(256,68,0)
(79,328,0)
(270,353,0)
(268,322,0)
(150,197,0)
(230,290,0)
(189,96,0)
(282,265,0)
(293,142,0)
(65,261,0)
(322,169,0)
(323,129,0)
(149,61,0)
(223,176,0)
(305,93,0)
(339,284,0)
(257,2,0)
(350,125,0)
(126,346,0)
(100,328,0)
(352,311,0)
(75,163,0)
(114,357,0)
(194,163,0)
(303,173,0)
(280,134,0)
(78,327,0)
(30,291,0)
(344,34,0)
(63,202,0)
(298,71,0)
(183,302,0)
(358,71,0)
(117,16,0)
(135,167,0)
(8,173,0)
(343,254,0)
(246,244,0)
(12,17,0)
(115,158,0)
(167,353,0)
(200,163,0)
(287,202,0)
(306,195,0)
(244,176,0)
(138,356,0)
(40,358,0)
(272,2,0)
(315,173,0)
(249,346,0)
(81,302,0)
(226,344,0)
(322,40,0)
(91,119,0)
(220,262,0)
(124,254,0)
(350,329,0)
(138,302,0)
(208,328,0)
(273,339,0)
(315,184,0)
(181,93,0)
(185,68,0)
(247,97,0)
(242,257,0)
(47,48,0)
(317,346,0)
(216,350,0)
(69,93,0)
(11,194,0)
(329,350,0)
(214,40,0)
(271,2,0)
(277,1,0)
(88,222,0)
(85,153,0)
(123,290,0)
(225,302,0)
(156,125,0)
(130,236,0)
(284,249,0)
(352,97,0)
(176,78,0)
(328,202,0)
(356,138,0)
(190,93,0)
(211,110,0)
(167,163,0)
(320,202,0)
(269,201,0)
(33,48,0)
(261,180,0)
(359,73,1)
(295,110,1)
(296,140,1)
(203,128,1)
(215,201,1)
(29,126,1)
(59,89,1)
(319,152,1)
(242,19,1)
(111,241,1)
(220,341,1)
(318,253,1)
(352,311,1)
(277,95,1)
(97,16,1)
(249,346,1)
(269,92,1)
(14,219,1)
(316,151,1)
(302,81,1)
(137,300,1)
(184,1,1)
(155,325,1)
(365,215,1)
(261,157,1)
(107,110,1)
(150,201,1)
(248,164,1)
(86,336,1)
(339,69,1)
(257,201,1)
(331,42,1)
(131,110,1)
(93,305,1)
(170,321,1)
(166,207,1)
(102,105,1)
(37,308,1)
(227,191,1)
(216,160,1)
(39,303,1)
(193,76,1)
(212,137,1)
(163,131,1)
(267,177,1)
(24,145,1)
(147,170,1)
(331,45,1)
(303,119,1)
(210,232,1)
(66,224,1)
(168,61,1)
(288,313,1)
(131,274,1)
(54,82,1)
(74,35,1)
(214,40,1)
(105,214,1)
(146,108,1)
(219,227,1)
(1,277,1)
(172,337,1)
(251,294,1)
(143,304,1)
(326,280,1)
(251,349,1)
(34,299,1)
(159,166,1)
(75,163,1)
(312,57,1)
(73,6,1)
(355,128,1)
(146,201,1)
(97,352,1)
(339,110,1)
(42,161,1)
(296,124,1)
(215,49,1)
(284,354,1)
(41,182,1)
(75,347,1)
(272,271,1)
(310,209,1)
(226,225,1)
(261,61,1)
(350,329,1)
(144,236,1)
(230,62,1)
(154,181,1)
(244,176,1)
(104,72,1)
(345,27,1)
(3,43,1)
(108,250,1)
(40,358,1)
(43,284,1)
(309,192,1)
(341,334,1)
(33,47,1)
(53,288,1)
(299,213,1)
(203,48,1)
(128,87,1)
(85,18,1)
(11,16,1)
(358,291,1)
(193,346,1)
(13,164,1)
(78,327,1)
(336,126,1)
(195,340,1)
(298,186,1)
(148,84,1)
(64,0,1)
(329,178,1)
(67,121,1)
(135,37,1)
(101,319,1)
(105,169,1)
(343,112,1)
(347,167,1)
(358,71,1)
(192,126,1)
(137,323,1)
(265,282,1)
(327,124,1)
(340,330,1)
(343,146,1)
(223,176,1)
(124,254,1)
(9,318,1)
(239,196,1)
(285,176,1)
(48,33,1)
(257,242,1)
(197,302,1)
(300,359,1)
(301,190,1)
(123,230,1)
(60,158,1)
(236,201,1)
(214,310,1)
(275,238,1)
(142,221,1)
(15,31,1)
(251,136,1)
(70,306,1)
(259,228,1)
(186,291,1)
(279,77,1)
(71,323,1)
(167,37,1)
(142,323,1)
(322,40,1)
(180,231,1)
(179,248,1)
(126,64,1)
(258,142,1)
(225,302,1)
(121,247,1)
(263,193,1)
(211,279,1)
(305,346,1)
(35,333,1)
(20,97,1)
(189,8,1)
(8,173,1)
(360,275,1)
(239,201,1)
(251,156,1)
(233,273,1)
(225,251,1)
(350,173,1)
(333,134,1)
(251,162,1)
(194,55,1)
(89,263,1)
(127,154,1)
(349,17,1)
(344,34,1)
(232,107,1)
(138,363,1)
(2,257,1)
(228,59,1)
(183,34,1)
(238,233,1)
(154,98,1)
(114,344,1)
(344,335,1)
(265,15,1)
(88,312,1)
(117,67,1)
(181,260,1)
(2,272,1)
(254,343,1)
(49,348,1)
(80,357,1)
(315,184,1)
(307,80,1)
(141,149,1)
(334,61,1)
(319,323,1)
(251,255,1)
(226,302,1)
(71,298,1)
(101,264,1)
(0,346,1)
(182,292,1)
(327,266,1)
(338,126,1)
(77,74,1)
(313,281,1)
(154,273,1)
(155,173,1)
(72,148,1)
(291,30,1)
(34,7,1)
(57,29,1)
(119,91,1)
(60,23,1)
(348,203,1)
(48,201,1)
(323,129,1)
(274,263,1)
(113,233,1)
(178,364,1)
(157,179,1)
(55,11,1)
(261,180,1)
(237,360,1)
(115,50,1)
(247,200,1)
(92,355,1)
(306,142,1)
(165,130,1)
(306,195,1)
(253,124,1)
(61,141,1)
(65,261,1)
(219,296,1)
(308,41,1)
(32,212,1)
(245,296,1)
(222,88,1)
(356,138,1)
(128,201,1)
(365,2,1)
(181,93,1)
(292,20,1)
(145,222,1)
(107,345,1)
(205,240,1)
(37,41,1)
(251,127,1)
(168,5,1)
(297,216,1)
(290,123,1)
(222,346,1)
(31,346,1)
(310,176,1)
(150,197,1)
(162,126,1)
(81,183,1)
(153,323,1)
(44,306,1)
(183,14,1)
(344,14,1)
(184,133,1)
(339,3,1)
(47,295,1)
(200,172,1)
(357,150,1)
(144,217,1)
(51,317,1)
(266,32,1)
(356,46,1)
(293,40,1)
(203,7,1)
(236,165,1)
(120,326,1)
(278,316,1)
(50,239,1)
(279,15,1)
(41,346,1)
(5,65,1)
(339,284,1)
(78,124,1)
(167,135,1)
(269,201,1)
(262,220,1)
(169,321,1)
(290,201,1)
(280,15,1)
(130,146,1)
(304,102,1)
(191,245,1)
(334,168,1)
(99,44,1)
(337,163,1)
(305,301,1)
(284,249,1)
(294,333,1)
(254,139,1)
(164,61,1)
(224,214,1)
(286,45,1)
(129,346,1)
(251,189,1)
(361,223,1)
(260,54,1)
(363,297,1)
(16,117,1)
(149,180,1)
(344,302,1)
(282,120,1)
(122,267,1)
(161,159,1)
(136,155,1)
(45,246,1)
(153,85,1)
(52,269,1)
(76,338,1)
(296,9,1)
(119,153,1)
(346,60,1)
(251,13,1)
(134,265,1)
(115,302,1)
(176,78,1)
(1,263,1)
(194,163,1)
(240,69,1)
(31,309,1)
(335,226,1)
(203,52,1)
(268,83,1)
(177,12,1)
(244,278,1)
(87,276,1)
(164,262,1)
(250,365,1)
(12,237,1)
(231,331,1)
(262,323,1)
(82,113,1)
(19,215,1)
(154,173,1)
(8,101,1)
(221,293,1)
(354,249,1)
(65,110,1)
(160,357,1)
(281,93,1)
(352,194,1)
(42,323,1)
(16,163,1)
(329,201,1)
(138,302,1)
(227,201,1)
(83,147,1)
(152,143,1)
(69,93,1)
(83,176,1)
(251,39,1)
(203,295,1)
(30,286,1)
(322,268,1)
(22,10,1)
(255,315,1)
(145,173,1)
(251,287,1)
(27,244,1)
(274,259,1)
(158,239,1)
(209,99,1)
(249,205,1)
(325,361,1)
(322,83,1)
(95,111,1)
(211,110,1)
(160,307,1)
(173,290,1)
(126,346,1)
(190,126,1)
(330,258,1)
(321,323,1)
(327,302,1)
(350,356,1)
(294,211,1)
(223,285,1)
(196,51,1)
(169,322,1)
(213,253,1)
(158,115,1)
(112,144,1)
(4,70,1)
(17,122,1)
(246,244,1)
(321,66,1)
(10,114,1)
(315,173,1)
(129,86,1)
(302,124,1)
(69,53,1)
(276,48,1)
(84,173,1)
(197,22,1)
(98,181,1)
(151,223,1)
(273,339,1)
(364,356,1)
(167,163,1)
(207,105,1)
(271,257,1)
(200,163,1)
(17,12,1)
(6,323,1)
(78,137,1)
(246,210,1)
(241,200,1)
(231,109,1)
(303,173,1)
(203,269,1)
(317,160,1)
(287,75,1)
(251,24,1)
(112,236,1)
(78,201,1)
(295,104,1)
(94,344,1)
(156,350,1)
(18,4,1)
(135,200,2)
(101,264,2)
(203,295,2)
(327,302,2)
(302,124,2)
(161,105,2)
(137,323,2)
(193,126,2)
(160,357,2)
(197,344,2)
(309,126,2)
(155,173,2)
(322,83,2)
(11,200,2)
(241,200,2)
(285,126,2)
(327,126,2)
(222,346,2)
(278,223,2)
(99,306,2)
(114,344,2)
(331,45,2)
(97,352,2)
(151,223,2)
(340,223,2)
(296,140,2)
(306,223,2)
(164,61,2)
(61,105,2)
(329,160,2)
(315,173,2)
(77,333,2)
(200,163,2)
(69,93,2)
(57,126,2)
(55,200,2)
(112,144,2)
(134,265,2)
(356,138,2)
(352,311,2)
(339,110,2)
(297,160,2)
(257,201,2)
(358,71,2)
(227,201,2)
(335,344,2)
(16,163,2)
(184,1,2)
(1,200,2)
(336,126,2)
(149,105,2)
(69,126,2)
(167,37,2)
(272,215,2)
(164,164,2)
(141,105,2)
(193,346,2)
(86,126,2)
(215,201,2)
(203,48,2)
(168,61,2)
(268,214,2)
(277,200,2)
(128,201,2)
(333,126,2)
(70,306,2)
(167,163,2)
(334,105,2)
(306,142,2)
(281,126,2)
(121,200,2)
(224,214,2)
(78,137,2)
(303,306,2)
(4,306,2)
(344,14,2)
(73,126,2)
(344,34,2)
(346,160,2)
(22,344,2)
(219,296,2)
(292,200,2)
(244,176,2)
(1,263,2)
(158,115,2)
(228,126,2)
(213,253,2)
(262,323,2)
(209,306,2)
(318,253,2)
(41,346,2)
(262,105,2)
(267,233,2)
(154,233,2)
(144,217,2)
(8,105,2)
(164,262,2)
(145,222,2)
(220,105,2)
(8,173,2)
(102,105,2)
(327,124,2)
(131,110,2)
(147,214,2)
(41,200,2)
(37,41,2)
(322,40,2)
(236,201,2)
(343,112,2)
(319,105,2)
(255,200,2)
(27,223,2)
(154,173,2)
(34,7,2)
(284,249,2)
(357,344,2)
(303,173,2)
(295,110,2)
(286,223,2)
(2,215,2)
(210,223,2)
(279,15,2)
(350,356,2)
(158,160,2)
(78,201,2)
(237,233,2)
(194,163,2)
(162,126,2)
(78,126,2)
(138,160,2)
(95,200,2)
(191,253,2)
(169,214,2)
(239,201,2)
(323,126,2)
(126,160,2)
(345,223,2)
(111,200,2)
(211,333,2)
(9,253,2)
(17,233,2)
(30,223,2)
(154,273,2)
(274,263,2)
(352,194,2)
(101,319,2)
(119,153,2)
(298,223,2)
(251,344,2)
(129,346,2)
(65,164,2)
(273,339,2)
(296,253,2)
(261,180,2)
(280,126,2)
(89,126,2)
(360,233,2)
(222,126,2)
(127,233,2)
(337,126,2)
(105,169,2)
(173,290,2)
(312,126,2)
(357,150,2)
(261,61,2)
(42,323,2)
(358,291,2)
(239,160,2)
(60,160,2)
(232,107,2)
(316,223,2)
(288,126,2)
(176,126,2)
(105,306,2)
(74,333,2)
(163,126,2)
(266,126,2)
(363,160,2)
(154,181,2)
(24,126,2)
(293,223,2)
(17,122,2)
(120,126,2)
(170,214,2)
(231,105,2)
(60,158,2)
(339,3,2)
(271,215,2)
(317,160,2)
(82,233,2)
(207,105,2)
(67,200,2)
(172,126,2)
(32,126,2)
(346,60,2)
(88,126,2)
(329,201,2)
(131,126,2)
(12,233,2)
(262,164,2)
(350,329,2)
(5,164,2)
(119,91,2)
(290,201,2)
(304,105,2)
(167,200,2)
(349,233,2)
(156,160,2)
(19,215,2)
(31,126,2)
(200,126,2)
(231,109,2)
(323,129,2)
(219,253,2)
(78,327,2)
(214,310,2)
(331,105,2)
(150,201,2)
(83,214,2)
(319,323,2)
(181,233,2)
(299,253,2)
(221,223,2)
(315,184,2)
(153,323,2)
(37,200,2)
(259,126,2)
(126,346,2)
(240,126,2)
(296,124,2)
(6,126,2)
(356,160,2)
(180,231,2)
(76,126,2)
(269,201,2)
(17,12,2)
(137,126,2)
(15,126,2)
(307,344,2)
(134,126,2)
(225,302,2)
(83,176,2)
(136,223,2)
(313,126,2)
(75,163,2)
(344,344,2)
(71,323,2)
(190,126,2)
(197,302,2)
(169,321,2)
(184,200,2)
(258,223,2)
(182,200,2)
(214,40,2)
(331,42,2)
(338,126,2)
(184,133,2)
(254,343,2)
(261,164,2)
(226,344,2)
(343,146,2)
(194,200,2)
(18,306,2)
(78,124,2)
(195,340,2)
(66,214,2)
(14,219,2)
(45,246,2)
(113,233,2)
(20,200,2)
(231,331,2)
(300,126,2)
(93,126,2)
(59,126,2)
(112,236,2)
(40,223,2)
(282,126,2)
(246,210,2)
(249,126,2)
(65,110,2)
(181,93,2)
(142,223,2)
(279,333,2)
(2,257,2)
(339,69,2)
(60,23,2)
(189,105,2)
(322,214,2)
(339,284,2)
(310,306,2)
(150,344,2)
(129,126,2)
(155,223,2)
(157,164,2)
(119,306,2)
(186,223,2)
(75,200,2)
(211,110,2)
(248,164,2)
(85,306,2)
(223,176,2)
(210,232,2)
(344,302,2)
(117,200,2)
(246,244,2)
(238,233,2)
(223,126,2)
(359,126,2)
(145,126,2)
(14,253,2)
(0,160,2)
(179,164,2)
(176,78,2)
(356,46,2)
(352,200,2)
(115,160,2)
(216,160,2)
(80,344,2)
(150,197,2)
(42,105,2)
(315,200,2)
(146,201,2)
(143,105,2)
(138,302,2)
(107,223,2)
(51,160,2)
(50,160,2)
(260,233,2)
(212,126,2)
(158,239,2)
(257,215,2)
(53,126,2)
(107,110,2)
(263,193,2)
(220,164,2)
(160,344,2)
(321,214,2)
(205,126,2)
(34,253,2)
(254,139,2)
(203,269,2)
(364,160,2)
(180,105,2)
(334,164,2)
(192,126,2)
(195,223,2)
(93,305,2)
(196,160,2)
(219,227,2)
(242,215,2)
(225,344,2)
(163,131,2)
(169,322,2)
(97,200,2)
(105,214,2)
(247,200,2)
(65,261,2)
(203,7,2)
(341,164,2)
(249,346,2)
(274,126,2)
(305,126,2)
(358,223,2)
(43,126,2)
(214,306,2)
(244,223,2)
(265,126,2)
(115,302,2)
(166,105,2)
(71,223,2)
(48,201,2)
(275,233,2)
(45,223,2)
(152,105,2)
(153,306,2)
(227,253,2)
(310,176,2)
(326,126,2)
(54,233,2)
(122,233,2)
(265,15,2)
(35,333,2)
(341,105,2)
(308,200,2)
(10,344,2)
(347,200,2)
(29,126,2)
(131,274,2)
(101,105,2)
(354,126,2)
(306,195,2)
(325,223,2)
(301,126,2)
(39,306,2)
(40,358,2)
(273,126,2)
(168,164,2)
(98,233,2)
(246,223,2)
(8,101,2)
(211,279,2)
(291,223,2)
(164,105,2)
(339,126,2)
(64,160,2)
(361,223,2)
(13,105,2)
(97,16,2)
(178,160,2)
(294,126,2)
(284,126,2)
(159,105,2)
(3,126,2)
(263,126,2)
(321,323,2)
(177,233,2)
(245,253,2)
(44,306,2)
(124,254,2)
(203,128,2)
(233,126,2)
(15,31,2)
(287,200,2)
(145,173,2)
(350,160,2)
(330,223,2)
(305,346,2)
(16,200,2)
(303,119,2)
(142,323,2)
(232,223,2)
(350,173,2)
(31,346,2)
-----------------------------------
(0,hdr)
(1,fp->binder)
(2,binder_dec_node(buffer->target_node, 1, 0)
(3,&rdata)
(4,debug_id)
(5,fd_index)
(6,parent)
(7,binder_size_t *failed_at)
(8,pr_err("transaction release %d not enough space for %lld fds in buffer\\n",\n\\n\\t\\t\\t\\t       debug_id, (u64)
(9,off_start)
(10,buffer)
(11,node)
(12,rdata.debug_id)
(13,break;)
(14,off_end = (void *)
(15,*fp = to_binder_fd_object(hdr)
(16,node->debug_id)
(17,binder_debug(BINDER_DEBUG_TRANSACTION,\n\\n\\t\\t\\t\\t     "        ref %d desc %d\\n",\n\\n\\t\\t\\t\\t     rdata.debug_id, rdata.desc)
(18,fda)
(19,buffer)
(20,node)
(21,)
(22,offp)
(23,struct binder_object_header *)
(24,break;)
(25,fda)
(26,fd_buf_size)
(27,proc)
(28,node)
(29,"transaction release %d bad object type %x\\n")
(30,u32)
(31,to_binder_fd_object(hdr)
(32,offp)
(33,debug_id)
(34,off_end = failed_at)
(35,proc)
(36,offp)
(37,hdr->type == BINDER_TYPE_BINDER)
(38,hdr)
(39,continue;)
(40,fd_buf_size = sizeof(u32)
(41,hdr->type)
(42,fda->parent_offset)
(43,rdata)
(44,fd_buf_size)
(45,parent_buffer = parent->buffer -\n\\n\\t\\t\\t\\tbinder_alloc_get_user_buffer_offset(\n\\n\\t\\t\\t\\t\\t\\t&proc->alloc)
(46,u64)
(47,buffer)
(48,buffer->debug_id)
(49,target_node)
(50,offp)
(51,buffer)
(52,failed_at)
(53,handle)
(54,fp)
(55,ptr)
(56,if (!parent)
(57,debug_id)
(58,parent)
(59,proc)
(60,(struct binder_object_header *)
(61,fd_index = 0)
(62,debug_id)
(63,case BINDER_TYPE_FD:)
(64,type)
(65,task_close_fd(proc, fd_array[fd_index])
(66,parent_offset)
(67,node)
(68,)
(69,fp->handle)
(70,"transaction release %d invalid number of fds (%lld)
(71,fda->num_fds)
(72,proc)
(73,buffer)
(74,fp)
(75,binder_put_node(node)
(76,hdr)
(77,fd)
(78,binder_validate_ptr(buffer, fda->parent,\n\\n\\t\\t\\t\\t\\t\\t     off_start,\n\\n\\t\\t\\t\\t\\t\\t     offp - off_start)
(79,parent_buffer)
(80,object_size)
(81,off_start)
(82,debug_id)
(83,parent->length)
(84,BINDER_DEBUG_TRANSACTION)
(85,num_fds)
(86,hdr)
(87,data_size)
(88,type)
(89,node)
(90,)
(91,u64)
(92,offsets_size)
(93,fp = to_flat_binder_object(hdr)
(94,RET)
(95,fp)
(96,)
(97,binder_debug(BINDER_DEBUG_TRANSACTION,\n\\n\\t\\t\\t\\t     "        node %d u%016llx\\n",\n\\n\\t\\t\\t\\t     node->debug_id, (u64)
(98,ret)
(99,parent)
(100,for (fd_index = 0; fd_index < fda->num_fds; fd_index++)
(101,(u64)
(102,"transaction release %d not enough space for %lld fds in buffer\\n")
(103,if (ret)
(104,pid)
(105,fd_buf_size > parent->length ||\n\\n\\t\\t\\t    fda->parent_offset > parent->length - fd_buf_size)
(106,)
(107,proc->alloc)
(108,data)
(109,u32 *)
(110,struct binder_proc *proc)
(111,debug_id)
(112,ALIGN(buffer->data_size, sizeof(void *)
(113,"transaction release %d bad handle %d, ret = %d\\n")
(114,object_size)
(115,*offp)
(116,if (fd_buf_size > parent->length ||\n\\n\\t\\t\\t    fda->parent_offset > parent->length - fd_buf_size)
(117,debug_id)
(118,if (fda->num_fds >= SIZE_MAX / sizeof(u32)
(119,(u64)
(120,fp)
(121,"        node %d u%016llx\\n")
(122,rdata.desc)
(123,debug_id)
(124,off_start = (binder_size_t *)
(125,)
(126,hdr->type)
(127,break;)
(128,buffer->data_size)
(129,to_binder_fd_array_object(hdr)
(130,buffer)
(131,binder_get_node(proc, fp->binder)
(132,)
(133,u64)
(134,binder_debug(BINDER_DEBUG_TRANSACTION,\n\\n\\t\\t\\t\\t     "        fd %d\\n", fp->fd)
(135,0)
(136,continue;)
(137,fda->parent)
(138,*offp)
(139,binder_size_t *)
(140,void *)
(141,0)
(142,fda->num_fds)
(143,fda)
(144,sizeof(void *)
(145,pr_err("transaction release %d bad object type %x\\n",\n\\n\\t\\t\\t\\tdebug_id, hdr->type)
(146,buffer->data)
(147,length)
(148,"%d buffer release %d, size %zd-%zd, failed at %p\\n")
(149,fd_index)
(150,binder_validate_object(buffer, *offp)
(151,parent_buffer)
(152,num_fds)
(153,fda->num_fds)
(154,pr_err("transaction release %d bad handle %d, ret = %d\\n",\n\\n\\t\\t\\t\\t debug_id, fp->handle, ret)
(155,pr_err("transaction release %d bad parent offset",\n\\n\\t\\t\\t\\t       debug_id)
(156,continue;)
(157,fd_index)
(158,buffer->data + *offp)
(159,fda)
(160,object_size == 0)
(161,parent_offset)
(162,break;)
(163,node = binder_get_node(proc, fp->binder)
(164,fd_index < fda->num_fds)
(165,data_size)
(166,parent_buffer)
(167,binder_dec_node(node, hdr->type == BINDER_TYPE_BINDER,\n\\n\\t\\t\\t\\t\\t0)
(168,fd_index++)
(169,fda->parent_offset > parent->length - fd_buf_size)
(170,parent)
(171,fp)
(172,NULL)
(173,debug_id = buffer->debug_id)
(174,debug_id)
(175,)
(176,parent = binder_validate_ptr(buffer, fda->parent,\n\\n\\t\\t\\t\\t\\t\\t     off_start,\n\\n\\t\\t\\t\\t\\t\\t     offp - off_start)
(177,rdata)
(178,data_size)
(179,fd_array)
(180,fd_array = (u32 *)
(181,fp->handle)
(182,type)
(183,offp)
(184,(u64)
(185,if (buffer->target_node)
(186,fda)
(187,fp)
(188,switch (hdr->type)
(189,continue;)
(190,fp)
(191,offsets_size)
(192,fp)
(193,to_flat_binder_object(hdr)
(194,node->ptr)
(195,SIZE_MAX / sizeof(u32)
(196,data)
(197,*offp)
(198,)
(199,default:)
(200,node == NULL)
(201,struct binder_buffer *buffer)
(202,)
(203,binder_debug(BINDER_DEBUG_TRANSACTION,\n\\n\\t\\t     "%d buffer release %d, size %zd-%zd, failed at %p\\n",\n\\n\\t\\t     proc->pid, buffer->debug_id,\n\\n\\t\\t     buffer->data_size, buffer->offsets_size, failed_at)
(204,if (object_size == 0)
(205,type)
(206,fp)
(207,fd_array)
(208,fd_array)
(209,length)
(210,binder_alloc_get_user_buffer_offset(\n\\n\\t\\t\\t\\t\\t\\t&proc->alloc)
(211,task_close_fd(proc, fp->fd)
(212,off_start)
(213,off_end)
(214,fd_buf_size > parent->length)
(215,buffer->target_node)
(216,"transaction release %d bad object at offset %lld, size %zd\\n")
(217,void *)
(218,case BINDER_TYPE_PTR:)
(219,(void *)
(220,num_fds)
(221,num_fds)
(222,hdr->type)
(223,!parent)
(224,fda)
(225,offp++)
(226,offp)
(227,buffer->offsets_size)
(228,fp)
(229,fd_index)
(230,buffer)
(231,(u32 *)
(232,&proc->alloc)
(233,ret)
(234,off_start)
(235,case BINDER_TYPE_BINDER:)
(236,buffer->data_size)
(237,debug_id)
(238,BINDER_DEBUG_TRANSACTION)
(239,buffer->data)
(240,hdr)
(241,"transaction release %d bad node %016llx\\n")
(242,target_node)
(243,case BINDER_TYPE_FDA:)
(244,parent->buffer)
(245,buffer)
(246,parent->buffer -\n\\n\\t\\t\\t\\tbinder_alloc_get_user_buffer_offset(\n\\n\\t\\t\\t\\t\\t\\t&proc->alloc)
(247,BINDER_DEBUG_TRANSACTION)
(248,proc)
(249,hdr->type)
(250,buffer)
(251,offp)
(252,rdata)
(253,failed_at)
(254,(binder_size_t *)
(255,break;)
(256,for (offp = off_start; offp < off_end; offp++)
(257,buffer->target_node)
(258,SIZE_MAX)
(259,binder)
(260,handle)
(261,fd_array[fd_index])
(262,fda->num_fds)
(263,fp = to_flat_binder_object(hdr)
(264,u64)
(265,fp->fd)
(266,off_start)
(267,desc)
(268,fd_buf_size)
(269,buffer->offsets_size)
(270,if (node == NULL)
(271,1)
(272,0)
(273,ret = binder_dec_ref_for_handle(proc, fp->handle,\n\\n\\t\\t\\t\\thdr->type == BINDER_TYPE_HANDLE, &rdata)
(274,fp->binder)
(275,"        ref %d desc %d\\n")
(276,buffer)
(277,binder)
(278,buffer)
(279,fp->fd)
(280,BINDER_DEBUG_TRANSACTION)
(281,ret)
(282,fd)
(283,object_size)
(284,hdr->type == BINDER_TYPE_HANDLE)
(285,parent)
(286,fd_buf_size)
(287,break;)
(288,fp)
(289,case BINDER_TYPE_HANDLE:)
(290,buffer->debug_id)
(291,sizeof(u32)
(292,hdr)
(293,fda)
(294,break;)
(295,proc->pid)
(296,(void *)
(297,debug_id)
(298,num_fds)
(299,failed_at)
(300,parent)
(301,hdr)
(302,offp = off_start)
(303,pr_err("transaction release %d invalid number of fds (%lld)
(304,debug_id)
(305,to_flat_binder_object(hdr)
(306,fda->num_fds >= SIZE_MAX / sizeof(u32)
(307,0)
(308,BINDER_TYPE_BINDER)
(309,hdr)
(310,parent->length)
(311,u64)
(312,hdr)
(313,proc)
(314,if (failed_at)
(315,pr_err("transaction release %d bad node %016llx\\n",\n\\n\\t\\t\\t\\t       debug_id, (u64)
(316,parent)
(317,hdr)
(318,off_end)
(319,fda->num_fds)
(320,case BINDER_TYPE_WEAK_BINDER:)
(321,fda->parent_offset)
(322,parent->length - fd_buf_size)
(323,fda = to_binder_fd_array_object(hdr)
(324,case BINDER_TYPE_WEAK_HANDLE:)
(325,debug_id)
(326,"        fd %d\\n")
(327,offp - off_start)
(328,)
(329,buffer->data_size)
(330,u32)
(331,parent_buffer + fda->parent_offset)
(332,if (failed_at)
(333,failed_at)
(334,fd_index)
(335,off_end)
(336,fda)
(337,node)
(338,fp)
(339,binder_dec_ref_for_handle(proc, fp->handle,\n\\n\\t\\t\\t\\thdr->type == BINDER_TYPE_HANDLE, &rdata)
(340,sizeof(u32)
(341,fda)
(342,ret)
(343,buffer->data +\n\\n\\t\\t\\t\\t      ALIGN(buffer->data_size, sizeof(void *)
(344,offp < off_end)
(345,alloc)
(346,hdr = (struct binder_object_header *)
(347,node)
(348,buffer)
(349,break;)
(350,pr_err("transaction release %d bad object at offset %lld, size %zd\\n",\n\\n\\t\\t\\t       debug_id, (u64)
(351,)
(352,(u64)
(353,)
(354,BINDER_TYPE_HANDLE)
(355,buffer)
(356,(u64)
(357,object_size = binder_validate_object(buffer, *offp)
(358,sizeof(u32)
(359,fda)
(360,rdata)
(361,"transaction release %d bad parent offset")
(362,off_end)
(363,offp)
(364,buffer)
(365,off_start)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^