-----label-----
1
-----code-----
int v4l2_query_ext_ctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_query_ext_ctrl *qc)
{
	const unsigned next_flags = V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND;
	u32 id = qc->id & V4L2_CTRL_ID_MASK;
	struct v4l2_ctrl_ref *ref;
	struct v4l2_ctrl *ctrl;

	if (hdl == NULL)
		return -EINVAL;

	mutex_lock(hdl->lock);

	/* Try to find it */
	ref = find_ref(hdl, id);

	if ((qc->id & next_flags) && !list_empty(&hdl->ctrl_refs)) {
		bool is_compound;
		/* Match any control that is not hidden */
		unsigned mask = 1;
		bool match = false;

		if ((qc->id & next_flags) == V4L2_CTRL_FLAG_NEXT_COMPOUND) {
			/* Match any hidden control */
			match = true;
		} else if ((qc->id & next_flags) == next_flags) {
			/* Match any control, compound or not */
			mask = 0;
		}

		/* Find the next control with ID > qc->id */

		/* Did we reach the end of the control list? */
		if (id >= node2id(hdl->ctrl_refs.prev)) {
			ref = NULL; /* Yes, so there is no next control */
		} else if (ref) {
			/* We found a control with the given ID, so just get
			   the next valid one in the list. */
			list_for_each_entry_continue(ref, &hdl->ctrl_refs, node) {
				is_compound =
					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;
				if (id < ref->ctrl->id &&
				    (is_compound & mask) == match)
					break;
			}
			if (&ref->node == &hdl->ctrl_refs)
				ref = NULL;
		} else {
			/* No control with the given ID exists, so start
			   searching for the next largest ID. We know there
			   is one, otherwise the first 'if' above would have
			   been true. */
			list_for_each_entry(ref, &hdl->ctrl_refs, node) {
				is_compound =
					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;
				if (id < ref->ctrl->id &&
				    (is_compound & mask) == match)
					break;
			}
			if (&ref->node == &hdl->ctrl_refs)
				ref = NULL;
		}
	}
	mutex_unlock(hdl->lock);

	if (!ref)
		return -EINVAL;

	ctrl = ref->ctrl;
	memset(qc, 0, sizeof(*qc));
	if (id >= V4L2_CID_PRIVATE_BASE)
		qc->id = id;
	else
		qc->id = ctrl->id;
	strlcpy(qc->name, ctrl->name, sizeof(qc->name));
	qc->flags = ctrl->flags;
	qc->type = ctrl->type;
	if (ctrl->is_ptr)
		qc->flags |= V4L2_CTRL_FLAG_HAS_PAYLOAD;
	qc->elem_size = ctrl->elem_size;
	qc->elems = ctrl->elems;
	qc->nr_of_dims = ctrl->nr_of_dims;
	memcpy(qc->dims, ctrl->dims, qc->nr_of_dims * sizeof(qc->dims[0]));
	qc->minimum = ctrl->minimum;
	qc->maximum = ctrl->maximum;
	qc->default_value = ctrl->default_value;
	if (ctrl->type == V4L2_CTRL_TYPE_MENU
	    || ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU)
		qc->step = 1;
	else
		qc->step = ctrl->step;
	return 0;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
14,16
17,18
17,19
17,20
17,21
17,22
17,23
17,24
17,25
17,26
17,27
17,28
17,29
17,30
17,31
17,32
17,33
17,34
17,35
17,36
17,37
17,38
17,39
17,40
17,41
17,42
17,43
18,19
19,20
19,21
21,22
21,23
23,24
24,25
24,26
25,26
27,28
29,30
30,31
30,32
31,32
33,34
33,35
35,36
36,37
36,38
37,38
37,39
38,39
41,42
43,44
44,45
44,46
45,46
47,48
47,49
50,51
51,52
51,53
52,53
54,55
54,56
57,58
57,59
58,59
58,60
59,60
61,62
63,64
64,65
65,66
67,68
68,69
68,70
69,70
71,72
71,73
72,73
75,76
76,77
76,78
77,78
79,80
79,81
79,82
80,81
82,83
84,85
86,87
86,88
87,88
87,89
88,89
89,90
89,91
90,91
90,92
91,92
94,95
96,97
97,98
97,99
98,99
100,101
101,102
101,103
102,103
105,106
105,107
105,108
105,109
105,110
106,107
107,108
107,109
109,110
111,112
112,113
112,114
114,115
114,116
116,117
118,119
119,120
119,121
121,122
121,123
123,124
125,126
125,127
125,128
126,127
126,128
127,128
128,129
128,130
129,130
129,131
130,131
133,134
135,136
137,138
138,139
139,140
139,141
140,141
143,144
143,145
144,145
144,146
145,146
146,147
146,148
147,148
147,149
148,149
151,152
153,154
155,156
156,157
157,158
157,159
158,159
161,162
161,163
161,164
162,163
162,164
163,164
165,166
165,167
166,167
168,169
168,170
169,170
169,171
170,171
174,175
175,176
176,177
176,178
177,178
179,180
181,182
181,183
181,184
182,183
184,185
184,186
184,187
184,188
185,186
186,187
186,188
186,189
186,190
187,188
189,190
191,192
192,193
192,194
193,194
196,197
198,199
199,200
199,201
200,201
201,202
201,203
202,203
204,205
204,206
205,206
205,207
206,207
206,208
207,208
211,212
213,214
213,215
214,215
214,216
215,216
215,217
216,217
218,219
218,220
219,220
219,221
220,221
224,225
224,226
225,226
226,227
226,228
227,228
229,230
231,232
234,235
234,236
235,236
235,237
236,237
237,238
237,239
238,239
241,242
242,243
242,244
243,244
246,247
247,248
247,249
248,249
250,251
252,253
252,254
252,255
252,256
253,254
254,255
254,256
254,257
254,258
255,256
257,258
259,260
260,261
260,262
261,262
264,265
266,267
267,268
267,269
268,269
269,270
269,271
270,271
272,273
272,274
273,274
273,275
274,275
274,276
275,276
279,280
281,282
281,283
282,283
282,284
283,284
283,285
284,285
286,287
286,288
287,288
287,289
288,289
292,293
292,294
293,294
294,295
294,296
295,296
297,298
299,300
302,303
302,304
303,304
303,305
304,305
305,306
305,307
306,307
309,310
310,311
310,312
311,312
314,315
315,316
315,317
316,317
318,319
320,321
321,322
321,323
322,323
324,325
324,326
325,326
328,329
328,330
329,330
330,331
332,333
333,334
334,335
336,337
337,338
337,339
338,339
340,341
340,342
341,342
344,345
345,346
345,347
345,348
345,349
346,347
348,349
351,352
352,353
353,354
354,355
356,357
356,358
356,359
357,358
357,359
358,359
360,361
362,363
363,364
363,365
364,365
364,366
365,366
368,369
370,371
371,372
371,373
372,373
372,374
373,374
376,377
376,378
377,378
380,381
381,382
381,383
381,384
381,385
382,383
384,385
384,386
385,386
388,389
388,390
389,390
392,393
393,394
394,395
394,396
395,396
398,399
399,400
399,401
400,401
400,402
401,402
404,405
404,406
405,406
408,409
409,410
409,411
410,411
410,412
411,412
414,415
414,416
415,416
418,419
418,420
419,420
419,421
420,421
423,424
424,425
424,426
425,426
425,427
426,427
429,430
431,432
432,433
432,434
433,434
433,435
434,435
437,438
437,439
438,439
441,442
442,443
442,444
443,444
443,445
444,445
447,448
447,449
448,449
451,452
452,453
452,454
453,454
453,455
454,455
457,458
457,459
458,459
461,462
462,463
462,464
462,465
462,466
463,464
465,466
465,467
466,467
469,470
469,471
470,471
473,474
473,475
474,475
474,476
475,476
478,479
479,480
480,481
480,482
481,482
481,483
482,483
486,487
487,488
487,489
488,489
488,490
489,490
492,493
492,494
493,494
496,497
497,498
497,499
498,499
498,500
499,500
502,503
502,504
503,504
506,507
507,508
507,509
508,509
508,510
509,510
512,513
512,514
513,514
516,517
516,518
516,519
517,518
517,519
518,519
518,520
519,520
519,521
520,521
523,524
525,526
525,527
526,527
526,528
527,528
530,531
532,533
533,534
533,535
534,535
534,536
535,536
539,540
540,541
540,542
541,542
541,543
542,543
545,546
545,547
546,547
549,550
-----nextToken-----
2,4,7,9,10,13,15,16,20,22,26,28,32,34,39,40,42,46,48,49,53,55,56,60,62,66,70,73,74,78,81,83,85,92,93,95,99,103,104,108,110,113,115,117,120,122,124,131,132,134,136,141,142,149,150,152,154,159,160,164,167,171,172,173,178,180,183,188,190,194,195,197,203,208,209,210,212,217,221,222,223,228,230,232,233,239,240,244,245,249,251,256,258,262,263,265,271,276,277,278,280,285,289,290,291,296,298,300,301,307,308,312,313,317,319,323,326,327,331,335,339,342,343,347,349,350,355,359,361,366,367,369,374,375,378,379,383,386,387,390,391,396,397,402,403,406,407,412,413,416,417,421,422,427,428,430,435,436,439,440,445,446,449,450,455,456,459,460,464,467,468,471,472,476,477,483,484,485,490,491,494,495,500,501,504,505,510,511,514,515,521,522,524,528,529,531,536,537,538,543,544,547,548,550
-----computeFrom-----
24,25
24,26
36,37
36,38
58,59
58,60
76,77
76,78
87,88
87,89
89,90
89,91
126,127
126,128
128,129
128,130
139,140
139,141
144,145
144,146
146,147
146,148
157,158
157,159
162,163
162,164
176,177
176,178
201,202
201,203
204,205
204,206
214,215
214,216
215,216
215,217
224,225
224,226
226,227
226,228
235,236
235,237
247,248
247,249
269,270
269,271
272,273
272,274
282,283
282,284
283,284
283,285
292,293
292,294
294,295
294,296
303,304
303,305
315,316
315,317
337,338
337,339
357,358
357,359
363,364
363,365
371,372
371,373
399,400
399,401
409,410
409,411
424,425
424,426
432,433
432,434
442,443
442,444
452,453
452,454
473,474
473,475
487,488
487,489
497,498
497,499
507,508
507,509
517,518
517,519
518,519
518,520
525,526
525,527
533,534
533,535
540,541
540,542
-----guardedBy-----
95,154
103,312
92,149
104,313
93,291
239,249
307,317
359,369
-----guardedByNegation-----
134,154
131,149
132,150
171,312
172,313
164,291
359,379
528,547
-----lastLexicalUse-----
359,379
-----jump-----
359,379
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;BinaryExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ProblemStatement;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ProblemStatement;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;ReturnStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
int v4l2_query_ext_ctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_query_ext_ctrl *qc){	const unsigned next_flags = V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND;	u32 id = qc->id & V4L2_CTRL_ID_MASK;	struct v4l2_ctrl_ref *ref;	struct v4l2_ctrl *ctrl;	if (hdl == NULL)		return -EINVAL;	mutex_lock(hdl->lock);	/* Try to find it */	ref = find_ref(hdl, id);	if ((qc->id & next_flags) && !list_empty(&hdl->ctrl_refs)) {		bool is_compound;		/* Match any control that is not hidden */		unsigned mask = 1;		bool match = false;		if ((qc->id & next_flags) == V4L2_CTRL_FLAG_NEXT_COMPOUND) {			/* Match any hidden control */			match = true;		} else if ((qc->id & next_flags) == next_flags) {			/* Match any control, compound or not */			mask = 0;		}		/* Find the next control with ID > qc->id */		/* Did we reach the end of the control list? */		if (id >= node2id(hdl->ctrl_refs.prev)) {			ref = NULL; /* Yes, so there is no next control */		} else if (ref) {			/* We found a control with the given ID, so just get			   the next valid one in the list. */			list_for_each_entry_continue(ref, &hdl->ctrl_refs, node) {				is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;				if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;			}			if (&ref->node == &hdl->ctrl_refs)				ref = NULL;		} else {			/* No control with the given ID exists, so start			   searching for the next largest ID. We know there			   is one, otherwise the first 'if' above would have			   been true. */			list_for_each_entry(ref, &hdl->ctrl_refs, node) {				is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;				if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;			}			if (&ref->node == &hdl->ctrl_refs)				ref = NULL;		}	}	mutex_unlock(hdl->lock);	if (!ref)		return -EINVAL;	ctrl = ref->ctrl;	memset(qc, 0, sizeof(*qc));	if (id >= V4L2_CID_PRIVATE_BASE)		qc->id = id;	else		qc->id = ctrl->id;	strlcpy(qc->name, ctrl->name, sizeof(qc->name));	qc->flags = ctrl->flags;	qc->type = ctrl->type;	if (ctrl->is_ptr)		qc->flags |= V4L2_CTRL_FLAG_HAS_PAYLOAD;	qc->elem_size = ctrl->elem_size;	qc->elems = ctrl->elems;	qc->nr_of_dims = ctrl->nr_of_dims;	memcpy(qc->dims, ctrl->dims, qc->nr_of_dims * sizeof(qc->dims[0]));	qc->minimum = ctrl->minimum;	qc->maximum = ctrl->maximum;	qc->default_value = ctrl->default_value;	if (ctrl->type == V4L2_CTRL_TYPE_MENU	    || ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU)		qc->step = 1;	else		qc->step = ctrl->step;	return 0;}
int
v4l2_query_ext_ctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_query_ext_ctrl *qc)
v4l2_query_ext_ctrl
struct v4l2_ctrl_handler *hdl
struct v4l2_ctrl_handler
v4l2_ctrl_handler
*hdl
*
hdl
struct v4l2_query_ext_ctrl *qc
struct v4l2_query_ext_ctrl
v4l2_query_ext_ctrl
*qc
*
qc
{	const unsigned next_flags = V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND;	u32 id = qc->id & V4L2_CTRL_ID_MASK;	struct v4l2_ctrl_ref *ref;	struct v4l2_ctrl *ctrl;	if (hdl == NULL)		return -EINVAL;	mutex_lock(hdl->lock);	/* Try to find it */	ref = find_ref(hdl, id);	if ((qc->id & next_flags) && !list_empty(&hdl->ctrl_refs)) {		bool is_compound;		/* Match any control that is not hidden */		unsigned mask = 1;		bool match = false;		if ((qc->id & next_flags) == V4L2_CTRL_FLAG_NEXT_COMPOUND) {			/* Match any hidden control */			match = true;		} else if ((qc->id & next_flags) == next_flags) {			/* Match any control, compound or not */			mask = 0;		}		/* Find the next control with ID > qc->id */		/* Did we reach the end of the control list? */		if (id >= node2id(hdl->ctrl_refs.prev)) {			ref = NULL; /* Yes, so there is no next control */		} else if (ref) {			/* We found a control with the given ID, so just get			   the next valid one in the list. */			list_for_each_entry_continue(ref, &hdl->ctrl_refs, node) {				is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;				if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;			}			if (&ref->node == &hdl->ctrl_refs)				ref = NULL;		} else {			/* No control with the given ID exists, so start			   searching for the next largest ID. We know there			   is one, otherwise the first 'if' above would have			   been true. */			list_for_each_entry(ref, &hdl->ctrl_refs, node) {				is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;				if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;			}			if (&ref->node == &hdl->ctrl_refs)				ref = NULL;		}	}	mutex_unlock(hdl->lock);	if (!ref)		return -EINVAL;	ctrl = ref->ctrl;	memset(qc, 0, sizeof(*qc));	if (id >= V4L2_CID_PRIVATE_BASE)		qc->id = id;	else		qc->id = ctrl->id;	strlcpy(qc->name, ctrl->name, sizeof(qc->name));	qc->flags = ctrl->flags;	qc->type = ctrl->type;	if (ctrl->is_ptr)		qc->flags |= V4L2_CTRL_FLAG_HAS_PAYLOAD;	qc->elem_size = ctrl->elem_size;	qc->elems = ctrl->elems;	qc->nr_of_dims = ctrl->nr_of_dims;	memcpy(qc->dims, ctrl->dims, qc->nr_of_dims * sizeof(qc->dims[0]));	qc->minimum = ctrl->minimum;	qc->maximum = ctrl->maximum;	qc->default_value = ctrl->default_value;	if (ctrl->type == V4L2_CTRL_TYPE_MENU	    || ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU)		qc->step = 1;	else		qc->step = ctrl->step;	return 0;}
const unsigned next_flags = V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND;
const unsigned next_flags = V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND;
const unsigned
next_flags = V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND
next_flags
= V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND
V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND
V4L2_CTRL_FLAG_NEXT_CTRL
V4L2_CTRL_FLAG_NEXT_CTRL
V4L2_CTRL_FLAG_NEXT_COMPOUND
V4L2_CTRL_FLAG_NEXT_COMPOUND
u32 id = qc->id & V4L2_CTRL_ID_MASK;
u32 id = qc->id & V4L2_CTRL_ID_MASK;
u32
u32
id = qc->id & V4L2_CTRL_ID_MASK
id
= qc->id & V4L2_CTRL_ID_MASK
qc->id & V4L2_CTRL_ID_MASK
qc->id
qc
qc
id
V4L2_CTRL_ID_MASK
V4L2_CTRL_ID_MASK
struct v4l2_ctrl_ref *ref;
struct v4l2_ctrl_ref *ref;
struct v4l2_ctrl_ref
v4l2_ctrl_ref
*ref
*
ref
struct v4l2_ctrl *ctrl;
struct v4l2_ctrl *ctrl;
struct v4l2_ctrl
v4l2_ctrl
*ctrl
*
ctrl
if (hdl == NULL)		return -EINVAL;
hdl == NULL
hdl
hdl
NULL
NULL
return -EINVAL;
-EINVAL
EINVAL
EINVAL
mutex_lock(hdl->lock);
mutex_lock(hdl->lock)
mutex_lock
mutex_lock
hdl->lock
hdl
hdl
lock
ref = find_ref(hdl, id);
ref = find_ref(hdl, id)
ref
ref
find_ref(hdl, id)
find_ref
find_ref
hdl
hdl
id
id
if ((qc->id & next_flags) && !list_empty(&hdl->ctrl_refs)) {		bool is_compound;		/* Match any control that is not hidden */		unsigned mask = 1;		bool match = false;		if ((qc->id & next_flags) == V4L2_CTRL_FLAG_NEXT_COMPOUND) {			/* Match any hidden control */			match = true;		} else if ((qc->id & next_flags) == next_flags) {			/* Match any control, compound or not */			mask = 0;		}		/* Find the next control with ID > qc->id */		/* Did we reach the end of the control list? */		if (id >= node2id(hdl->ctrl_refs.prev)) {			ref = NULL; /* Yes, so there is no next control */		} else if (ref) {			/* We found a control with the given ID, so just get			   the next valid one in the list. */			list_for_each_entry_continue(ref, &hdl->ctrl_refs, node) {				is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;				if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;			}			if (&ref->node == &hdl->ctrl_refs)				ref = NULL;		} else {			/* No control with the given ID exists, so start			   searching for the next largest ID. We know there			   is one, otherwise the first 'if' above would have			   been true. */			list_for_each_entry(ref, &hdl->ctrl_refs, node) {				is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;				if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;			}			if (&ref->node == &hdl->ctrl_refs)				ref = NULL;		}	}
(qc->id & next_flags) && !list_empty(&hdl->ctrl_refs)
(qc->id & next_flags)
qc->id & next_flags
qc->id
qc
qc
id
next_flags
next_flags
!list_empty(&hdl->ctrl_refs)
list_empty(&hdl->ctrl_refs)
list_empty
list_empty
&hdl->ctrl_refs
hdl->ctrl_refs
hdl
hdl
ctrl_refs
{		bool is_compound;		/* Match any control that is not hidden */		unsigned mask = 1;		bool match = false;		if ((qc->id & next_flags) == V4L2_CTRL_FLAG_NEXT_COMPOUND) {			/* Match any hidden control */			match = true;		} else if ((qc->id & next_flags) == next_flags) {			/* Match any control, compound or not */			mask = 0;		}		/* Find the next control with ID > qc->id */		/* Did we reach the end of the control list? */		if (id >= node2id(hdl->ctrl_refs.prev)) {			ref = NULL; /* Yes, so there is no next control */		} else if (ref) {			/* We found a control with the given ID, so just get			   the next valid one in the list. */			list_for_each_entry_continue(ref, &hdl->ctrl_refs, node) {				is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;				if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;			}			if (&ref->node == &hdl->ctrl_refs)				ref = NULL;		} else {			/* No control with the given ID exists, so start			   searching for the next largest ID. We know there			   is one, otherwise the first 'if' above would have			   been true. */			list_for_each_entry(ref, &hdl->ctrl_refs, node) {				is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;				if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;			}			if (&ref->node == &hdl->ctrl_refs)				ref = NULL;		}	}
bool is_compound;
bool is_compound;
bool
is_compound
is_compound
unsigned mask = 1;
unsigned mask = 1;
unsigned
mask = 1
mask
= 1
1
bool match = false;
bool match = false;
bool
match = false
match
= false
false
if ((qc->id & next_flags) == V4L2_CTRL_FLAG_NEXT_COMPOUND) {			/* Match any hidden control */			match = true;		} else if ((qc->id & next_flags) == next_flags) {			/* Match any control, compound or not */			mask = 0;		}
(qc->id & next_flags) == V4L2_CTRL_FLAG_NEXT_COMPOUND
(qc->id & next_flags)
qc->id & next_flags
qc->id
qc
qc
id
next_flags
next_flags
V4L2_CTRL_FLAG_NEXT_COMPOUND
V4L2_CTRL_FLAG_NEXT_COMPOUND
{			/* Match any hidden control */			match = true;		}
match = true;
match = true
match
match
true
if ((qc->id & next_flags) == next_flags) {			/* Match any control, compound or not */			mask = 0;		}
(qc->id & next_flags) == next_flags
(qc->id & next_flags)
qc->id & next_flags
qc->id
qc
qc
id
next_flags
next_flags
next_flags
next_flags
{			/* Match any control, compound or not */			mask = 0;		}
mask = 0;
mask = 0
mask
mask
0
if (id >= node2id(hdl->ctrl_refs.prev)) {			ref = NULL; /* Yes, so there is no next control */		} else if (ref) {			/* We found a control with the given ID, so just get			   the next valid one in the list. */			list_for_each_entry_continue(ref, &hdl->ctrl_refs, node) {				is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;				if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;			}			if (&ref->node == &hdl->ctrl_refs)				ref = NULL;		} else {			/* No control with the given ID exists, so start			   searching for the next largest ID. We know there			   is one, otherwise the first 'if' above would have			   been true. */			list_for_each_entry(ref, &hdl->ctrl_refs, node) {				is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;				if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;			}			if (&ref->node == &hdl->ctrl_refs)				ref = NULL;		}
id >= node2id(hdl->ctrl_refs.prev)
id
id
node2id(hdl->ctrl_refs.prev)
node2id
node2id
hdl->ctrl_refs.prev
hdl->ctrl_refs
hdl
hdl
ctrl_refs
prev
{			ref = NULL; /* Yes, so there is no next control */		}
ref = NULL;
ref = NULL
ref
ref
NULL
NULL
if (ref) {			/* We found a control with the given ID, so just get			   the next valid one in the list. */			list_for_each_entry_continue(ref, &hdl->ctrl_refs, node) {				is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;				if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;			}			if (&ref->node == &hdl->ctrl_refs)				ref = NULL;		} else {			/* No control with the given ID exists, so start			   searching for the next largest ID. We know there			   is one, otherwise the first 'if' above would have			   been true. */			list_for_each_entry(ref, &hdl->ctrl_refs, node) {				is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;				if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;			}			if (&ref->node == &hdl->ctrl_refs)				ref = NULL;		}
ref
ref
{			/* We found a control with the given ID, so just get			   the next valid one in the list. */			list_for_each_entry_continue(ref, &hdl->ctrl_refs, node) {				is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;				if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;			}			if (&ref->node == &hdl->ctrl_refs)				ref = NULL;		}
list_for_each_entry_continue(ref, &hdl->ctrl_refs, node)
list_for_each_entry_continue(ref, &hdl->ctrl_refs, node)
list_for_each_entry_continue
list_for_each_entry_continue
ref
ref
&hdl->ctrl_refs
hdl->ctrl_refs
hdl
hdl
ctrl_refs
node
node
)
{				is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;				if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;			}
is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;
is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES
is_compound
is_compound
ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES
ref->ctrl->type
ref->ctrl
ref
ref
ctrl
type
V4L2_CTRL_COMPOUND_TYPES
V4L2_CTRL_COMPOUND_TYPES
if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;
id < ref->ctrl->id &&				    (is_compound & mask) == match
id < ref->ctrl->id
id
id
ref->ctrl->id
ref->ctrl
ref
ref
ctrl
id
(is_compound & mask) == match
(is_compound & mask)
is_compound & mask
is_compound
is_compound
mask
mask
match
match
break;
if (&ref->node == &hdl->ctrl_refs)				ref = NULL;
&ref->node == &hdl->ctrl_refs
&ref->node
ref->node
ref
ref
node
&hdl->ctrl_refs
hdl->ctrl_refs
hdl
hdl
ctrl_refs
ref = NULL;
ref = NULL
ref
ref
NULL
NULL
{			/* No control with the given ID exists, so start			   searching for the next largest ID. We know there			   is one, otherwise the first 'if' above would have			   been true. */			list_for_each_entry(ref, &hdl->ctrl_refs, node) {				is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;				if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;			}			if (&ref->node == &hdl->ctrl_refs)				ref = NULL;		}
list_for_each_entry(ref, &hdl->ctrl_refs, node)
list_for_each_entry(ref, &hdl->ctrl_refs, node)
list_for_each_entry
list_for_each_entry
ref
ref
&hdl->ctrl_refs
hdl->ctrl_refs
hdl
hdl
ctrl_refs
node
node
)
{				is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;				if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;			}
is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;
is_compound =					ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES
is_compound
is_compound
ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES
ref->ctrl->type
ref->ctrl
ref
ref
ctrl
type
V4L2_CTRL_COMPOUND_TYPES
V4L2_CTRL_COMPOUND_TYPES
if (id < ref->ctrl->id &&				    (is_compound & mask) == match)					break;
id < ref->ctrl->id &&				    (is_compound & mask) == match
id < ref->ctrl->id
id
id
ref->ctrl->id
ref->ctrl
ref
ref
ctrl
id
(is_compound & mask) == match
(is_compound & mask)
is_compound & mask
is_compound
is_compound
mask
mask
match
match
break;
if (&ref->node == &hdl->ctrl_refs)				ref = NULL;
&ref->node == &hdl->ctrl_refs
&ref->node
ref->node
ref
ref
node
&hdl->ctrl_refs
hdl->ctrl_refs
hdl
hdl
ctrl_refs
ref = NULL;
ref = NULL
ref
ref
NULL
NULL
mutex_unlock(hdl->lock);
mutex_unlock(hdl->lock)
mutex_unlock
mutex_unlock
hdl->lock
hdl
hdl
lock
if (!ref)		return -EINVAL;
!ref
ref
ref
return -EINVAL;
-EINVAL
EINVAL
EINVAL
ctrl = ref->ctrl;
ctrl = ref->ctrl
ctrl
ctrl
ref->ctrl
ref
ref
ctrl
memset(qc, 0, sizeof(*qc));
memset(qc, 0, sizeof(*qc))
memset
memset
qc
qc
0
sizeof(*qc)
(*qc)
*qc
qc
qc
if (id >= V4L2_CID_PRIVATE_BASE)		qc->id = id;	else		qc->id = ctrl->id;
id >= V4L2_CID_PRIVATE_BASE
id
id
V4L2_CID_PRIVATE_BASE
V4L2_CID_PRIVATE_BASE
qc->id = id;
qc->id = id
qc->id
qc
qc
id
id
id
qc->id = ctrl->id;
qc->id = ctrl->id
qc->id
qc
qc
id
ctrl->id
ctrl
ctrl
id
strlcpy(qc->name, ctrl->name, sizeof(qc->name));
strlcpy(qc->name, ctrl->name, sizeof(qc->name))
strlcpy
strlcpy
qc->name
qc
qc
name
ctrl->name
ctrl
ctrl
name
sizeof(qc->name)
(qc->name)
qc->name
qc
qc
name
qc->flags = ctrl->flags;
qc->flags = ctrl->flags
qc->flags
qc
qc
flags
ctrl->flags
ctrl
ctrl
flags
qc->type = ctrl->type;
qc->type = ctrl->type
qc->type
qc
qc
type
ctrl->type
ctrl
ctrl
type
if (ctrl->is_ptr)		qc->flags |= V4L2_CTRL_FLAG_HAS_PAYLOAD;
ctrl->is_ptr
ctrl
ctrl
is_ptr
qc->flags |= V4L2_CTRL_FLAG_HAS_PAYLOAD;
qc->flags |= V4L2_CTRL_FLAG_HAS_PAYLOAD
qc->flags
qc
qc
flags
V4L2_CTRL_FLAG_HAS_PAYLOAD
V4L2_CTRL_FLAG_HAS_PAYLOAD
qc->elem_size = ctrl->elem_size;
qc->elem_size = ctrl->elem_size
qc->elem_size
qc
qc
elem_size
ctrl->elem_size
ctrl
ctrl
elem_size
qc->elems = ctrl->elems;
qc->elems = ctrl->elems
qc->elems
qc
qc
elems
ctrl->elems
ctrl
ctrl
elems
qc->nr_of_dims = ctrl->nr_of_dims;
qc->nr_of_dims = ctrl->nr_of_dims
qc->nr_of_dims
qc
qc
nr_of_dims
ctrl->nr_of_dims
ctrl
ctrl
nr_of_dims
memcpy(qc->dims, ctrl->dims, qc->nr_of_dims * sizeof(qc->dims[0]));
memcpy(qc->dims, ctrl->dims, qc->nr_of_dims * sizeof(qc->dims[0]))
memcpy
memcpy
qc->dims
qc
qc
dims
ctrl->dims
ctrl
ctrl
dims
qc->nr_of_dims * sizeof(qc->dims[0])
qc->nr_of_dims
qc
qc
nr_of_dims
sizeof(qc->dims[0])
(qc->dims[0])
qc->dims[0]
qc->dims
qc
qc
dims
0
qc->minimum = ctrl->minimum;
qc->minimum = ctrl->minimum
qc->minimum
qc
qc
minimum
ctrl->minimum
ctrl
ctrl
minimum
qc->maximum = ctrl->maximum;
qc->maximum = ctrl->maximum
qc->maximum
qc
qc
maximum
ctrl->maximum
ctrl
ctrl
maximum
qc->default_value = ctrl->default_value;
qc->default_value = ctrl->default_value
qc->default_value
qc
qc
default_value
ctrl->default_value
ctrl
ctrl
default_value
if (ctrl->type == V4L2_CTRL_TYPE_MENU	    || ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU)		qc->step = 1;	else		qc->step = ctrl->step;
ctrl->type == V4L2_CTRL_TYPE_MENU	    || ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU
ctrl->type == V4L2_CTRL_TYPE_MENU
ctrl->type
ctrl
ctrl
type
V4L2_CTRL_TYPE_MENU
V4L2_CTRL_TYPE_MENU
ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU
ctrl->type
ctrl
ctrl
type
V4L2_CTRL_TYPE_INTEGER_MENU
V4L2_CTRL_TYPE_INTEGER_MENU
qc->step = 1;
qc->step = 1
qc->step
qc
qc
step
1
qc->step = ctrl->step;
qc->step = ctrl->step
qc->step
qc
qc
step
ctrl->step
ctrl
ctrl
step
return 0;
0
-----joern-----
(126,308,0)
(286,318,0)
(233,68,0)
(262,171,0)
(312,169,0)
(114,46,0)
(287,133,0)
(307,135,0)
(134,120,0)
(127,173,0)
(67,223,0)
(99,174,0)
(87,301,0)
(306,157,0)
(175,65,0)
(88,282,0)
(125,260,0)
(266,204,0)
(21,216,0)
(281,269,0)
(193,156,0)
(120,134,0)
(168,24,0)
(79,116,0)
(37,201,0)
(310,164,0)
(7,52,0)
(255,4,0)
(201,319,0)
(57,238,0)
(216,21,0)
(52,65,0)
(318,90,0)
(55,51,0)
(161,74,0)
(319,8,0)
(5,135,0)
(301,191,0)
(242,31,0)
(62,273,0)
(204,35,0)
(326,192,0)
(250,161,0)
(241,317,0)
(270,205,0)
(291,74,0)
(294,272,0)
(102,142,0)
(43,95,0)
(175,225,0)
(63,68,0)
(171,134,0)
(110,56,0)
(318,30,0)
(261,155,0)
(235,268,0)
(291,202,0)
(225,175,0)
(157,306,0)
(168,5,0)
(237,261,0)
(303,137,0)
(254,65,0)
(98,157,0)
(186,224,0)
(122,173,0)
(64,3,0)
(48,291,0)
(301,238,0)
(269,281,0)
(231,134,0)
(47,69,0)
(12,233,0)
(59,282,0)
(128,169,0)
(211,83,0)
(96,238,0)
(197,82,0)
(83,35,0)
(218,310,0)
(194,215,0)
(215,156,0)
(279,229,0)
(5,15,0)
(16,196,0)
(230,3,0)
(282,116,0)
(142,53,0)
(178,277,0)
(277,74,0)
(51,65,0)
(52,203,0)
(56,24,0)
(224,238,0)
(260,125,0)
(273,121,0)
(152,1,0)
(175,32,0)
(316,252,0)
(205,74,0)
(4,52,0)
(63,263,0)
(1,154,0)
(199,16,0)
(315,65,0)
(217,121,0)
(86,120,0)
(302,192,0)
(202,0,0)
(253,308,0)
(271,298,0)
(98,156,0)
(5,17,0)
(142,102,0)
(132,65,0)
(46,139,0)
(192,326,0)
(73,191,0)
(198,63,0)
(153,83,0)
(282,273,0)
(65,238,0)
(227,238,0)
(166,127,0)
(162,239,0)
(174,121,0)
(137,134,0)
(296,50,0)
(49,246,0)
(221,156,0)
(267,290,0)
(325,65,0)
(19,15,0)
(14,121,0)
(103,263,0)
(66,139,0)
(140,95,0)
(181,4,0)
(244,295,0)
(5,273,0)
(263,121,0)
(36,170,0)
(5,88,0)
(278,12,0)
(125,134,0)
(188,216,0)
(301,121,0)
(148,88,0)
(257,181,0)
(135,57,0)
(116,325,0)
(105,202,0)
(154,249,0)
(50,136,0)
(20,277,0)
(82,253,0)
(282,317,0)
(182,122,0)
(15,312,0)
(165,50,0)
(321,17,0)
(32,175,0)
(315,156,0)
(136,50,0)
(300,315,0)
(197,193,0)
(145,65,0)
(160,318,0)
(142,68,0)
(217,182,0)
(277,20,0)
(258,51,0)
(35,204,0)
(34,68,0)
(120,268,0)
(173,127,0)
(272,74,0)
(239,122,0)
(185,125,0)
(139,238,0)
(313,134,0)
(120,61,0)
(222,301,0)
(93,261,0)
(5,83,0)
(106,272,0)
(226,238,0)
(297,161,0)
(42,267,0)
(2,223,0)
(191,301,0)
(147,233,0)
(275,120,0)
(281,63,0)
(207,295,0)
(213,134,0)
(243,205,0)
(323,174,0)
(33,305,0)
(89,17,0)
(187,327,0)
(68,298,0)
(76,98,0)
(176,268,0)
(284,15,0)
(10,47,0)
(77,133,0)
(246,3,0)
(216,156,0)
(226,229,0)
(140,156,0)
(292,133,0)
(83,121,0)
(53,142,0)
(107,47,0)
(99,290,0)
(31,121,0)
(68,238,0)
(173,122,0)
(295,67,0)
(1,121,0)
(290,267,0)
(69,238,0)
(206,61,0)
(53,68,0)
(26,88,0)
(97,267,0)
(324,217,0)
(269,141,0)
(297,306,0)
(5,295,0)
(40,95,0)
(319,201,0)
(133,134,0)
(13,239,0)
(20,238,0)
(85,238,0)
(116,121,0)
(143,296,0)
(225,30,0)
(70,53,0)
(320,231,0)
(298,68,0)
(329,30,0)
(5,31,0)
(223,67,0)
(296,134,0)
(123,253,0)
(5,327,0)
(326,156,0)
(182,238,0)
(113,3,0)
(233,12,0)
(11,261,0)
(254,252,0)
(181,156,0)
(322,16,0)
(154,238,0)
(18,238,0)
(265,161,0)
(112,304,0)
(99,231,0)
(199,170,0)
(233,14,0)
(134,238,0)
(32,215,0)
(140,61,0)
(41,327,0)
(65,254,0)
(8,21,0)
(263,63,0)
(84,272,0)
(237,253,0)
(106,141,0)
(237,71,0)
(46,134,0)
(202,291,0)
(161,297,0)
(156,238,0)
(168,164,0)
(69,47,0)
(179,32,0)
(28,90,0)
(132,0,0)
(288,234,0)
(280,216,0)
(232,315,0)
(71,203,0)
(308,78,0)
(249,134,0)
(71,237,0)
(81,73,0)
(151,215,0)
(129,132,0)
(215,32,0)
(30,225,0)
(108,277,0)
(140,268,0)
(237,90,0)
(144,204,0)
(72,201,0)
(139,46,0)
(120,95,0)
(21,8,0)
(136,305,0)
(127,166,0)
(290,99,0)
(304,134,0)
(256,296,0)
(99,238,0)
(305,137,0)
(313,182,0)
(191,73,0)
(115,285,0)
(166,121,0)
(104,14,0)
(92,291,0)
(327,121,0)
(193,197,0)
(183,249,0)
(200,199,0)
(315,74,0)
(282,295,0)
(234,58,0)
(283,71,0)
(229,226,0)
(73,121,0)
(124,231,0)
(71,246,0)
(239,121,0)
(214,238,0)
(0,202,0)
(311,193,0)
(239,226,0)
(314,237,0)
(117,298,0)
(39,175,0)
(44,313,0)
(47,74,0)
(5,238,0)
(174,99,0)
(180,102,0)
(5,116,0)
(135,121,0)
(30,318,0)
(259,169,0)
(201,74,0)
(94,238,0)
(54,313,0)
(276,127,0)
(273,260,0)
(45,193,0)
(29,61,0)
(119,186,0)
(5,66,0)
(172,3,0)
(100,116,0)
(91,238,0)
(27,82,0)
(317,121,0)
(264,98,0)
(38,326,0)
(122,182,0)
(182,217,0)
(169,134,0)
(247,238,0)
(240,234,0)
(249,154,0)
(309,1,0)
(57,304,0)
(146,137,0)
(306,297,0)
(252,121,0)
(9,174,0)
(328,304,0)
(5,1,0)
(236,166,0)
(50,296,0)
(299,90,0)
(219,3,0)
(228,238,0)
(4,181,0)
(293,254,0)
(170,192,0)
(231,99,0)
(289,78,0)
(295,121,0)
(23,325,0)
(90,3,0)
(267,121,0)
(292,238,0)
(156,315,0)
(101,252,0)
(229,134,0)
(17,121,0)
(63,281,0)
(170,199,0)
(224,186,0)
(149,46,0)
(223,134,0)
(245,246,0)
(163,249,0)
(195,273,0)
(209,317,0)
(109,5,0)
(0,132,0)
(251,197,0)
(102,121,0)
(133,292,0)
(253,82,0)
(22,142,0)
(305,136,0)
(157,98,0)
(120,156,0)
(122,239,0)
(66,121,0)
(118,229,0)
(17,226,0)
(158,66,0)
(88,121,0)
(30,246,0)
(212,171,0)
(52,4,0)
(304,57,0)
(61,150,0)
(138,66,0)
(203,52,0)
(60,196,0)
(317,292,0)
(169,312,0)
(177,223,0)
(8,319,0)
(137,305,0)
(248,14,0)
(15,121,0)
(204,134,0)
(5,317,0)
(30,234,0)
(192,170,0)
(210,326,0)
(252,254,0)
(220,237,0)
(208,135,0)
(182,313,0)
(80,31,0)
(189,102,0)
(6,263,0)
(71,234,0)
(318,261,0)
(141,106,0)
(14,233,0)
(25,217,0)
(31,224,0)
(167,238,0)
(141,269,0)
(186,134,0)
(318,199,0)
(260,238,0)
(203,71,0)
(272,106,0)
(312,238,0)
(159,181,0)
(82,197,0)
(75,140,0)
(190,125,0)
(130,166,0)
(131,186,0)
(327,285,0)
(256,139,1)
(82,197,1)
(49,245,1)
(199,170,1)
(178,108,1)
(14,248,1)
(217,324,1)
(28,299,1)
(21,216,1)
(265,157,1)
(140,61,1)
(82,27,1)
(53,70,1)
(14,121,1)
(197,251,1)
(293,252,1)
(225,30,1)
(101,316,1)
(267,42,1)
(171,134,1)
(5,88,1)
(321,89,1)
(211,153,1)
(273,121,1)
(181,257,1)
(39,199,1)
(306,297,1)
(12,278,1)
(218,140,1)
(229,134,1)
(307,208,1)
(287,317,1)
(186,131,1)
(70,142,1)
(241,99,1)
(107,95,1)
(168,164,1)
(187,41,1)
(7,253,1)
(32,215,1)
(147,14,1)
(229,118,1)
(15,284,1)
(209,241,1)
(98,156,1)
(17,321,1)
(290,267,1)
(260,125,1)
(264,111,1)
(184,225,1)
(20,277,1)
(205,243,1)
(50,165,1)
(103,6,1)
(65,254,1)
(5,66,1)
(131,119,1)
(237,220,1)
(249,134,1)
(45,311,1)
(327,121,1)
(315,74,1)
(107,268,1)
(132,65,1)
(53,142,1)
(53,68,1)
(257,159,1)
(128,259,1)
(180,189,1)
(221,20,1)
(163,1,1)
(310,218,1)
(315,300,1)
(318,90,1)
(217,121,1)
(35,204,1)
(317,121,1)
(240,12,1)
(152,312,1)
(264,203,1)
(52,65,1)
(116,121,1)
(200,274,1)
(216,280,1)
(268,235,1)
(89,154,1)
(280,188,1)
(76,264,1)
(50,296,1)
(151,39,1)
(306,157,1)
(32,179,1)
(19,171,1)
(107,281,1)
(29,206,1)
(272,84,1)
(15,121,1)
(5,17,1)
(127,276,1)
(197,193,1)
(13,162,1)
(142,102,1)
(9,67,1)
(225,175,1)
(125,190,1)
(176,306,1)
(220,314,1)
(277,74,1)
(54,217,1)
(201,72,1)
(281,63,1)
(107,8,1)
(242,80,1)
(174,323,1)
(206,132,1)
(325,65,1)
(30,234,1)
(203,52,1)
(38,210,1)
(302,326,1)
(129,53,1)
(25,226,1)
(47,10,1)
(40,8,1)
(154,249,1)
(297,161,1)
(9,325,1)
(22,102,1)
(295,121,1)
(317,209,1)
(11,93,1)
(261,11,1)
(318,261,1)
(223,2,1)
(300,232,1)
(166,130,1)
(185,273,1)
(276,166,1)
(157,98,1)
(189,12,1)
(318,199,1)
(75,69,1)
(106,272,1)
(4,181,1)
(273,195,1)
(27,197,1)
(215,156,1)
(282,273,1)
(239,226,1)
(140,268,1)
(164,310,1)
(59,88,1)
(291,74,1)
(237,261,1)
(132,0,1)
(253,82,1)
(56,110,1)
(57,304,1)
(140,75,1)
(51,258,1)
(323,9,1)
(175,65,1)
(71,283,1)
(329,318,1)
(284,19,1)
(129,261,1)
(83,121,1)
(144,83,1)
(270,65,1)
(166,121,1)
(226,229,1)
(188,184,1)
(235,176,1)
(86,213,1)
(170,36,1)
(111,203,1)
(204,134,1)
(252,101,1)
(173,127,1)
(63,263,1)
(134,120,1)
(31,242,1)
(326,38,1)
(129,234,1)
(48,129,1)
(120,95,1)
(278,233,1)
(4,255,1)
(46,134,1)
(272,74,1)
(292,133,1)
(5,135,1)
(182,217,1)
(165,296,1)
(277,178,1)
(77,287,1)
(213,140,1)
(42,97,1)
(243,270,1)
(296,134,1)
(141,106,1)
(36,192,1)
(239,13,1)
(114,66,1)
(190,185,1)
(30,318,1)
(124,320,1)
(249,183,1)
(309,152,1)
(207,51,1)
(120,275,1)
(304,328,1)
(51,65,1)
(5,83,1)
(169,128,1)
(274,132,1)
(120,156,1)
(282,295,1)
(216,156,1)
(136,305,1)
(313,44,1)
(5,109,1)
(81,222,1)
(5,15,1)
(97,231,1)
(244,207,1)
(95,43,1)
(198,263,1)
(99,290,1)
(223,134,1)
(326,156,1)
(201,74,1)
(107,61,1)
(79,51,1)
(102,180,1)
(73,121,1)
(266,144,1)
(115,327,1)
(193,45,1)
(140,95,1)
(55,301,1)
(204,266,1)
(139,46,1)
(5,1,1)
(305,33,1)
(298,271,1)
(254,293,1)
(61,29,1)
(168,24,1)
(71,246,1)
(194,151,1)
(98,76,1)
(88,26,1)
(8,319,1)
(158,224,1)
(137,134,1)
(41,136,1)
(153,136,1)
(130,236,1)
(275,86,1)
(174,121,1)
(233,147,1)
(143,256,1)
(120,61,1)
(248,104,1)
(202,291,1)
(281,269,1)
(133,134,1)
(296,143,1)
(92,48,1)
(282,317,1)
(67,223,1)
(145,68,1)
(66,121,1)
(303,146,1)
(122,239,1)
(109,285,1)
(37,21,1)
(104,246,1)
(135,121,1)
(237,90,1)
(283,237,1)
(324,25,1)
(210,200,1)
(282,59,1)
(73,81,1)
(251,193,1)
(294,63,1)
(286,160,1)
(133,77,1)
(5,31,1)
(102,121,1)
(255,181,1)
(224,186,1)
(99,231,1)
(47,74,1)
(192,326,1)
(146,50,1)
(80,57,1)
(119,31,1)
(328,112,1)
(120,268,1)
(250,265,1)
(161,250,1)
(63,198,1)
(175,32,1)
(236,239,1)
(116,100,1)
(118,279,1)
(233,14,1)
(5,317,1)
(313,134,1)
(23,116,1)
(183,163,1)
(212,262,1)
(258,55,1)
(171,212,1)
(138,158,1)
(231,124,1)
(203,71,1)
(125,134,1)
(325,23,1)
(72,37,1)
(191,73,1)
(62,292,1)
(304,134,1)
(19,282,1)
(137,303,1)
(162,313,1)
(109,35,1)
(232,221,1)
(215,194,1)
(159,7,1)
(262,260,1)
(254,252,1)
(295,244,1)
(269,141,1)
(233,68,1)
(169,134,1)
(301,191,1)
(117,34,1)
(112,135,1)
(140,156,1)
(5,273,1)
(246,49,1)
(1,309,1)
(5,295,1)
(135,307,1)
(314,52,1)
(30,329,1)
(71,237,1)
(30,246,1)
(234,288,1)
(263,103,1)
(1,121,1)
(99,174,1)
(259,15,1)
(305,137,1)
(148,171,1)
(245,90,1)
(24,56,1)
(319,201,1)
(320,174,1)
(31,121,1)
(208,182,1)
(5,116,1)
(63,68,1)
(90,28,1)
(88,121,1)
(68,298,1)
(279,17,1)
(100,79,1)
(44,54,1)
(231,134,1)
(192,302,1)
(170,192,1)
(52,4,1)
(66,138,1)
(161,74,1)
(84,294,1)
(108,205,1)
(299,281,1)
(6,156,1)
(8,21,1)
(311,123,1)
(327,187,1)
(33,137,1)
(0,202,1)
(186,134,1)
(122,173,1)
(312,169,1)
(285,115,1)
(12,233,1)
(26,148,1)
(239,121,1)
(315,65,1)
(182,313,1)
(291,92,1)
(188,225,1)
(195,62,1)
(17,121,1)
(288,240,1)
(136,50,1)
(142,68,1)
(71,234,1)
(202,105,1)
(252,121,1)
(301,121,1)
(2,177,1)
(107,306,1)
(105,291,1)
(10,107,1)
(83,211,1)
(156,315,1)
(149,114,1)
(127,166,1)
(222,87,1)
(177,295,1)
(263,121,1)
(316,145,1)
(87,134,1)
(237,253,1)
(46,149,1)
(271,117,1)
(43,40,1)
(5,327,1)
(93,53,1)
(282,116,1)
(142,22,1)
(318,286,1)
(168,5,1)
(160,175,1)
(123,274,1)
(267,121,1)
(179,215,1)
(181,156,1)
(182,122,1)
(205,74,1)
(69,47,1)
(110,205,1)
(193,156,1)
(122,173,2)
(193,274,2)
(162,140,2)
(199,170,2)
(299,281,2)
(194,274,2)
(13,140,2)
(21,216,2)
(141,63,2)
(278,281,2)
(217,140,2)
(50,296,2)
(104,281,2)
(218,140,2)
(99,231,2)
(275,140,2)
(164,140,2)
(75,205,2)
(99,140,2)
(53,142,2)
(4,274,2)
(253,82,2)
(63,68,2)
(241,140,2)
(133,140,2)
(262,140,2)
(224,186,2)
(190,140,2)
(186,134,2)
(245,281,2)
(5,295,2)
(182,217,2)
(204,134,2)
(317,121,2)
(160,175,2)
(38,274,2)
(0,202,2)
(169,140,2)
(52,4,2)
(225,30,2)
(297,274,2)
(257,274,2)
(273,121,2)
(200,274,2)
(170,274,2)
(135,121,2)
(148,171,2)
(139,140,2)
(132,65,2)
(315,205,2)
(51,65,2)
(19,140,2)
(178,205,2)
(12,281,2)
(301,140,2)
(185,140,2)
(14,121,2)
(216,274,2)
(195,140,2)
(69,205,2)
(142,12,2)
(57,140,2)
(309,140,2)
(71,237,2)
(312,140,2)
(48,281,2)
(89,140,2)
(10,205,2)
(84,63,2)
(222,140,2)
(120,156,2)
(171,134,2)
(43,8,2)
(239,121,2)
(248,281,2)
(203,274,2)
(318,175,2)
(240,12,2)
(120,95,2)
(173,127,2)
(305,50,2)
(165,140,2)
(31,140,2)
(315,65,2)
(318,261,2)
(41,136,2)
(226,229,2)
(106,63,2)
(203,52,2)
(44,140,2)
(28,281,2)
(5,317,2)
(305,137,2)
(324,140,2)
(216,156,2)
(146,50,2)
(5,135,2)
(5,17,2)
(285,136,2)
(325,51,2)
(68,298,2)
(23,51,2)
(209,140,2)
(288,12,2)
(25,140,2)
(192,274,2)
(65,254,2)
(88,121,2)
(109,140,2)
(15,140,2)
(134,140,2)
(320,140,2)
(116,51,2)
(314,52,2)
(46,140,2)
(76,274,2)
(327,136,2)
(180,12,2)
(204,136,2)
(114,140,2)
(137,50,2)
(318,90,2)
(136,50,2)
(254,252,2)
(201,274,2)
(136,140,2)
(71,234,2)
(300,205,2)
(212,140,2)
(80,140,2)
(191,73,2)
(215,274,2)
(277,74,2)
(188,274,2)
(30,234,2)
(297,161,2)
(154,140,2)
(280,274,2)
(215,156,2)
(203,71,2)
(296,134,2)
(122,239,2)
(237,90,2)
(5,116,2)
(312,169,2)
(46,134,2)
(107,205,2)
(292,133,2)
(282,116,2)
(233,14,2)
(52,274,2)
(187,136,2)
(17,140,2)
(53,12,2)
(62,140,2)
(115,136,2)
(93,53,2)
(182,140,2)
(22,12,2)
(47,205,2)
(32,215,2)
(255,274,2)
(177,51,2)
(31,121,2)
(256,140,2)
(183,140,2)
(129,281,2)
(292,140,2)
(5,327,2)
(175,274,2)
(143,140,2)
(30,318,2)
(24,205,2)
(201,74,2)
(134,120,2)
(221,205,2)
(152,140,2)
(55,140,2)
(174,121,2)
(133,134,2)
(123,274,2)
(53,68,2)
(231,134,2)
(304,134,2)
(197,193,2)
(5,273,2)
(303,50,2)
(52,65,2)
(206,132,2)
(30,246,2)
(175,65,2)
(40,8,2)
(182,313,2)
(39,274,2)
(267,121,2)
(81,140,2)
(237,253,2)
(5,15,2)
(11,53,2)
(21,274,2)
(0,281,2)
(54,140,2)
(14,281,2)
(326,156,2)
(237,261,2)
(249,134,2)
(7,274,2)
(207,51,2)
(233,281,2)
(179,274,2)
(232,205,2)
(269,141,2)
(30,175,2)
(112,140,2)
(119,140,2)
(266,136,2)
(73,140,2)
(211,136,2)
(100,51,2)
(37,274,2)
(132,281,2)
(242,140,2)
(5,88,2)
(328,140,2)
(191,140,2)
(140,95,2)
(291,74,2)
(125,140,2)
(246,281,2)
(82,197,2)
(281,205,2)
(181,274,2)
(325,65,2)
(98,156,2)
(239,226,2)
(260,140,2)
(111,203,2)
(27,274,2)
(317,140,2)
(120,268,2)
(63,263,2)
(110,205,2)
(5,83,2)
(142,68,2)
(272,63,2)
(8,274,2)
(67,51,2)
(17,121,2)
(8,21,2)
(154,249,2)
(1,140,2)
(15,121,2)
(294,63,2)
(301,191,2)
(287,140,2)
(263,205,2)
(45,274,2)
(302,274,2)
(50,140,2)
(290,267,2)
(223,134,2)
(259,140,2)
(103,205,2)
(140,61,2)
(116,121,2)
(166,121,2)
(141,106,2)
(5,31,2)
(6,205,2)
(282,273,2)
(213,140,2)
(69,47,2)
(223,51,2)
(102,121,2)
(276,140,2)
(182,122,2)
(236,140,2)
(234,12,2)
(12,233,2)
(156,315,2)
(140,156,2)
(49,281,2)
(261,53,2)
(47,74,2)
(313,140,2)
(166,140,2)
(306,297,2)
(140,268,2)
(127,140,2)
(279,140,2)
(231,140,2)
(130,140,2)
(175,32,2)
(284,140,2)
(205,74,2)
(106,272,2)
(272,74,2)
(105,281,2)
(1,121,2)
(265,274,2)
(4,181,2)
(239,140,2)
(304,140,2)
(192,326,2)
(35,204,2)
(26,171,2)
(149,140,2)
(5,66,2)
(159,274,2)
(273,140,2)
(138,140,2)
(5,1,2)
(326,274,2)
(139,46,2)
(169,134,2)
(142,102,2)
(56,205,2)
(224,140,2)
(63,205,2)
(198,205,2)
(95,8,2)
(258,140,2)
(296,140,2)
(35,136,2)
(9,140,2)
(202,291,2)
(118,140,2)
(128,140,2)
(153,136,2)
(161,74,2)
(319,201,2)
(147,281,2)
(33,50,2)
(122,140,2)
(281,269,2)
(71,246,2)
(193,156,2)
(315,74,2)
(199,274,2)
(98,274,2)
(282,317,2)
(321,140,2)
(157,274,2)
(140,205,2)
(197,274,2)
(290,140,2)
(327,121,2)
(189,12,2)
(88,171,2)
(173,140,2)
(282,171,2)
(249,140,2)
(329,175,2)
(82,274,2)
(157,98,2)
(291,281,2)
(251,274,2)
(318,199,2)
(90,281,2)
(295,121,2)
(66,140,2)
(144,136,2)
(176,306,2)
(233,68,2)
(158,140,2)
(295,51,2)
(72,274,2)
(202,281,2)
(168,5,2)
(67,223,2)
(281,63,2)
(97,140,2)
(181,156,2)
(77,140,2)
(87,140,2)
(92,281,2)
(264,274,2)
(131,140,2)
(260,125,2)
(170,192,2)
(73,121,2)
(250,274,2)
(184,225,2)
(70,12,2)
(323,140,2)
(5,140,2)
(20,205,2)
(83,136,2)
(237,52,2)
(253,274,2)
(135,140,2)
(137,134,2)
(268,306,2)
(229,140,2)
(286,175,2)
(163,140,2)
(57,304,2)
(277,205,2)
(102,12,2)
(225,175,2)
(32,274,2)
(226,140,2)
(66,121,2)
(229,134,2)
(42,140,2)
(311,274,2)
(306,157,2)
(132,0,2)
(120,140,2)
(306,274,2)
(319,274,2)
(120,61,2)
(136,305,2)
(225,274,2)
(269,63,2)
(71,52,2)
(99,174,2)
(220,52,2)
(86,140,2)
(252,121,2)
(2,51,2)
(263,121,2)
(282,295,2)
(51,140,2)
(174,140,2)
(108,205,2)
(186,140,2)
(168,164,2)
(20,277,2)
(59,171,2)
(171,140,2)
(161,274,2)
(168,24,2)
(36,274,2)
(244,51,2)
(151,274,2)
(124,140,2)
(301,121,2)
(310,140,2)
(83,121,2)
(79,51,2)
(217,121,2)
(274,132,2)
(125,134,2)
(99,290,2)
(307,140,2)
(210,274,2)
(61,132,2)
(127,166,2)
(156,205,2)
(208,140,2)
(313,134,2)
(29,132,2)
(283,52,2)
(8,319,2)
(235,306,2)
(267,140,2)
-----------------------------------
(0,node2id(hdl->ctrl_refs.prev)
(1,qc->elems)
(2,id)
(3,)
(4,ref->ctrl->id)
(5,return 0;)
(6,qc)
(7,id)
(8,&ref->node == &hdl->ctrl_refs)
(9,qc)
(10,lock)
(11,0)
(12,(qc->id & next_flags)
(13,nr_of_dims)
(14,qc->id)
(15,qc->elem_size)
(16,)
(17,qc->nr_of_dims)
(18,if (hdl == NULL)
(19,qc)
(20,mutex_lock(hdl->lock)
(21,&ref->node)
(22,next_flags)
(23,id)
(24,return -EINVAL;)
(25,qc)
(26,flags)
(27,V4L2_CTRL_COMPOUND_TYPES)
(28,1)
(29,NULL)
(30,(is_compound & mask)
(31,qc->maximum)
(32,ref->ctrl->id)
(33,V4L2_CTRL_TYPE_INTEGER_MENU)
(34,next_flags)
(35,qc->step = ctrl->step)
(36,V4L2_CTRL_COMPOUND_TYPES)
(37,hdl)
(38,ctrl)
(39,id)
(40,ref)
(41,qc)
(42,name)
(43,NULL)
(44,dims)
(45,ctrl)
(46,ctrl->default_value)
(47,hdl->lock)
(48,hdl)
(49,false)
(50,ctrl->type == V4L2_CTRL_TYPE_MENU)
(51,id >= V4L2_CID_PRIVATE_BASE)
(52,id < ref->ctrl->id)
(53,(qc->id & next_flags)
(54,ctrl)
(55,id)
(56,-EINVAL)
(57,qc->minimum = ctrl->minimum)
(58,)
(59,V4L2_CTRL_FLAG_HAS_PAYLOAD)
(60,if (&ref->node == &hdl->ctrl_refs)
(61,ref = NULL)
(62,qc)
(63,qc->id & next_flags)
(64,if ((qc->id & next_flags)
(65,id = qc->id & V4L2_CTRL_ID_MASK)
(66,qc->default_value)
(67,qc->id = ctrl->id)
(68,next_flags = V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND)
(69,mutex_unlock(hdl->lock)
(70,next_flags)
(71,(is_compound & mask)
(72,ctrl_refs)
(73,*qc)
(74,struct v4l2_ctrl_handler *hdl)
(75,ref)
(76,node)
(77,flags)
(78,)
(79,qc)
(80,qc)
(81,qc)
(82,ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES)
(83,qc->step)
(84,ctrl_refs)
(85,if (ctrl->type == V4L2_CTRL_TYPE_MENU\n\\n\\t    || ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU)
(86,ref)
(87,qc)
(88,qc->flags)
(89,qc)
(90,mask = 1)
(91,next_flags)
(92,ctrl_refs)
(93,mask)
(94,if (ctrl->is_ptr)
(95,ref = NULL)
(96,id)
(97,qc)
(98,ref->node)
(99,strlcpy(qc->name, ctrl->name, sizeof(qc->name)
(100,id)
(101,id)
(102,qc->id)
(103,id)
(104,qc)
(105,prev)
(106,&hdl->ctrl_refs)
(107,hdl)
(108,hdl)
(109,0)
(110,EINVAL)
(111,break;)
(112,ctrl)
(113,is_compound)
(114,ctrl)
(115,1)
(116,qc->id)
(117,V4L2_CTRL_FLAG_NEXT_CTRL)
(118,nr_of_dims)
(119,ctrl)
(120,ref->ctrl)
(121,struct v4l2_query_ext_ctrl *qc)
(122,qc->nr_of_dims * sizeof(qc->dims[0])
(123,is_compound)
(124,name)
(125,ctrl->type)
(126,if (id < ref->ctrl->id &&\n\\n\\t\\t\\t\\t    (is_compound & mask)
(127,qc->dims[0])
(128,elem_size)
(129,id)
(130,dims)
(131,maximum)
(132,id >= node2id(hdl->ctrl_refs.prev)
(133,ctrl->flags)
(134,ctrl = ref->ctrl)
(135,qc->minimum)
(136,ctrl->type == V4L2_CTRL_TYPE_MENU\n\\n\\t    || ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU)
(137,ctrl->type)
(138,default_value)
(139,qc->default_value = ctrl->default_value)
(140,!ref)
(141,list_empty(&hdl->ctrl_refs)
(142,qc->id & next_flags)
(143,type)
(144,ctrl)
(145,id)
(146,ctrl)
(147,next_flags)
(148,qc)
(149,default_value)
(150,)
(151,ref)
(152,qc)
(153,qc)
(154,qc->elems = ctrl->elems)
(155,)
(156,ref = find_ref(hdl, id)
(157,&ref->node)
(158,qc)
(159,ref)
(160,is_compound)
(161,hdl->ctrl_refs)
(162,qc)
(163,ctrl)
(164,return -EINVAL;)
(165,V4L2_CTRL_TYPE_MENU)
(166,qc->dims)
(167,ref)
(168,RET)
(169,ctrl->elem_size)
(170,ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES)
(171,ctrl->is_ptr)
(172,if (id >= node2id(hdl->ctrl_refs.prev)
(173,sizeof(qc->dims[0])
(174,qc->name)
(175,id < ref->ctrl->id)
(176,ref)
(177,ctrl)
(178,lock)
(179,id)
(180,id)
(181,ref->ctrl)
(182,memcpy(qc->dims, ctrl->dims, qc->nr_of_dims * sizeof(qc->dims[0])
(183,elems)
(184,break;)
(185,ctrl)
(186,ctrl->maximum)
(187,step)
(188,ref)
(189,qc)
(190,type)
(191,sizeof(*qc)
(192,ref->ctrl->type)
(193,ref->ctrl)
(194,ctrl)
(195,type)
(196,)
(197,ref->ctrl->type)
(198,next_flags)
(199,is_compound =\n\\n\\t\\t\\t\\t\\tref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES)
(200,is_compound)
(201,hdl->ctrl_refs)
(202,hdl->ctrl_refs.prev)
(203,id < ref->ctrl->id &&\n\\n\\t\\t\\t\\t    (is_compound & mask)
(204,ctrl->step)
(205,hdl == NULL)
(206,ref)
(207,qc)
(208,qc)
(209,flags)
(210,ref)
(211,step)
(212,is_ptr)
(213,ctrl)
(214,if (id >= V4L2_CID_PRIVATE_BASE)
(215,ref->ctrl)
(216,ref->node)
(217,qc->dims)
(218,EINVAL)
(219,mask)
(220,mask)
(221,ref)
(222,0)
(223,ctrl->id)
(224,qc->maximum = ctrl->maximum)
(225,id < ref->ctrl->id &&\n\\n\\t\\t\\t\\t    (is_compound & mask)
(226,qc->nr_of_dims = ctrl->nr_of_dims)
(227,if ((qc->id & next_flags)
(228,ctrl)
(229,ctrl->nr_of_dims)
(230,match)
(231,ctrl->name)
(232,hdl)
(233,qc->id & next_flags)
(234,match = true)
(235,NULL)
(236,qc)
(237,is_compound & mask)
(238,)
(239,qc->nr_of_dims)
(240,match)
(241,qc)
(242,maximum)
(243,NULL)
(244,id)
(245,match)
(246,match = false)
(247,if (!ref)
(248,id)
(249,ctrl->elems)
(250,ctrl_refs)
(251,type)
(252,qc->id)
(253,is_compound =\n\\n\\t\\t\\t\\t\\tref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES)
(254,qc->id & V4L2_CTRL_ID_MASK)
(255,id)
(256,ctrl)
(257,ctrl)
(258,V4L2_CID_PRIVATE_BASE)
(259,ctrl)
(260,qc->type = ctrl->type)
(261,mask = 0)
(262,ctrl)
(263,qc->id)
(264,ref)
(265,hdl)
(266,step)
(267,qc->name)
(268,ref = NULL)
(269,!list_empty(&hdl->ctrl_refs)
(270,hdl)
(271,V4L2_CTRL_FLAG_NEXT_COMPOUND)
(272,hdl->ctrl_refs)
(273,qc->type)
(274,ref)
(275,ctrl)
(276,0)
(277,hdl->lock)
(278,V4L2_CTRL_FLAG_NEXT_COMPOUND)
(279,ctrl)
(280,node)
(281,(qc->id & next_flags)
(282,qc->flags |= V4L2_CTRL_FLAG_HAS_PAYLOAD)
(283,match)
(284,elem_size)
(285,qc->step = 1)
(286,mask)
(287,ctrl)
(288,true)
(289,if (&ref->node == &hdl->ctrl_refs)
(290,sizeof(qc->name)
(291,hdl->ctrl_refs)
(292,qc->flags = ctrl->flags)
(293,V4L2_CTRL_ID_MASK)
(294,hdl)
(295,qc->id)
(296,ctrl->type)
(297,&hdl->ctrl_refs)
(298,V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND)
(299,mask)
(300,id)
(301,memset(qc, 0, sizeof(*qc)
(302,type)
(303,type)
(304,ctrl->minimum)
(305,ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU)
(306,&ref->node == &hdl->ctrl_refs)
(307,minimum)
(308,)
(309,elems)
(310,-EINVAL)
(311,ref)
(312,qc->elem_size = ctrl->elem_size)
(313,ctrl->dims)
(314,is_compound)
(315,find_ref(hdl, id)
(316,qc)
(317,qc->flags)
(318,is_compound & mask)
(319,&hdl->ctrl_refs)
(320,ctrl)
(321,nr_of_dims)
(322,if (id < ref->ctrl->id &&\n\\n\\t\\t\\t\\t    (is_compound & mask)
(323,name)
(324,dims)
(325,qc->id = id)
(326,ref->ctrl)
(327,qc->step)
(328,minimum)
(329,match)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^