-----label-----
1
-----code-----
int copy_thread(unsigned long clone_flags,
		unsigned long usp, unsigned long kthread_arg,
		struct task_struct *p)
{
	struct pt_regs *c_regs;        /* child's pt_regs */
	unsigned long *childksp;       /* to unwind out of __switch_to() */
	struct callee_regs *c_callee;  /* child's callee regs */
	struct callee_regs *parent_callee;  /* paren't callee */
	struct pt_regs *regs = current_pt_regs();

	/* Mark the specific anchors to begin with (see pic above) */
	c_regs = task_pt_regs(p);
	childksp = (unsigned long *)c_regs - 2;  /* 2 words for FP/BLINK */
	c_callee = ((struct callee_regs *)childksp) - 1;

	/*
	 * __switch_to() uses thread.ksp to start unwinding stack
	 * For kernel threads we don't need to create callee regs, the
	 * stack layout nevertheless needs to remain the same.
	 * Also, since __switch_to anyways unwinds callee regs, we use
	 * this to populate kernel thread entry-pt/args into callee regs,
	 * so that ret_from_kernel_thread() becomes simpler.
	 */
	p->thread.ksp = (unsigned long)c_callee;	/* THREAD_KSP */

	/* __switch_to expects FP(0), BLINK(return addr) at top */
	childksp[0] = 0;			/* fp */
	childksp[1] = (unsigned long)ret_from_fork; /* blink */

	if (unlikely(p->flags & PF_KTHREAD)) {
		memset(c_regs, 0, sizeof(struct pt_regs));

		c_callee->r13 = kthread_arg;
		c_callee->r14 = usp;  /* function */

		return 0;
	}

	/*--------- User Task Only --------------*/

	/* __switch_to expects FP(0), BLINK(return addr) at top of stack */
	childksp[0] = 0;				/* for POP fp */
	childksp[1] = (unsigned long)ret_from_fork;	/* for POP blink */

	/* Copy parents pt regs on child's kernel mode stack */
	*c_regs = *regs;

	if (usp)
		c_regs->sp = usp;

	c_regs->r0 = 0;		/* fork returns 0 in child */

	parent_callee = ((struct callee_regs *)regs) - 1;
	*c_callee = *parent_callee;

	if (unlikely(clone_flags & CLONE_SETTLS)) {
		/*
		 * set task's userland tls data ptr from 4th arg
		 * clone C-lib call is difft from clone sys-call
		 */
		task_thread_info(p)->thr_ptr = regs->r3;
	} else {
		/* Normal fork case: set parent's TLS ptr in child */
		task_thread_info(p)->thr_ptr =
		task_thread_info(current)->thr_ptr;
	}


	/*
	 * setup usermode thread pointer #1:
	 * when child is picked by scheduler, __switch_to() uses @c_callee to
	 * populate usermode callee regs: this works (despite being in a kernel
	 * function) since special return path for child @ret_from_fork()
	 * ensures those regs are not clobbered all the way to RTIE to usermode
	 */
	c_callee->r25 = task_thread_info(p)->thr_ptr;

#ifdef CONFIG_ARC_CURR_IN_REG
	/*
	 * setup usermode thread pointer #2:
	 * however for this special use of r25 in kernel, __switch_to() sets
	 * r25 for kernel needs and only in the final return path is usermode
	 * r25 setup, from pt_regs->user_r25. So set that up as well
	 */
	c_regs->user_r25 = c_callee->r25;
#endif

	return 0;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
7,8
9,10
9,11
11,12
13,14
13,15
15,16
17,18
17,19
18,19
20,21
20,22
23,24
23,25
23,26
23,27
23,28
23,29
23,30
23,31
23,32
23,33
23,34
23,35
23,36
23,37
23,38
23,39
23,40
23,41
23,42
23,43
23,44
23,45
24,25
25,26
25,27
26,27
28,29
28,30
31,32
32,33
32,34
34,35
34,36
37,38
38,39
38,40
39,40
41,42
41,43
44,45
45,46
45,47
46,47
48,49
48,50
51,52
52,53
52,54
53,54
55,56
55,57
55,58
58,59
59,60
60,61
62,63
63,64
63,65
64,65
66,67
66,68
67,68
69,70
71,72
72,73
72,74
73,74
75,76
75,77
76,77
76,78
77,78
77,79
79,80
81,82
84,85
85,86
85,87
86,87
88,89
88,90
89,90
90,91
90,92
91,92
91,93
92,93
94,95
96,97
99,100
100,101
100,102
101,102
101,103
102,103
102,104
103,104
107,108
107,109
108,109
108,110
111,112
113,114
114,115
114,116
115,116
115,117
116,117
120,121
121,122
121,123
122,123
122,124
123,124
126,127
126,128
127,128
127,129
130,131
132,133
132,134
133,134
133,135
134,135
136,137
136,138
137,138
137,139
138,139
141,142
143,144
143,145
143,146
143,147
144,145
145,146
145,147
145,148
145,149
146,147
148,149
151,152
152,153
152,154
153,154
156,157
157,158
157,159
158,159
158,160
159,160
162,163
164,165
165,166
165,167
166,167
166,168
167,168
170,171
172,173
174,175
175,176
175,177
176,177
176,178
177,178
181,182
182,183
182,184
183,184
183,185
184,185
187,188
187,189
188,189
188,190
191,192
193,194
194,195
194,196
195,196
196,197
198,199
199,200
201,202
201,203
202,203
204,205
205,206
205,207
206,207
206,208
207,208
210,211
212,213
213,214
213,215
214,215
214,216
215,216
219,220
220,221
220,222
221,222
223,224
223,225
224,225
225,226
225,227
226,227
226,228
227,228
229,230
231,232
234,235
235,236
235,237
236,237
237,238
239,240
240,241
242,243
242,244
242,245
243,244
243,245
244,245
246,247
246,248
247,248
249,250
251,252
252,253
253,254
253,255
254,255
254,256
255,256
255,257
256,257
258,259
261,262
261,263
262,263
265,266
266,267
267,268
267,269
268,269
268,270
269,270
269,271
270,271
272,273
275,276
275,277
276,277
276,278
277,278
279,280
282,283
283,284
283,285
284,285
284,286
285,286
288,289
288,290
289,290
289,291
290,291
292,293
295,296
-----nextToken-----
2,4,6,8,10,12,14,16,19,21,22,27,29,30,33,35,36,40,42,43,47,49,50,54,56,57,61,65,68,70,74,78,80,82,83,87,93,95,97,98,104,105,106,109,110,112,117,118,119,124,125,128,129,131,135,139,140,142,147,149,150,154,155,160,161,163,168,169,171,173,178,179,180,185,186,189,190,192,197,200,203,208,209,211,216,217,218,222,228,230,232,233,238,241,245,248,250,257,259,260,263,264,271,273,274,278,280,281,286,287,291,293,294,296
-----computeFrom-----
63,64
63,65
72,73
72,74
75,76
75,77
85,86
85,87
88,89
88,90
100,101
100,102
114,115
114,116
121,122
121,123
136,137
136,138
157,158
157,159
165,166
165,167
175,176
175,177
182,183
182,184
194,195
194,196
205,206
205,207
213,214
213,215
220,221
220,222
223,224
223,225
235,236
235,237
246,247
246,248
253,254
253,255
267,268
267,269
283,284
283,285
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;FunctionCallExpression;IdExpression;Name;IdExpression;Name;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
int copy_thread(unsigned long clone_flags,		unsigned long usp, unsigned long kthread_arg,		struct task_struct *p){	struct pt_regs *c_regs;        /* child's pt_regs */	unsigned long *childksp;       /* to unwind out of __switch_to() */	struct callee_regs *c_callee;  /* child's callee regs */	struct callee_regs *parent_callee;  /* paren't callee */	struct pt_regs *regs = current_pt_regs();	/* Mark the specific anchors to begin with (see pic above) */	c_regs = task_pt_regs(p);	childksp = (unsigned long *)c_regs - 2;  /* 2 words for FP/BLINK */	c_callee = ((struct callee_regs *)childksp) - 1;	/*	 * __switch_to() uses thread.ksp to start unwinding stack	 * For kernel threads we don't need to create callee regs, the	 * stack layout nevertheless needs to remain the same.	 * Also, since __switch_to anyways unwinds callee regs, we use	 * this to populate kernel thread entry-pt/args into callee regs,	 * so that ret_from_kernel_thread() becomes simpler.	 */	p->thread.ksp = (unsigned long)c_callee;	/* THREAD_KSP */	/* __switch_to expects FP(0), BLINK(return addr) at top */	childksp[0] = 0;			/* fp */	childksp[1] = (unsigned long)ret_from_fork; /* blink */	if (unlikely(p->flags & PF_KTHREAD)) {		memset(c_regs, 0, sizeof(struct pt_regs));		c_callee->r13 = kthread_arg;		c_callee->r14 = usp;  /* function */		return 0;	}	/*--------- User Task Only --------------*/	/* __switch_to expects FP(0), BLINK(return addr) at top of stack */	childksp[0] = 0;				/* for POP fp */	childksp[1] = (unsigned long)ret_from_fork;	/* for POP blink */	/* Copy parents pt regs on child's kernel mode stack */	*c_regs = *regs;	if (usp)		c_regs->sp = usp;	c_regs->r0 = 0;		/* fork returns 0 in child */	parent_callee = ((struct callee_regs *)regs) - 1;	*c_callee = *parent_callee;	if (unlikely(clone_flags & CLONE_SETTLS)) {		/*		 * set task's userland tls data ptr from 4th arg		 * clone C-lib call is difft from clone sys-call		 */		task_thread_info(p)->thr_ptr = regs->r3;	} else {		/* Normal fork case: set parent's TLS ptr in child */		task_thread_info(p)->thr_ptr =		task_thread_info(current)->thr_ptr;	}	/*	 * setup usermode thread pointer #1:	 * when child is picked by scheduler, __switch_to() uses @c_callee to	 * populate usermode callee regs: this works (despite being in a kernel	 * function) since special return path for child @ret_from_fork()	 * ensures those regs are not clobbered all the way to RTIE to usermode	 */	c_callee->r25 = task_thread_info(p)->thr_ptr;#ifdef CONFIG_ARC_CURR_IN_REG	/*	 * setup usermode thread pointer #2:	 * however for this special use of r25 in kernel, __switch_to() sets	 * r25 for kernel needs and only in the final return path is usermode	 * r25 setup, from pt_regs->user_r25. So set that up as well	 */	c_regs->user_r25 = c_callee->r25;#endif	return 0;}
int
copy_thread(unsigned long clone_flags,		unsigned long usp, unsigned long kthread_arg,		struct task_struct *p)
copy_thread
unsigned long clone_flags
unsigned long
clone_flags
clone_flags
unsigned long usp
unsigned long
usp
usp
unsigned long kthread_arg
unsigned long
kthread_arg
kthread_arg
struct task_struct *p
struct task_struct
task_struct
*p
*
p
{	struct pt_regs *c_regs;        /* child's pt_regs */	unsigned long *childksp;       /* to unwind out of __switch_to() */	struct callee_regs *c_callee;  /* child's callee regs */	struct callee_regs *parent_callee;  /* paren't callee */	struct pt_regs *regs = current_pt_regs();	/* Mark the specific anchors to begin with (see pic above) */	c_regs = task_pt_regs(p);	childksp = (unsigned long *)c_regs - 2;  /* 2 words for FP/BLINK */	c_callee = ((struct callee_regs *)childksp) - 1;	/*	 * __switch_to() uses thread.ksp to start unwinding stack	 * For kernel threads we don't need to create callee regs, the	 * stack layout nevertheless needs to remain the same.	 * Also, since __switch_to anyways unwinds callee regs, we use	 * this to populate kernel thread entry-pt/args into callee regs,	 * so that ret_from_kernel_thread() becomes simpler.	 */	p->thread.ksp = (unsigned long)c_callee;	/* THREAD_KSP */	/* __switch_to expects FP(0), BLINK(return addr) at top */	childksp[0] = 0;			/* fp */	childksp[1] = (unsigned long)ret_from_fork; /* blink */	if (unlikely(p->flags & PF_KTHREAD)) {		memset(c_regs, 0, sizeof(struct pt_regs));		c_callee->r13 = kthread_arg;		c_callee->r14 = usp;  /* function */		return 0;	}	/*--------- User Task Only --------------*/	/* __switch_to expects FP(0), BLINK(return addr) at top of stack */	childksp[0] = 0;				/* for POP fp */	childksp[1] = (unsigned long)ret_from_fork;	/* for POP blink */	/* Copy parents pt regs on child's kernel mode stack */	*c_regs = *regs;	if (usp)		c_regs->sp = usp;	c_regs->r0 = 0;		/* fork returns 0 in child */	parent_callee = ((struct callee_regs *)regs) - 1;	*c_callee = *parent_callee;	if (unlikely(clone_flags & CLONE_SETTLS)) {		/*		 * set task's userland tls data ptr from 4th arg		 * clone C-lib call is difft from clone sys-call		 */		task_thread_info(p)->thr_ptr = regs->r3;	} else {		/* Normal fork case: set parent's TLS ptr in child */		task_thread_info(p)->thr_ptr =		task_thread_info(current)->thr_ptr;	}	/*	 * setup usermode thread pointer #1:	 * when child is picked by scheduler, __switch_to() uses @c_callee to	 * populate usermode callee regs: this works (despite being in a kernel	 * function) since special return path for child @ret_from_fork()	 * ensures those regs are not clobbered all the way to RTIE to usermode	 */	c_callee->r25 = task_thread_info(p)->thr_ptr;#ifdef CONFIG_ARC_CURR_IN_REG	/*	 * setup usermode thread pointer #2:	 * however for this special use of r25 in kernel, __switch_to() sets	 * r25 for kernel needs and only in the final return path is usermode	 * r25 setup, from pt_regs->user_r25. So set that up as well	 */	c_regs->user_r25 = c_callee->r25;#endif	return 0;}
struct pt_regs *c_regs;
struct pt_regs *c_regs;
struct pt_regs
pt_regs
*c_regs
*
c_regs
unsigned long *childksp;
unsigned long *childksp;
unsigned long
*childksp
*
childksp
struct callee_regs *c_callee;
struct callee_regs *c_callee;
struct callee_regs
callee_regs
*c_callee
*
c_callee
struct callee_regs *parent_callee;
struct callee_regs *parent_callee;
struct callee_regs
callee_regs
*parent_callee
*
parent_callee
struct pt_regs *regs = current_pt_regs();
struct pt_regs *regs = current_pt_regs();
struct pt_regs
pt_regs
*regs = current_pt_regs()
*
regs
= current_pt_regs()
current_pt_regs()
current_pt_regs
current_pt_regs
c_regs = task_pt_regs(p);
c_regs = task_pt_regs(p)
c_regs
c_regs
task_pt_regs(p)
task_pt_regs
task_pt_regs
p
p
childksp = (unsigned long *)c_regs - 2;
childksp = (unsigned long *)c_regs - 2
childksp
childksp
(unsigned long *)c_regs - 2
(unsigned long *)c_regs
unsigned long *
unsigned long
*
*
c_regs
c_regs
2
c_callee = ((struct callee_regs *)childksp) - 1;
c_callee = ((struct callee_regs *)childksp) - 1
c_callee
c_callee
((struct callee_regs *)childksp) - 1
((struct callee_regs *)childksp)
(struct callee_regs *)childksp
struct callee_regs *
struct callee_regs
callee_regs
*
*
childksp
childksp
1
p->thread.ksp = (unsigned long)c_callee;
p->thread.ksp = (unsigned long)c_callee
p->thread.ksp
p->thread
p
p
thread
ksp
(unsigned long)c_callee
unsigned long
unsigned long

c_callee
c_callee
childksp[0] = 0;
childksp[0] = 0
childksp[0]
childksp
childksp
0
0
childksp[1] = (unsigned long)ret_from_fork;
childksp[1] = (unsigned long)ret_from_fork
childksp[1]
childksp
childksp
1
(unsigned long)ret_from_fork
unsigned long
unsigned long

ret_from_fork
ret_from_fork
if (unlikely(p->flags & PF_KTHREAD)) {		memset(c_regs, 0, sizeof(struct pt_regs));		c_callee->r13 = kthread_arg;		c_callee->r14 = usp;  /* function */		return 0;	}
unlikely(p->flags & PF_KTHREAD)
unlikely
unlikely
p->flags & PF_KTHREAD
p->flags
p
p
flags
PF_KTHREAD
PF_KTHREAD
{		memset(c_regs, 0, sizeof(struct pt_regs));		c_callee->r13 = kthread_arg;		c_callee->r14 = usp;  /* function */		return 0;	}
memset(c_regs, 0, sizeof(struct pt_regs));
memset(c_regs, 0, sizeof(struct pt_regs))
memset
memset
c_regs
c_regs
0
sizeof(struct pt_regs)
struct pt_regs
struct pt_regs
pt_regs

c_callee->r13 = kthread_arg;
c_callee->r13 = kthread_arg
c_callee->r13
c_callee
c_callee
r13
kthread_arg
kthread_arg
c_callee->r14 = usp;
c_callee->r14 = usp
c_callee->r14
c_callee
c_callee
r14
usp
usp
return 0;
0
childksp[0] = 0;
childksp[0] = 0
childksp[0]
childksp
childksp
0
0
childksp[1] = (unsigned long)ret_from_fork;
childksp[1] = (unsigned long)ret_from_fork
childksp[1]
childksp
childksp
1
(unsigned long)ret_from_fork
unsigned long
unsigned long

ret_from_fork
ret_from_fork
*c_regs = *regs;
*c_regs = *regs
*c_regs
c_regs
c_regs
*regs
regs
regs
if (usp)		c_regs->sp = usp;
usp
usp
c_regs->sp = usp;
c_regs->sp = usp
c_regs->sp
c_regs
c_regs
sp
usp
usp
c_regs->r0 = 0;
c_regs->r0 = 0
c_regs->r0
c_regs
c_regs
r0
0
parent_callee = ((struct callee_regs *)regs) - 1;
parent_callee = ((struct callee_regs *)regs) - 1
parent_callee
parent_callee
((struct callee_regs *)regs) - 1
((struct callee_regs *)regs)
(struct callee_regs *)regs
struct callee_regs *
struct callee_regs
callee_regs
*
*
regs
regs
1
*c_callee = *parent_callee;
*c_callee = *parent_callee
*c_callee
c_callee
c_callee
*parent_callee
parent_callee
parent_callee
if (unlikely(clone_flags & CLONE_SETTLS)) {		/*		 * set task's userland tls data ptr from 4th arg		 * clone C-lib call is difft from clone sys-call		 */		task_thread_info(p)->thr_ptr = regs->r3;	} else {		/* Normal fork case: set parent's TLS ptr in child */		task_thread_info(p)->thr_ptr =		task_thread_info(current)->thr_ptr;	}
unlikely(clone_flags & CLONE_SETTLS)
unlikely
unlikely
clone_flags & CLONE_SETTLS
clone_flags
clone_flags
CLONE_SETTLS
CLONE_SETTLS
{		/*		 * set task's userland tls data ptr from 4th arg		 * clone C-lib call is difft from clone sys-call		 */		task_thread_info(p)->thr_ptr = regs->r3;	}
task_thread_info(p)->thr_ptr = regs->r3;
task_thread_info(p)->thr_ptr = regs->r3
task_thread_info(p)->thr_ptr
task_thread_info(p)
task_thread_info
task_thread_info
p
p
thr_ptr
regs->r3
regs
regs
r3
{		/* Normal fork case: set parent's TLS ptr in child */		task_thread_info(p)->thr_ptr =		task_thread_info(current)->thr_ptr;	}
task_thread_info(p)->thr_ptr =		task_thread_info(current)->thr_ptr;
task_thread_info(p)->thr_ptr =		task_thread_info(current)->thr_ptr
task_thread_info(p)->thr_ptr
task_thread_info(p)
task_thread_info
task_thread_info
p
p
thr_ptr
task_thread_info(current)->thr_ptr
task_thread_info(current)
task_thread_info
task_thread_info
current
current
thr_ptr
c_callee->r25 = task_thread_info(p)->thr_ptr;
c_callee->r25 = task_thread_info(p)->thr_ptr
c_callee->r25
c_callee
c_callee
r25
task_thread_info(p)->thr_ptr
task_thread_info(p)
task_thread_info
task_thread_info
p
p
thr_ptr
return 0;
0
-----joern-----
(37,64,0)
(44,24,0)
(122,103,0)
(18,42,0)
(107,85,0)
(45,35,0)
(72,105,0)
(105,124,0)
(63,27,0)
(6,141,0)
(45,157,0)
(43,23,0)
(114,96,0)
(73,8,0)
(139,42,0)
(33,133,0)
(153,42,0)
(112,71,0)
(102,65,0)
(137,5,0)
(150,45,0)
(66,42,0)
(69,124,0)
(122,152,0)
(96,42,0)
(128,147,0)
(141,29,0)
(126,96,0)
(68,58,0)
(108,132,0)
(39,109,0)
(122,12,0)
(112,20,0)
(24,109,0)
(31,42,0)
(148,28,0)
(101,152,0)
(84,137,0)
(112,158,0)
(150,42,0)
(122,64,0)
(79,89,0)
(105,39,0)
(50,42,0)
(67,125,0)
(56,126,0)
(77,39,0)
(112,79,0)
(123,107,0)
(55,12,0)
(145,19,0)
(76,152,0)
(34,92,0)
(113,70,0)
(20,1,0)
(55,15,0)
(58,19,0)
(152,151,0)
(70,19,0)
(157,39,0)
(81,27,0)
(99,65,0)
(27,42,0)
(8,124,0)
(107,123,0)
(38,113,0)
(155,126,0)
(1,42,0)
(19,70,0)
(27,13,0)
(11,79,0)
(47,92,0)
(112,92,0)
(114,23,0)
(14,85,0)
(133,30,0)
(122,79,0)
(94,132,0)
(156,1,0)
(132,108,0)
(3,1,0)
(5,124,0)
(32,6,0)
(127,112,0)
(39,157,0)
(53,45,0)
(96,114,0)
(142,103,0)
(113,38,0)
(25,61,0)
(119,42,0)
(89,42,0)
(147,35,0)
(152,35,0)
(36,25,0)
(59,69,0)
(100,99,0)
(16,109,0)
(99,124,0)
(49,112,0)
(93,58,0)
(140,81,0)
(129,52,0)
(69,79,0)
(83,124,0)
(20,150,0)
(132,94,0)
(103,35,0)
(98,42,0)
(52,88,0)
(112,16,0)
(16,8,0)
(51,71,0)
(83,1,0)
(79,69,0)
(60,107,0)
(75,42,0)
(21,125,0)
(62,5,0)
(48,20,0)
(8,16,0)
(144,23,0)
(115,132,0)
(111,18,0)
(104,156,0)
(38,42,0)
(107,96,0)
(134,114,0)
(122,17,0)
(49,122,0)
(71,1,0)
(28,89,0)
(39,105,0)
(116,24,0)
(52,98,0)
(64,96,0)
(35,42,0)
(143,141,0)
(75,81,0)
(112,64,0)
(57,113,0)
(87,65,0)
(156,12,0)
(5,137,0)
(19,58,0)
(85,35,0)
(54,17,0)
(118,151,0)
(13,27,0)
(58,27,0)
(80,83,0)
(0,158,0)
(136,26,0)
(121,96,0)
(23,114,0)
(45,150,0)
(71,75,0)
(120,64,0)
(61,25,0)
(85,107,0)
(117,45,0)
(112,17,0)
(125,96,0)
(2,35,0)
(110,69,0)
(109,24,0)
(4,158,0)
(125,66,0)
(82,104,0)
(28,74,0)
(147,38,0)
(88,52,0)
(6,1,0)
(10,16,0)
(7,156,0)
(89,28,0)
(112,125,0)
(158,35,0)
(25,97,0)
(40,42,0)
(70,42,0)
(92,1,0)
(133,130,0)
(64,26,0)
(30,133,0)
(112,147,0)
(146,156,0)
(149,42,0)
(109,22,0)
(23,144,0)
(28,35,0)
(130,133,0)
(17,96,0)
(1,83,0)
(157,42,0)
(98,52,0)
(156,104,0)
(103,55,0)
(137,108,0)
(130,42,0)
(106,25,0)
(46,55,0)
(23,1,0)
(26,42,0)
(78,20,0)
(151,29,0)
(126,98,0)
(41,42,0)
(39,108,0)
(90,99,0)
(112,126,0)
(112,137,0)
(35,85,0)
(65,99,0)
(104,82,0)
(58,93,0)
(112,42,0)
(81,75,0)
(24,27,0)
(74,28,0)
(92,18,0)
(65,87,0)
(151,12,0)
(108,159,0)
(154,122,0)
(91,17,0)
(17,130,0)
(138,66,0)
(135,103,0)
(112,6,0)
(86,6,0)
(158,157,0)
(9,94,0)
(131,70,0)
(23,1,1)
(24,27,1)
(5,62,1)
(20,1,1)
(112,16,1)
(89,28,1)
(112,17,1)
(92,1,1)
(58,27,1)
(146,87,1)
(155,66,1)
(5,124,1)
(122,103,1)
(105,72,1)
(38,113,1)
(46,103,1)
(114,134,1)
(118,152,1)
(91,54,1)
(83,80,1)
(125,21,1)
(7,146,1)
(148,79,1)
(131,18,1)
(34,95,1)
(112,79,1)
(125,96,1)
(112,64,1)
(109,24,1)
(103,35,1)
(122,17,1)
(121,1,1)
(8,73,1)
(49,122,1)
(126,96,1)
(25,106,1)
(33,17,1)
(47,34,1)
(17,96,1)
(102,99,1)
(72,158,1)
(105,124,1)
(75,81,1)
(53,20,1)
(111,92,1)
(73,61,1)
(76,101,1)
(6,32,1)
(140,71,1)
(122,64,1)
(108,132,1)
(126,56,1)
(24,44,1)
(71,51,1)
(79,69,1)
(86,95,1)
(77,105,1)
(81,140,1)
(70,19,1)
(158,35,1)
(135,156,1)
(157,39,1)
(104,82,1)
(45,35,1)
(145,58,1)
(28,148,1)
(112,147,1)
(48,157,1)
(95,75,1)
(107,60,1)
(122,152,1)
(113,70,1)
(99,100,1)
(85,107,1)
(112,71,1)
(106,36,1)
(107,123,1)
(20,78,1)
(16,10,1)
(133,30,1)
(23,144,1)
(85,14,1)
(122,154,1)
(116,16,1)
(134,23,1)
(57,147,1)
(55,15,1)
(8,124,1)
(9,137,1)
(147,35,1)
(79,11,1)
(32,86,1)
(138,125,1)
(92,47,1)
(19,58,1)
(65,102,1)
(117,53,1)
(104,7,1)
(26,136,1)
(43,121,1)
(45,117,1)
(4,0,1)
(152,76,1)
(96,114,1)
(0,109,1)
(64,37,1)
(98,52,1)
(36,38,1)
(129,126,1)
(44,116,1)
(10,8,1)
(110,59,1)
(35,85,1)
(107,96,1)
(90,130,1)
(64,96,1)
(154,151,1)
(78,48,1)
(112,92,1)
(39,108,1)
(122,79,1)
(13,63,1)
(94,9,1)
(112,127,1)
(127,150,1)
(6,1,1)
(112,137,1)
(141,143,1)
(27,13,1)
(51,98,1)
(156,104,1)
(156,1,1)
(143,6,1)
(137,5,1)
(25,97,1)
(39,109,1)
(103,142,1)
(14,107,1)
(52,88,1)
(150,45,1)
(132,115,1)
(152,35,1)
(112,6,1)
(49,112,1)
(62,61,1)
(39,105,1)
(67,87,1)
(23,43,1)
(120,89,1)
(60,2,1)
(99,124,1)
(100,90,1)
(39,77,1)
(68,131,1)
(58,93,1)
(66,138,1)
(115,94,1)
(113,57,1)
(84,5,1)
(65,99,1)
(17,91,1)
(54,26,1)
(69,124,1)
(130,133,1)
(45,157,1)
(28,35,1)
(83,124,1)
(112,126,1)
(112,20,1)
(58,68,1)
(37,120,1)
(21,67,1)
(142,135,1)
(136,64,1)
(16,8,1)
(141,29,1)
(28,74,1)
(114,23,1)
(61,25,1)
(1,83,1)
(80,3,1)
(19,145,1)
(112,158,1)
(18,111,1)
(151,29,1)
(81,27,1)
(2,96,1)
(56,155,1)
(87,65,1)
(101,55,1)
(158,4,1)
(69,110,1)
(3,27,1)
(132,94,1)
(55,46,1)
(59,35,1)
(71,1,1)
(128,70,1)
(34,141,1)
(112,125,1)
(137,84,1)
(151,118,1)
(147,128,1)
(133,33,1)
(0,108,1)
(52,129,1)
(11,69,1)
(129,87,2)
(23,144,2)
(75,81,2)
(51,87,2)
(152,35,2)
(105,87,2)
(78,87,2)
(117,87,2)
(84,61,2)
(151,87,2)
(112,126,2)
(55,15,2)
(61,25,2)
(58,27,2)
(20,87,2)
(45,87,2)
(21,87,2)
(58,87,2)
(19,87,2)
(109,24,2)
(39,109,2)
(122,152,2)
(125,87,2)
(135,87,2)
(154,87,2)
(104,82,2)
(105,124,2)
(77,87,2)
(96,114,2)
(24,61,2)
(47,87,2)
(39,108,2)
(131,87,2)
(112,137,2)
(52,88,2)
(17,96,2)
(112,92,2)
(94,61,2)
(87,65,2)
(70,87,2)
(45,35,2)
(28,35,2)
(114,23,2)
(132,61,2)
(38,87,2)
(7,87,2)
(111,87,2)
(9,61,2)
(18,87,2)
(75,87,2)
(122,17,2)
(72,87,2)
(67,87,2)
(152,87,2)
(109,61,2)
(150,87,2)
(133,30,2)
(28,74,2)
(107,123,2)
(103,87,2)
(155,87,2)
(81,87,2)
(5,61,2)
(146,87,2)
(128,87,2)
(66,87,2)
(24,27,2)
(151,29,2)
(83,124,2)
(140,87,2)
(156,104,2)
(46,87,2)
(156,87,2)
(158,35,2)
(125,96,2)
(68,87,2)
(57,87,2)
(99,124,2)
(71,1,2)
(48,87,2)
(126,96,2)
(130,133,2)
(49,122,2)
(79,69,2)
(132,94,2)
(52,87,2)
(112,64,2)
(141,95,2)
(112,125,2)
(6,1,2)
(55,87,2)
(1,83,2)
(150,45,2)
(112,20,2)
(69,124,2)
(115,61,2)
(116,61,2)
(141,29,2)
(32,95,2)
(112,71,2)
(64,96,2)
(34,87,2)
(92,87,2)
(38,113,2)
(86,95,2)
(112,16,2)
(0,87,2)
(56,87,2)
(103,35,2)
(81,27,2)
(113,70,2)
(53,87,2)
(138,87,2)
(104,87,2)
(27,13,2)
(143,95,2)
(35,85,2)
(127,87,2)
(137,5,2)
(108,61,2)
(39,87,2)
(126,87,2)
(71,87,2)
(113,87,2)
(44,61,2)
(118,87,2)
(95,87,2)
(158,87,2)
(36,87,2)
(4,87,2)
(157,39,2)
(112,147,2)
(73,61,2)
(10,61,2)
(19,58,2)
(92,1,2)
(25,97,2)
(23,1,2)
(147,87,2)
(89,28,2)
(5,124,2)
(76,87,2)
(45,157,2)
(98,87,2)
(145,87,2)
(122,103,2)
(112,79,2)
(142,87,2)
(8,61,2)
(58,93,2)
(6,95,2)
(49,112,2)
(20,1,2)
(122,79,2)
(61,87,2)
(147,35,2)
(8,124,2)
(101,87,2)
(85,107,2)
(157,87,2)
(98,52,2)
(65,99,2)
(108,132,2)
(137,61,2)
(112,158,2)
(107,96,2)
(112,17,2)
(25,87,2)
(112,87,2)
(156,1,2)
(62,61,2)
(122,64,2)
(39,105,2)
(112,6,2)
(70,19,2)
(16,8,2)
(16,61,2)
(106,87,2)
(122,87,2)
-----------------------------------
(0,c_callee)
(1,c_regs = task_pt_regs(p)
(2,c_callee)
(3,c_regs)
(4,r25)
(5,task_thread_info(p)
(6,c_regs->sp)
(7,0)
(8,task_thread_info(p)
(9,current)
(10,thr_ptr)
(11,ksp)
(12,)
(13,current_pt_regs()
(14,1)
(15,unsigned long kthread_arg)
(16,task_thread_info(p)
(17,childksp[1])
(18,c_regs->r0 = 0)
(19,((struct callee_regs *)
(20,c_regs->user_r25)
(21,0)
(22,)
(23,(unsigned long *)
(24,regs->r3)
(25,clone_flags & CLONE_SETTLS)
(26,childksp[0] = 0)
(27,*regs = current_pt_regs()
(28,(unsigned long)
(29,unsigned long usp)
(30,unsigned long)
(31,if (unlikely(clone_flags & CLONE_SETTLS)
(32,sp)
(33,ret_from_fork)
(34,c_regs)
(35,c_callee = ((struct callee_regs *)
(36,clone_flags)
(37,0)
(38,*c_callee = *parent_callee)
(39,task_thread_info(p)
(40,if (unlikely(p->flags & PF_KTHREAD)
(41,c_regs)
(42,)
(43,c_regs)
(44,r3)
(45,c_callee->r25)
(46,kthread_arg)
(47,r0)
(48,c_regs)
(49,RET)
(50,childksp)
(51,c_regs)
(52,(unsigned long)
(53,c_callee)
(54,childksp)
(55,c_callee->r13 = kthread_arg)
(56,1)
(57,parent_callee)
(58,(struct callee_regs *)
(59,p)
(60,childksp)
(61,unlikely(clone_flags & CLONE_SETTLS)
(62,p)
(63,regs)
(64,childksp[0])
(65,p->flags & PF_KTHREAD)
(66,childksp[0] = 0)
(67,childksp)
(68,regs)
(69,p->thread)
(70,parent_callee = ((struct callee_regs *)
(71,*c_regs)
(72,p)
(73,p)
(74,unsigned long)
(75,*c_regs = *regs)
(76,r14)
(77,thr_ptr)
(78,user_r25)
(79,p->thread.ksp)
(80,p)
(81,*regs)
(82,struct pt_regs)
(83,task_pt_regs(p)
(84,thr_ptr)
(85,((struct callee_regs *)
(86,c_regs)
(87,unlikely(p->flags & PF_KTHREAD)
(88,unsigned long)
(89,p->thread.ksp = (unsigned long)
(90,p)
(91,1)
(92,c_regs->r0)
(93,struct callee_regs *)
(94,task_thread_info(current)
(95,usp)
(96,childksp = (unsigned long *)
(97,unsigned long clone_flags)
(98,childksp[1] = (unsigned long)
(99,p->flags)
(100,flags)
(101,c_callee)
(102,PF_KTHREAD)
(103,c_callee->r13)
(104,sizeof(struct pt_regs)
(105,task_thread_info(p)
(106,CLONE_SETTLS)
(107,(struct callee_regs *)
(108,task_thread_info(p)
(109,task_thread_info(p)
(110,thread)
(111,0)
(112,return 0;)
(113,*parent_callee)
(114,(unsigned long *)
(115,thr_ptr)
(116,regs)
(117,r25)
(118,usp)
(119,parent_callee)
(120,childksp)
(121,childksp)
(122,return 0;)
(123,struct callee_regs *)
(124,struct task_struct *p)
(125,childksp[0])
(126,childksp[1])
(127,0)
(128,c_callee)
(129,ret_from_fork)
(130,childksp[1] = (unsigned long)
(131,parent_callee)
(132,task_thread_info(current)
(133,(unsigned long)
(134,2)
(135,c_callee)
(136,0)
(137,task_thread_info(p)
(138,0)
(139,c_callee)
(140,regs)
(141,c_regs->sp = usp)
(142,r13)
(143,usp)
(144,unsigned long *)
(145,1)
(146,c_regs)
(147,*c_callee)
(148,c_callee)
(149,if (usp)
(150,c_regs->user_r25 = c_callee->r25)
(151,c_callee->r14 = usp)
(152,c_callee->r14)
(153,regs)
(154,0)
(155,childksp)
(156,memset(c_regs, 0, sizeof(struct pt_regs)
(157,c_callee->r25 = task_thread_info(p)
(158,c_callee->r25)
(159,)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^