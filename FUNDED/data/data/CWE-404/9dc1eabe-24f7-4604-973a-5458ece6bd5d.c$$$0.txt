-----label-----
1
-----code-----
int
copy_thread(unsigned long clone_flags, unsigned long usp,
	    unsigned long arg,
	    struct task_struct *p)
{
	extern void ret_from_fork(void);
	extern void ret_from_kernel_thread(void);

	struct thread_info *childti = task_thread_info(p);
	struct pt_regs *childregs = task_pt_regs(p);
	struct pt_regs *regs = current_pt_regs();
	struct switch_stack *childstack, *stack;

	childstack = ((struct switch_stack *) childregs) - 1;
	childti->pcb.ksp = (unsigned long) childstack;
	childti->pcb.flags = 1;	/* set FEN, clear everything else */

	if (unlikely(p->flags & PF_KTHREAD)) {
		/* kernel thread */
		memset(childstack, 0,
			sizeof(struct switch_stack) + sizeof(struct pt_regs));
		childstack->r26 = (unsigned long) ret_from_kernel_thread;
		childstack->r9 = usp;	/* function */
		childstack->r10 = arg;
		childregs->hae = alpha_mv.hae_cache,
		childti->pcb.usp = 0;
		return 0;
	}
	/* Note: if CLONE_SETTLS is not set, then we must inherit the
	   value from the parent, which will have been set by the block
	   copy in dup_task_struct.  This is non-intuitive, but is
	   required for proper operation in the case of a threaded
	   application calling fork.  */
	if (clone_flags & CLONE_SETTLS)
		childti->pcb.unique = regs->r20;
	childti->pcb.usp = usp ?: rdusp();
	*childregs = *regs;
	childregs->r0 = 0;
	childregs->r19 = 0;
	childregs->r20 = 1;	/* OSF/1 has some strange fork() semantics.  */
	regs->r20 = 0;
	stack = ((struct switch_stack *) regs) - 1;
	*childstack = *stack;
	childstack->r26 = (unsigned long) ret_from_fork;
	return 0;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
7,8
9,10
9,11
11,12
13,14
13,15
15,16
17,18
17,19
18,19
20,21
20,22
23,24
23,25
23,26
23,27
23,28
23,29
23,30
23,31
23,32
23,33
23,34
23,35
23,36
23,37
23,38
23,39
23,40
23,41
23,42
23,43
23,44
24,25
25,26
25,27
27,28
27,29
29,30
29,31
31,32
33,34
34,35
34,36
36,37
36,38
38,39
38,40
40,41
42,43
43,44
43,45
44,45
46,47
46,48
46,49
49,50
50,51
50,52
51,52
53,54
55,56
56,57
56,58
57,58
59,60
59,61
59,62
62,63
63,64
63,65
64,65
66,67
68,69
69,70
69,71
70,71
72,73
72,74
72,75
75,76
76,77
77,78
79,80
80,81
80,82
80,83
81,82
83,84
83,85
86,87
86,88
89,90
90,91
90,92
91,92
93,94
93,95
94,95
95,96
95,97
96,97
96,98
97,98
99,100
101,102
104,105
105,106
105,107
106,107
106,108
107,108
107,109
108,109
112,113
112,114
113,114
113,115
116,117
118,119
119,120
119,121
120,121
120,122
121,122
121,123
122,123
127,128
127,129
128,129
128,130
129,130
131,132
131,133
132,133
132,134
133,134
136,137
138,139
138,140
138,141
138,142
138,143
138,144
139,140
140,141
140,142
140,143
140,144
141,142
143,144
146,147
146,148
147,148
148,149
148,150
149,150
152,153
153,154
153,155
154,155
157,158
158,159
158,160
159,160
159,161
160,161
163,164
163,165
164,165
164,166
167,168
169,170
170,171
170,172
171,172
171,173
172,173
175,176
177,178
178,179
178,180
179,180
179,181
180,181
183,184
185,186
186,187
186,188
187,188
187,189
188,189
188,190
189,190
192,193
192,194
193,194
196,197
196,198
197,198
197,199
198,199
198,200
199,200
204,205
206,207
206,208
207,208
207,209
208,209
210,211
212,213
213,214
213,215
214,215
214,216
215,216
215,217
216,217
220,221
220,222
221,222
224,225
225,226
225,227
226,227
226,228
227,228
227,229
228,229
232,233
232,234
233,234
235,236
236,237
238,239
239,240
239,241
240,241
241,242
243,244
244,245
246,247
247,248
247,249
248,249
248,250
249,250
253,254
254,255
254,256
255,256
255,257
256,257
260,261
261,262
261,263
262,263
262,264
263,264
267,268
268,269
268,270
269,270
269,271
270,271
274,275
275,276
275,277
276,277
278,279
278,280
279,280
280,281
280,282
281,282
281,283
282,283
284,285
286,287
289,290
290,291
290,292
291,292
292,293
294,295
295,296
297,298
298,299
298,300
299,300
299,301
300,301
303,304
303,305
304,305
304,306
307,308
309,310
-----nextToken-----
2,4,6,8,10,12,14,16,19,21,22,26,28,30,32,35,37,39,41,45,47,48,52,54,58,60,61,65,67,71,73,74,78,82,84,85,87,88,92,98,100,102,103,109,110,111,114,115,117,123,124,125,126,130,134,135,137,142,144,145,150,151,155,156,161,162,165,166,168,173,174,176,181,182,184,190,191,194,195,200,201,202,203,205,209,211,217,218,219,222,223,229,230,231,234,237,242,245,250,251,252,257,258,259,264,265,266,271,272,273,277,283,285,287,288,293,296,301,302,305,306,308,310
-----computeFrom-----
90,91
90,92
93,94
93,95
105,106
105,107
119,120
119,121
131,132
131,133
146,147
146,148
158,159
158,160
170,171
170,172
178,179
178,180
187,188
187,189
196,197
196,198
207,208
207,209
213,214
213,215
225,226
225,227
239,240
239,241
247,248
247,249
254,255
254,256
261,262
261,263
268,269
268,270
275,276
275,277
278,279
278,280
290,291
290,292
298,299
298,300
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BinaryExpression;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;ExpressionList;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ConditionalExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;UnaryExpression;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;IdExpression;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
intcopy_thread(unsigned long clone_flags, unsigned long usp,	    unsigned long arg,	    struct task_struct *p){	extern void ret_from_fork(void);	extern void ret_from_kernel_thread(void);	struct thread_info *childti = task_thread_info(p);	struct pt_regs *childregs = task_pt_regs(p);	struct pt_regs *regs = current_pt_regs();	struct switch_stack *childstack, *stack;	childstack = ((struct switch_stack *) childregs) - 1;	childti->pcb.ksp = (unsigned long) childstack;	childti->pcb.flags = 1;	/* set FEN, clear everything else */	if (unlikely(p->flags & PF_KTHREAD)) {		/* kernel thread */		memset(childstack, 0,			sizeof(struct switch_stack) + sizeof(struct pt_regs));		childstack->r26 = (unsigned long) ret_from_kernel_thread;		childstack->r9 = usp;	/* function */		childstack->r10 = arg;		childregs->hae = alpha_mv.hae_cache,		childti->pcb.usp = 0;		return 0;	}	/* Note: if CLONE_SETTLS is not set, then we must inherit the	   value from the parent, which will have been set by the block	   copy in dup_task_struct.  This is non-intuitive, but is	   required for proper operation in the case of a threaded	   application calling fork.  */	if (clone_flags & CLONE_SETTLS)		childti->pcb.unique = regs->r20;	childti->pcb.usp = usp ?: rdusp();	*childregs = *regs;	childregs->r0 = 0;	childregs->r19 = 0;	childregs->r20 = 1;	/* OSF/1 has some strange fork() semantics.  */	regs->r20 = 0;	stack = ((struct switch_stack *) regs) - 1;	*childstack = *stack;	childstack->r26 = (unsigned long) ret_from_fork;	return 0;}
int
copy_thread(unsigned long clone_flags, unsigned long usp,	    unsigned long arg,	    struct task_struct *p)
copy_thread
unsigned long clone_flags
unsigned long
clone_flags
clone_flags
unsigned long usp
unsigned long
usp
usp
unsigned long arg
unsigned long
arg
arg
struct task_struct *p
struct task_struct
task_struct
*p
*
p
{	extern void ret_from_fork(void);	extern void ret_from_kernel_thread(void);	struct thread_info *childti = task_thread_info(p);	struct pt_regs *childregs = task_pt_regs(p);	struct pt_regs *regs = current_pt_regs();	struct switch_stack *childstack, *stack;	childstack = ((struct switch_stack *) childregs) - 1;	childti->pcb.ksp = (unsigned long) childstack;	childti->pcb.flags = 1;	/* set FEN, clear everything else */	if (unlikely(p->flags & PF_KTHREAD)) {		/* kernel thread */		memset(childstack, 0,			sizeof(struct switch_stack) + sizeof(struct pt_regs));		childstack->r26 = (unsigned long) ret_from_kernel_thread;		childstack->r9 = usp;	/* function */		childstack->r10 = arg;		childregs->hae = alpha_mv.hae_cache,		childti->pcb.usp = 0;		return 0;	}	/* Note: if CLONE_SETTLS is not set, then we must inherit the	   value from the parent, which will have been set by the block	   copy in dup_task_struct.  This is non-intuitive, but is	   required for proper operation in the case of a threaded	   application calling fork.  */	if (clone_flags & CLONE_SETTLS)		childti->pcb.unique = regs->r20;	childti->pcb.usp = usp ?: rdusp();	*childregs = *regs;	childregs->r0 = 0;	childregs->r19 = 0;	childregs->r20 = 1;	/* OSF/1 has some strange fork() semantics.  */	regs->r20 = 0;	stack = ((struct switch_stack *) regs) - 1;	*childstack = *stack;	childstack->r26 = (unsigned long) ret_from_fork;	return 0;}
extern void ret_from_fork(void);
extern void ret_from_fork(void);
extern void
ret_from_fork(void)
ret_from_fork
void
void


extern void ret_from_kernel_thread(void);
extern void ret_from_kernel_thread(void);
extern void
ret_from_kernel_thread(void)
ret_from_kernel_thread
void
void


struct thread_info *childti = task_thread_info(p);
struct thread_info *childti = task_thread_info(p);
struct thread_info
thread_info
*childti = task_thread_info(p)
*
childti
= task_thread_info(p)
task_thread_info(p)
task_thread_info
task_thread_info
p
p
struct pt_regs *childregs = task_pt_regs(p);
struct pt_regs *childregs = task_pt_regs(p);
struct pt_regs
pt_regs
*childregs = task_pt_regs(p)
*
childregs
= task_pt_regs(p)
task_pt_regs(p)
task_pt_regs
task_pt_regs
p
p
struct pt_regs *regs = current_pt_regs();
struct pt_regs *regs = current_pt_regs();
struct pt_regs
pt_regs
*regs = current_pt_regs()
*
regs
= current_pt_regs()
current_pt_regs()
current_pt_regs
current_pt_regs
struct switch_stack *childstack, *stack;
struct switch_stack *childstack, *stack;
struct switch_stack
switch_stack
*childstack
*
childstack
*stack
*
stack
childstack = ((struct switch_stack *) childregs) - 1;
childstack = ((struct switch_stack *) childregs) - 1
childstack
childstack
((struct switch_stack *) childregs) - 1
((struct switch_stack *) childregs)
(struct switch_stack *) childregs
struct switch_stack *
struct switch_stack
switch_stack
*
*
childregs
childregs
1
childti->pcb.ksp = (unsigned long) childstack;
childti->pcb.ksp = (unsigned long) childstack
childti->pcb.ksp
childti->pcb
childti
childti
pcb
ksp
(unsigned long) childstack
unsigned long
unsigned long

childstack
childstack
childti->pcb.flags = 1;
childti->pcb.flags = 1
childti->pcb.flags
childti->pcb
childti
childti
pcb
flags
1
if (unlikely(p->flags & PF_KTHREAD)) {		/* kernel thread */		memset(childstack, 0,			sizeof(struct switch_stack) + sizeof(struct pt_regs));		childstack->r26 = (unsigned long) ret_from_kernel_thread;		childstack->r9 = usp;	/* function */		childstack->r10 = arg;		childregs->hae = alpha_mv.hae_cache,		childti->pcb.usp = 0;		return 0;	}
unlikely(p->flags & PF_KTHREAD)
unlikely
unlikely
p->flags & PF_KTHREAD
p->flags
p
p
flags
PF_KTHREAD
PF_KTHREAD
{		/* kernel thread */		memset(childstack, 0,			sizeof(struct switch_stack) + sizeof(struct pt_regs));		childstack->r26 = (unsigned long) ret_from_kernel_thread;		childstack->r9 = usp;	/* function */		childstack->r10 = arg;		childregs->hae = alpha_mv.hae_cache,		childti->pcb.usp = 0;		return 0;	}
memset(childstack, 0,			sizeof(struct switch_stack) + sizeof(struct pt_regs));
memset(childstack, 0,			sizeof(struct switch_stack) + sizeof(struct pt_regs))
memset
memset
childstack
childstack
0
sizeof(struct switch_stack) + sizeof(struct pt_regs)
sizeof(struct switch_stack)
struct switch_stack
struct switch_stack
switch_stack

sizeof(struct pt_regs)
struct pt_regs
struct pt_regs
pt_regs

childstack->r26 = (unsigned long) ret_from_kernel_thread;
childstack->r26 = (unsigned long) ret_from_kernel_thread
childstack->r26
childstack
childstack
r26
(unsigned long) ret_from_kernel_thread
unsigned long
unsigned long

ret_from_kernel_thread
ret_from_kernel_thread
childstack->r9 = usp;
childstack->r9 = usp
childstack->r9
childstack
childstack
r9
usp
usp
childstack->r10 = arg;
childstack->r10 = arg
childstack->r10
childstack
childstack
r10
arg
arg
childregs->hae = alpha_mv.hae_cache,		childti->pcb.usp = 0;
childregs->hae = alpha_mv.hae_cache,		childti->pcb.usp = 0
childregs->hae = alpha_mv.hae_cache
childregs->hae
childregs
childregs
hae
alpha_mv.hae_cache
alpha_mv
alpha_mv
hae_cache
childti->pcb.usp = 0
childti->pcb.usp
childti->pcb
childti
childti
pcb
usp
0
return 0;
0
if (clone_flags & CLONE_SETTLS)		childti->pcb.unique = regs->r20;
clone_flags & CLONE_SETTLS
clone_flags
clone_flags
CLONE_SETTLS
CLONE_SETTLS
childti->pcb.unique = regs->r20;
childti->pcb.unique = regs->r20
childti->pcb.unique
childti->pcb
childti
childti
pcb
unique
regs->r20
regs
regs
r20
childti->pcb.usp = usp ?: rdusp();
childti->pcb.usp = usp ?: rdusp()
childti->pcb.usp
childti->pcb
childti
childti
pcb
usp
usp ?: rdusp()
usp
usp
rdusp()
rdusp
rdusp
*childregs = *regs;
*childregs = *regs
*childregs
childregs
childregs
*regs
regs
regs
childregs->r0 = 0;
childregs->r0 = 0
childregs->r0
childregs
childregs
r0
0
childregs->r19 = 0;
childregs->r19 = 0
childregs->r19
childregs
childregs
r19
0
childregs->r20 = 1;
childregs->r20 = 1
childregs->r20
childregs
childregs
r20
1
regs->r20 = 0;
regs->r20 = 0
regs->r20
regs
regs
r20
0
stack = ((struct switch_stack *) regs) - 1;
stack = ((struct switch_stack *) regs) - 1
stack
stack
((struct switch_stack *) regs) - 1
((struct switch_stack *) regs)
(struct switch_stack *) regs
struct switch_stack *
struct switch_stack
switch_stack
*
*
regs
regs
1
*childstack = *stack;
*childstack = *stack
*childstack
childstack
childstack
*stack
stack
stack
childstack->r26 = (unsigned long) ret_from_fork;
childstack->r26 = (unsigned long) ret_from_fork
childstack->r26
childstack
childstack
r26
(unsigned long) ret_from_fork
unsigned long
unsigned long

ret_from_fork
ret_from_fork
return 0;
0
-----joern-----
(149,88,0)
(139,41,0)
(75,1,0)
(113,107,0)
(148,145,0)
(29,17,0)
(147,35,0)
(98,143,0)
(123,7,0)
(128,30,0)
(123,78,0)
(90,92,0)
(13,77,0)
(95,52,0)
(8,143,0)
(58,42,0)
(41,148,0)
(30,45,0)
(12,145,0)
(145,61,0)
(52,95,0)
(91,115,0)
(25,37,0)
(6,147,0)
(67,26,0)
(144,32,0)
(66,150,0)
(123,100,0)
(61,94,0)
(123,2,0)
(53,18,0)
(44,40,0)
(55,101,0)
(85,1,0)
(11,58,0)
(4,144,0)
(86,123,0)
(123,55,0)
(1,65,0)
(97,63,0)
(82,112,0)
(116,22,0)
(48,112,0)
(136,112,0)
(74,147,0)
(37,118,0)
(14,152,0)
(3,82,0)
(101,55,0)
(114,8,0)
(149,58,0)
(103,65,0)
(122,8,0)
(29,31,0)
(64,34,0)
(2,90,0)
(32,43,0)
(89,46,0)
(68,152,0)
(128,35,0)
(131,13,0)
(113,152,0)
(45,19,0)
(128,20,0)
(13,32,0)
(123,35,0)
(125,96,0)
(130,13,0)
(153,152,0)
(28,30,0)
(83,153,0)
(128,144,0)
(83,93,0)
(119,82,0)
(155,62,0)
(145,152,0)
(61,145,0)
(54,128,0)
(134,92,0)
(110,46,0)
(121,152,0)
(31,152,0)
(93,83,0)
(59,32,0)
(123,89,0)
(123,152,0)
(156,145,0)
(114,72,0)
(35,14,0)
(151,152,0)
(128,62,0)
(90,152,0)
(115,31,0)
(146,96,0)
(33,144,0)
(88,149,0)
(69,52,0)
(24,31,0)
(34,120,0)
(16,152,0)
(8,122,0)
(77,96,0)
(96,125,0)
(108,83,0)
(32,152,0)
(29,43,0)
(99,66,0)
(31,115,0)
(7,26,0)
(26,152,0)
(112,48,0)
(112,82,0)
(34,32,0)
(23,32,0)
(156,62,0)
(71,152,0)
(122,32,0)
(50,89,0)
(5,152,0)
(78,153,0)
(81,37,0)
(143,98,0)
(100,18,0)
(22,150,0)
(58,149,0)
(60,122,0)
(46,152,0)
(7,31,0)
(14,23,0)
(42,152,0)
(135,30,0)
(80,61,0)
(92,90,0)
(21,66,0)
(43,29,0)
(78,32,0)
(144,63,0)
(141,152,0)
(23,38,0)
(132,100,0)
(82,94,0)
(51,52,0)
(92,113,0)
(57,78,0)
(56,78,0)
(77,20,0)
(133,20,0)
(42,58,0)
(117,152,0)
(10,113,0)
(102,43,0)
(76,35,0)
(149,113,0)
(127,100,0)
(41,151,0)
(49,23,0)
(79,148,0)
(63,39,0)
(140,45,0)
(22,31,0)
(45,20,0)
(101,145,0)
(84,7,0)
(128,13,0)
(106,152,0)
(120,47,0)
(153,83,0)
(128,41,0)
(123,34,0)
(47,42,0)
(9,149,0)
(147,145,0)
(27,42,0)
(73,156,0)
(43,32,0)
(65,152,0)
(35,147,0)
(150,66,0)
(129,148,0)
(40,133,0)
(23,14,0)
(148,41,0)
(109,152,0)
(126,151,0)
(124,47,0)
(115,94,0)
(1,113,0)
(111,156,0)
(104,7,0)
(17,29,0)
(62,156,0)
(15,101,0)
(143,8,0)
(38,23,0)
(138,122,0)
(55,95,0)
(2,31,0)
(36,22,0)
(122,20,0)
(30,32,0)
(87,101,0)
(150,133,0)
(123,41,0)
(96,77,0)
(0,2,0)
(105,128,0)
(18,152,0)
(123,1,0)
(154,152,0)
(62,40,0)
(105,123,0)
(128,22,0)
(8,114,0)
(72,114,0)
(47,120,0)
(52,113,0)
(120,152,0)
(142,29,0)
(107,113,0)
(70,89,0)
(63,20,0)
(89,31,0)
(100,31,0)
(137,55,0)
(64,42,1)
(63,97,1)
(23,49,1)
(23,32,1)
(123,2,1)
(130,131,1)
(123,35,1)
(128,13,1)
(57,56,1)
(123,7,1)
(132,90,1)
(126,41,1)
(110,89,1)
(108,78,1)
(131,122,1)
(11,149,1)
(0,117,1)
(52,69,1)
(27,65,1)
(21,99,1)
(142,59,1)
(85,26,1)
(156,145,1)
(149,88,1)
(22,36,1)
(103,1,1)
(23,38,1)
(37,25,1)
(136,82,1)
(87,37,1)
(1,75,1)
(34,32,1)
(56,120,1)
(51,55,1)
(123,86,1)
(140,30,1)
(69,51,1)
(50,70,1)
(63,39,1)
(83,93,1)
(114,143,1)
(147,6,1)
(123,41,1)
(52,113,1)
(91,24,1)
(15,87,1)
(13,130,1)
(123,34,1)
(84,104,1)
(155,156,1)
(32,43,1)
(148,145,1)
(127,132,1)
(128,144,1)
(58,11,1)
(62,155,1)
(73,150,1)
(49,35,1)
(30,32,1)
(75,85,1)
(78,57,1)
(24,145,1)
(101,15,1)
(14,23,1)
(4,33,1)
(26,67,1)
(37,118,1)
(3,119,1)
(9,27,1)
(128,41,1)
(70,18,1)
(156,111,1)
(42,58,1)
(36,116,1)
(81,48,1)
(35,147,1)
(128,62,1)
(124,34,1)
(95,52,1)
(82,94,1)
(146,13,1)
(128,54,1)
(46,110,1)
(143,98,1)
(122,32,1)
(47,124,1)
(80,12,1)
(41,148,1)
(99,22,1)
(139,148,1)
(2,0,1)
(45,19,1)
(35,76,1)
(97,144,1)
(41,139,1)
(117,37,1)
(123,100,1)
(113,107,1)
(112,82,1)
(151,126,1)
(29,142,1)
(54,40,1)
(144,32,1)
(22,31,1)
(33,45,1)
(148,129,1)
(45,140,1)
(101,145,1)
(28,135,1)
(116,63,1)
(115,91,1)
(123,1,1)
(29,31,1)
(67,7,1)
(89,31,1)
(96,146,1)
(34,64,1)
(6,74,1)
(123,89,1)
(48,112,1)
(66,21,1)
(90,92,1)
(55,137,1)
(137,101,1)
(65,103,1)
(43,29,1)
(128,30,1)
(18,53,1)
(8,143,1)
(76,147,1)
(77,96,1)
(111,73,1)
(150,66,1)
(122,8,1)
(61,80,1)
(120,47,1)
(123,78,1)
(82,3,1)
(147,145,1)
(129,79,1)
(119,151,1)
(144,4,1)
(128,22,1)
(25,81,1)
(30,28,1)
(145,61,1)
(1,113,1)
(105,128,1)
(138,48,1)
(107,10,1)
(114,72,1)
(8,114,1)
(10,31,1)
(40,44,1)
(74,32,1)
(115,94,1)
(86,153,1)
(61,94,1)
(135,77,1)
(31,115,1)
(149,9,1)
(96,125,1)
(53,100,1)
(92,113,1)
(105,123,1)
(153,83,1)
(2,31,1)
(29,17,1)
(128,35,1)
(149,113,1)
(100,127,1)
(143,60,1)
(7,31,1)
(117,95,1)
(62,156,1)
(55,101,1)
(104,46,1)
(83,108,1)
(13,32,1)
(47,42,1)
(100,31,1)
(44,62,1)
(60,138,1)
(58,149,1)
(102,29,1)
(134,2,1)
(78,32,1)
(43,102,1)
(89,50,1)
(92,134,1)
(59,113,1)
(112,136,1)
(79,14,1)
(7,84,1)
(123,55,1)
(29,17,2)
(143,48,2)
(100,31,2)
(36,48,2)
(128,30,2)
(115,94,2)
(7,48,2)
(50,48,2)
(123,89,2)
(117,48,2)
(95,37,2)
(62,48,2)
(47,42,2)
(44,48,2)
(150,48,2)
(105,123,2)
(2,31,2)
(144,48,2)
(35,147,2)
(104,48,2)
(27,48,2)
(134,48,2)
(8,143,2)
(23,38,2)
(42,48,2)
(128,35,2)
(149,113,2)
(21,48,2)
(112,82,2)
(147,145,2)
(103,48,2)
(13,32,2)
(52,37,2)
(110,48,2)
(120,47,2)
(4,48,2)
(73,48,2)
(99,48,2)
(89,31,2)
(55,101,2)
(123,78,2)
(122,8,2)
(128,62,2)
(153,48,2)
(25,48,2)
(81,48,2)
(58,149,2)
(140,48,2)
(26,48,2)
(31,115,2)
(46,48,2)
(135,48,2)
(100,48,2)
(132,48,2)
(47,48,2)
(23,32,2)
(34,32,2)
(22,48,2)
(8,48,2)
(92,48,2)
(43,29,2)
(155,48,2)
(30,32,2)
(63,48,2)
(96,125,2)
(95,52,2)
(37,48,2)
(150,66,2)
(137,37,2)
(101,37,2)
(122,48,2)
(66,48,2)
(22,31,2)
(108,48,2)
(101,145,2)
(148,145,2)
(77,48,2)
(89,48,2)
(128,41,2)
(75,48,2)
(123,34,2)
(32,43,2)
(144,32,2)
(114,48,2)
(123,2,2)
(67,48,2)
(9,48,2)
(123,41,2)
(15,37,2)
(29,31,2)
(33,48,2)
(54,48,2)
(2,48,2)
(48,112,2)
(41,148,2)
(69,37,2)
(128,48,2)
(60,48,2)
(34,48,2)
(55,37,2)
(123,55,2)
(123,7,2)
(70,48,2)
(84,48,2)
(90,92,2)
(58,48,2)
(77,96,2)
(53,48,2)
(64,48,2)
(143,98,2)
(61,94,2)
(86,48,2)
(40,48,2)
(127,48,2)
(123,100,2)
(114,72,2)
(13,48,2)
(138,48,2)
(123,1,2)
(78,48,2)
(1,48,2)
(90,48,2)
(0,48,2)
(131,48,2)
(7,31,2)
(149,88,2)
(128,13,2)
(85,48,2)
(111,48,2)
(42,58,2)
(96,48,2)
(145,61,2)
(92,113,2)
(153,83,2)
(97,48,2)
(87,37,2)
(120,48,2)
(82,94,2)
(45,48,2)
(149,48,2)
(30,48,2)
(78,32,2)
(14,23,2)
(52,113,2)
(123,35,2)
(1,113,2)
(8,114,2)
(11,48,2)
(63,39,2)
(65,48,2)
(18,48,2)
(156,48,2)
(57,48,2)
(146,48,2)
(123,48,2)
(45,19,2)
(51,37,2)
(56,48,2)
(62,156,2)
(124,48,2)
(105,128,2)
(128,22,2)
(116,48,2)
(83,93,2)
(128,144,2)
(156,145,2)
(28,48,2)
(130,48,2)
(83,48,2)
(37,118,2)
(122,32,2)
(113,107,2)
-----------------------------------
(0,childregs)
(1,regs->r20)
(2,*childregs)
(3,flags)
(4,r10)
(5,if (clone_flags & CLONE_SETTLS)
(6,pcb)
(7,childregs->r20)
(8,sizeof(struct switch_stack)
(9,regs)
(10,regs)
(11,1)
(12,childti)
(13,childstack->r26)
(14,childti->pcb.ksp = (unsigned long)
(15,pcb)
(16,childregs)
(17,struct switch_stack *)
(18,childregs->r0 = 0)
(19,unsigned long usp)
(20,)
(21,hae_cache)
(22,childregs->hae)
(23,(unsigned long)
(24,childregs)
(25,CLONE_SETTLS)
(26,childregs->r20 = 1)
(27,stack)
(28,r9)
(29,(struct switch_stack *)
(30,childstack->r9)
(31,*childregs = task_pt_regs(p)
(32,childstack = ((struct switch_stack *)
(33,childstack)
(34,*childstack)
(35,childti->pcb.ksp)
(36,hae)
(37,clone_flags & CLONE_SETTLS)
(38,unsigned long)
(39,unsigned long arg)
(40,childti->pcb.usp = 0)
(41,childti->pcb.flags)
(42,stack = ((struct switch_stack *)
(43,((struct switch_stack *)
(44,0)
(45,childstack->r9 = usp)
(46,childregs->r19 = 0)
(47,*stack)
(48,unlikely(p->flags & PF_KTHREAD)
(49,childstack)
(50,r19)
(51,regs)
(52,regs->r20)
(53,0)
(54,0)
(55,childti->pcb.unique)
(56,childstack)
(57,r26)
(58,((struct switch_stack *)
(59,childstack)
(60,0)
(61,task_thread_info(p)
(62,childti->pcb.usp)
(63,childstack->r10 = arg)
(64,childstack)
(65,regs->r20 = 0)
(66,alpha_mv.hae_cache)
(67,1)
(68,regs)
(69,r20)
(70,childregs)
(71,ret_from_fork)
(72,struct pt_regs)
(73,childti)
(74,childti)
(75,r20)
(76,ksp)
(77,childstack->r26 = (unsigned long)
(78,childstack->r26)
(79,childti)
(80,p)
(81,clone_flags)
(82,p->flags)
(83,(unsigned long)
(84,r20)
(85,regs)
(86,0)
(87,childti)
(88,struct switch_stack *)
(89,childregs->r19)
(90,*childregs = *regs)
(91,p)
(92,*regs)
(93,unsigned long)
(94,struct task_struct *p)
(95,childti->pcb.unique = regs->r20)
(96,(unsigned long)
(97,arg)
(98,struct switch_stack)
(99,alpha_mv)
(100,childregs->r0)
(101,childti->pcb)
(102,1)
(103,0)
(104,childregs)
(105,RET)
(106,ret_from_kernel_thread)
(107,current_pt_regs()
(108,ret_from_fork)
(109,childstack)
(110,0)
(111,pcb)
(112,p->flags & PF_KTHREAD)
(113,*regs = current_pt_regs()
(114,sizeof(struct pt_regs)
(115,task_pt_regs(p)
(116,childregs)
(117,rdusp()
(118,unsigned long clone_flags)
(119,p)
(120,*childstack = *stack)
(121,stack)
(122,memset(childstack, 0,\n\\n\\t\\t\\tsizeof(struct switch_stack)
(123,return 0;)
(124,stack)
(125,unsigned long)
(126,1)
(127,r0)
(128,return 0;)
(129,pcb)
(130,r26)
(131,childstack)
(132,childregs)
(133,)
(134,regs)
(135,childstack)
(136,PF_KTHREAD)
(137,unique)
(138,childstack)
(139,flags)
(140,usp)
(141,childti)
(142,childregs)
(143,sizeof(struct switch_stack)
(144,childstack->r10)
(145,*childti = task_thread_info(p)
(146,ret_from_kernel_thread)
(147,childti->pcb)
(148,childti->pcb)
(149,(struct switch_stack *)
(150,childregs->hae = alpha_mv.hae_cache)
(151,childti->pcb.flags = 1)
(152,)
(153,childstack->r26 = (unsigned long)
(154,if (unlikely(p->flags & PF_KTHREAD)
(155,usp)
(156,childti->pcb)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^