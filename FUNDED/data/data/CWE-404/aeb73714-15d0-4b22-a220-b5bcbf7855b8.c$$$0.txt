-----label-----
1
-----code-----
static int hpet_next_event(unsigned long delta,
			   struct clock_event_device *evt, int timer)
{
	u32 cnt;
	s32 res;

	cnt = hpet_readl(HPET_COUNTER);
	cnt += (u32) delta;
	hpet_writel(cnt, HPET_Tn_CMP(timer));

	/*
	 * HPETs are a complete disaster. The compare register is
	 * based on a equal comparison and neither provides a less
	 * than or equal functionality (which would require to take
	 * the wraparound into account) nor a simple count down event
	 * mode. Further the write to the comparator register is
	 * delayed internally up to two HPET clock cycles in certain
	 * chipsets (ATI, ICH9,10). Some newer AMD chipsets have even
	 * longer delays. We worked around that by reading back the
	 * compare register, but that required another workaround for
	 * ICH9,10 chips where the first readout after write can
	 * return the old stale value. We already had a minimum
	 * programming delta of 5us enforced, but a NMI or SMI hitting
	 * between the counter readout and the comparator write can
	 * move us behind that point easily. Now instead of reading
	 * the compare register back several times, we make the ETIME
	 * decision based on the following: Return ETIME if the
	 * counter value after the write is less than HPET_MIN_CYCLES
	 * away from the event or if the counter is already ahead of
	 * the event. The minimum programming delta for the generic
	 * clockevents code is set to 1.5 * HPET_MIN_CYCLES.
	 */
	res = (s32)(cnt - (u32)hpet_readl(HPET_COUNTER));

	return res < HPET_MIN_CYCLES ? -ETIME : 0;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
7,8
9,10
9,11
10,11
12,13
12,14
15,16
15,17
17,18
19,20
19,21
19,22
19,23
19,24
19,25
19,26
20,21
21,22
21,23
22,23
24,25
26,27
27,28
27,29
28,29
30,31
32,33
33,34
33,35
34,35
36,37
36,38
37,38
39,40
41,42
42,43
42,44
43,44
45,46
45,47
46,47
46,48
47,48
50,51
52,53
53,54
53,55
53,56
54,55
56,57
58,59
58,60
59,60
61,62
63,64
64,65
64,66
65,66
67,68
67,69
68,69
69,70
71,72
71,73
72,73
74,75
74,76
75,76
75,77
76,77
79,80
79,81
80,81
82,83
84,85
85,86
85,87
85,88
86,87
86,88
87,88
89,90
91,92
92,93
-----nextToken-----
2,4,6,8,11,13,14,16,18,23,25,29,31,35,38,40,44,48,49,51,55,57,60,62,66,70,73,77,78,81,83,88,90,93,94
-----computeFrom-----
33,34
33,35
42,43
42,44
64,65
64,66
71,72
71,73
86,87
86,88
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;ConditionalExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;
-----ast_node-----
static int hpet_next_event(unsigned long delta,			   struct clock_event_device *evt, int timer){	u32 cnt;	s32 res;	cnt = hpet_readl(HPET_COUNTER);	cnt += (u32) delta;	hpet_writel(cnt, HPET_Tn_CMP(timer));	/*	 * HPETs are a complete disaster. The compare register is	 * based on a equal comparison and neither provides a less	 * than or equal functionality (which would require to take	 * the wraparound into account) nor a simple count down event	 * mode. Further the write to the comparator register is	 * delayed internally up to two HPET clock cycles in certain	 * chipsets (ATI, ICH9,10). Some newer AMD chipsets have even	 * longer delays. We worked around that by reading back the	 * compare register, but that required another workaround for	 * ICH9,10 chips where the first readout after write can	 * return the old stale value. We already had a minimum	 * programming delta of 5us enforced, but a NMI or SMI hitting	 * between the counter readout and the comparator write can	 * move us behind that point easily. Now instead of reading	 * the compare register back several times, we make the ETIME	 * decision based on the following: Return ETIME if the	 * counter value after the write is less than HPET_MIN_CYCLES	 * away from the event or if the counter is already ahead of	 * the event. The minimum programming delta for the generic	 * clockevents code is set to 1.5 * HPET_MIN_CYCLES.	 */	res = (s32)(cnt - (u32)hpet_readl(HPET_COUNTER));	return res < HPET_MIN_CYCLES ? -ETIME : 0;}
static int
hpet_next_event(unsigned long delta,			   struct clock_event_device *evt, int timer)
hpet_next_event
unsigned long delta
unsigned long
delta
delta
struct clock_event_device *evt
struct clock_event_device
clock_event_device
*evt
*
evt
int timer
int
timer
timer
{	u32 cnt;	s32 res;	cnt = hpet_readl(HPET_COUNTER);	cnt += (u32) delta;	hpet_writel(cnt, HPET_Tn_CMP(timer));	/*	 * HPETs are a complete disaster. The compare register is	 * based on a equal comparison and neither provides a less	 * than or equal functionality (which would require to take	 * the wraparound into account) nor a simple count down event	 * mode. Further the write to the comparator register is	 * delayed internally up to two HPET clock cycles in certain	 * chipsets (ATI, ICH9,10). Some newer AMD chipsets have even	 * longer delays. We worked around that by reading back the	 * compare register, but that required another workaround for	 * ICH9,10 chips where the first readout after write can	 * return the old stale value. We already had a minimum	 * programming delta of 5us enforced, but a NMI or SMI hitting	 * between the counter readout and the comparator write can	 * move us behind that point easily. Now instead of reading	 * the compare register back several times, we make the ETIME	 * decision based on the following: Return ETIME if the	 * counter value after the write is less than HPET_MIN_CYCLES	 * away from the event or if the counter is already ahead of	 * the event. The minimum programming delta for the generic	 * clockevents code is set to 1.5 * HPET_MIN_CYCLES.	 */	res = (s32)(cnt - (u32)hpet_readl(HPET_COUNTER));	return res < HPET_MIN_CYCLES ? -ETIME : 0;}
u32 cnt;
u32 cnt;
u32
u32
cnt
cnt
s32 res;
s32 res;
s32
s32
res
res
cnt = hpet_readl(HPET_COUNTER);
cnt = hpet_readl(HPET_COUNTER)
cnt
cnt
hpet_readl(HPET_COUNTER)
hpet_readl
hpet_readl
HPET_COUNTER
HPET_COUNTER
cnt += (u32) delta;
cnt += (u32) delta
cnt
cnt
(u32) delta
u32
u32
u32

delta
delta
hpet_writel(cnt, HPET_Tn_CMP(timer));
hpet_writel(cnt, HPET_Tn_CMP(timer))
hpet_writel
hpet_writel
cnt
cnt
HPET_Tn_CMP(timer)
HPET_Tn_CMP
HPET_Tn_CMP
timer
timer
res = (s32)(cnt - (u32)hpet_readl(HPET_COUNTER));
res = (s32)(cnt - (u32)hpet_readl(HPET_COUNTER))
res
res
(s32)(cnt - (u32)hpet_readl(HPET_COUNTER))
(s32)
s32
s32
cnt - (u32)hpet_readl(HPET_COUNTER)
cnt
cnt
(u32)hpet_readl(HPET_COUNTER)
u32
u32
u32

hpet_readl(HPET_COUNTER)
hpet_readl
hpet_readl
HPET_COUNTER
HPET_COUNTER
return res < HPET_MIN_CYCLES ? -ETIME : 0;
res < HPET_MIN_CYCLES ? -ETIME : 0
res < HPET_MIN_CYCLES
res
res
HPET_MIN_CYCLES
HPET_MIN_CYCLES
-ETIME
ETIME
ETIME
0
-----joern-----
(14,5,0)
(33,16,0)
(18,6,0)
(29,6,0)
(11,15,0)
(26,22,0)
(9,35,0)
(35,0,0)
(2,29,0)
(10,1,0)
(34,11,0)
(17,10,0)
(19,29,0)
(27,8,0)
(23,2,0)
(13,16,0)
(11,8,0)
(2,22,0)
(4,5,0)
(10,18,0)
(29,2,0)
(31,20,0)
(18,10,0)
(0,8,0)
(5,6,0)
(29,3,0)
(6,8,0)
(24,33,0)
(32,6,0)
(2,23,0)
(16,33,0)
(6,5,0)
(25,18,0)
(16,20,0)
(21,0,0)
(30,3,0)
(18,8,0)
(20,8,0)
(5,12,0)
(3,0,0)
(16,35,0)
(3,29,0)
(36,35,0)
(22,2,0)
(3,30,0)
(5,14,0)
(35,16,0)
(15,11,0)
(28,15,0)
(7,8,0)
(0,3,0)
(6,11,0)
(31,20,1)
(29,6,1)
(20,16,1)
(19,21,1)
(16,35,1)
(22,26,1)
(10,17,1)
(36,0,1)
(26,19,1)
(6,5,1)
(25,6,1)
(35,0,1)
(18,10,1)
(28,34,1)
(5,4,1)
(15,28,1)
(16,13,1)
(2,22,1)
(5,14,1)
(10,1,1)
(5,12,1)
(29,2,1)
(32,11,1)
(16,33,1)
(18,6,1)
(13,35,1)
(17,25,1)
(0,3,1)
(6,11,1)
(24,35,1)
(33,24,1)
(9,36,1)
(4,32,1)
(2,23,1)
(3,29,1)
(21,18,1)
(11,15,1)
(35,9,1)
(3,30,1)
(5,12,2)
(16,33,2)
(35,0,2)
(24,35,2)
(18,6,2)
(6,11,2)
(0,3,2)
(18,10,2)
(3,29,2)
(6,5,2)
(11,15,2)
(31,20,2)
(2,22,2)
(10,1,2)
(2,23,2)
(16,35,2)
(3,30,2)
(29,2,2)
(13,35,2)
(29,6,2)
(5,14,2)
(33,35,2)
-----------------------------------
(0,res = (s32)
(1,int timer)
(2,(u32)
(3,(s32)
(4,delta)
(5,(u32)
(6,cnt += (u32)
(7,cnt)
(8,)
(9,HPET_MIN_CYCLES)
(10,HPET_Tn_CMP(timer)
(11,cnt = hpet_readl(HPET_COUNTER)
(12,unsigned long delta)
(13,0)
(14,u32)
(15,hpet_readl(HPET_COUNTER)
(16,res < HPET_MIN_CYCLES ? -ETIME : 0)
(17,timer)
(18,hpet_writel(cnt, HPET_Tn_CMP(timer)
(19,cnt)
(20,return res < HPET_MIN_CYCLES ? -ETIME : 0;)
(21,res)
(22,hpet_readl(HPET_COUNTER)
(23,u32)
(24,ETIME)
(25,cnt)
(26,HPET_COUNTER)
(27,res)
(28,HPET_COUNTER)
(29,cnt - (u32)
(30,s32)
(31,RET)
(32,cnt)
(33,-ETIME)
(34,cnt)
(35,res < HPET_MIN_CYCLES)
(36,res)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^