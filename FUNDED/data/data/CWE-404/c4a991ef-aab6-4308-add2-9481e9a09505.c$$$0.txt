-----label-----
0
-----code-----
static void mqueue_evict_inode(struct inode *inode)
{
	struct mqueue_inode_info *info;
	struct user_struct *user;
	unsigned long mq_bytes, mq_treesize;
	struct ipc_namespace *ipc_ns;
	struct msg_msg *msg, *nmsg;
	LIST_HEAD(tmp_msg);

	clear_inode(inode);

	if (S_ISDIR(inode->i_mode))
		return;

	ipc_ns = get_ns_from_inode(inode);
	info = MQUEUE_I(inode);
	spin_lock(&info->lock);
	while ((msg = msg_get(info)) != NULL)
		list_add_tail(&msg->m_list, &tmp_msg);
	kfree(info->node_cache);
	spin_unlock(&info->lock);

	list_for_each_entry_safe(msg, nmsg, &tmp_msg, m_list) {
		list_del(&msg->m_list);
		free_msg(msg);
	}

	/* Total amount of bytes accounted for the mqueue */
	mq_treesize = info->attr.mq_maxmsg * sizeof(struct msg_msg) +
		min_t(unsigned int, info->attr.mq_maxmsg, MQ_PRIO_MAX) *
		sizeof(struct posix_msg_tree_node);

	mq_bytes = mq_treesize + (info->attr.mq_maxmsg *
				  info->attr.mq_msgsize);

	user = info->user;
	if (user) {
		spin_lock(&mq_lock);
		user->mq_bytes -= mq_bytes;
		/*
		 * get_ns_from_inode() ensures that the
		 * (ipc_ns = sb->s_fs_info) is either a valid ipc_ns
		 * to which we now hold a reference, or it is NULL.
		 * We can't put it here under mq_lock, though.
		 */
		if (ipc_ns)
			ipc_ns->mq_queues_count--;
		spin_unlock(&mq_lock);
		free_uid(user);
	}
	if (ipc_ns)
		put_ipc_ns(ipc_ns);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
6,7
8,9
8,10
11,12
11,13
11,14
11,15
11,16
11,17
11,18
11,19
11,20
11,21
11,22
11,23
11,24
11,25
11,26
11,27
11,28
11,29
11,30
11,31
11,32
11,33
12,13
13,14
13,15
14,15
16,17
16,18
19,20
20,21
20,22
21,22
23,24
23,25
26,27
27,28
27,29
27,30
29,30
31,32
33,34
34,35
34,36
35,36
37,38
37,39
40,41
41,42
41,43
41,44
42,43
44,45
44,46
47,48
47,49
50,51
51,52
51,53
52,53
54,55
55,56
57,58
58,59
58,60
59,60
61,62
63,64
63,65
64,65
64,66
65,66
67,68
67,69
68,69
72,73
73,74
73,75
74,75
76,77
76,78
77,78
79,80
81,82
82,83
82,84
83,84
85,86
85,87
86,87
88,89
90,91
91,92
91,93
92,93
94,95
95,96
95,97
96,97
99,100
99,101
100,101
100,102
101,102
102,103
102,104
103,104
105,106
105,107
106,107
108,109
110,111
112,113
113,114
113,115
113,116
114,115
116,117
117,118
117,119
118,119
121,122
122,123
124,125
125,126
125,127
126,127
128,129
128,130
129,130
132,133
133,134
133,135
134,135
136,137
137,138
137,139
138,139
141,142
142,143
142,144
142,145
142,146
142,147
143,144
145,146
147,148
149,150
150,151
152,153
154,155
155,156
155,157
156,157
157,158
157,159
158,159
160,161
161,162
161,163
162,163
165,166
166,167
166,168
167,168
169,170
171,172
172,173
173,174
173,175
174,175
176,177
176,178
177,178
179,180
180,181
180,182
181,182
181,183
182,183
182,184
183,184
187,188
187,189
188,189
188,190
189,190
193,194
194,195
194,196
195,196
197,198
197,199
198,199
201,202
201,203
202,203
204,205
204,206
204,207
204,208
204,209
205,206
206,207
206,208
207,208
209,210
210,211
210,212
213,214
214,215
214,216
215,216
215,217
216,217
219,220
221,222
221,223
222,223
224,225
225,226
226,227
226,228
227,228
230,231
231,232
231,233
232,233
234,235
235,236
237,238
238,239
238,240
239,240
241,242
243,244
243,245
244,245
246,247
247,248
247,249
248,249
250,251
-----nextToken-----
2,4,7,9,10,15,17,18,22,24,25,28,30,32,36,38,39,43,45,46,48,49,53,56,60,62,66,69,70,71,75,78,80,84,87,89,93,97,98,104,107,109,111,115,119,120,123,127,130,131,135,139,140,144,146,148,151,153,159,163,164,168,170,175,178,184,185,186,190,191,192,196,199,200,203,208,211,212,217,218,220,223,228,229,233,236,240,242,245,249,251
-----computeFrom-----
73,74
73,75
82,83
82,84
100,101
100,102
102,103
102,104
173,174
173,175
176,177
176,178
180,181
180,182
194,195
194,196
214,215
214,216
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;WhileStatement;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;ProblemStatement;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ProblemStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
static void mqueue_evict_inode(struct inode *inode){	struct mqueue_inode_info *info;	struct user_struct *user;	unsigned long mq_bytes, mq_treesize;	struct ipc_namespace *ipc_ns;	struct msg_msg *msg, *nmsg;	LIST_HEAD(tmp_msg);	clear_inode(inode);	if (S_ISDIR(inode->i_mode))		return;	ipc_ns = get_ns_from_inode(inode);	info = MQUEUE_I(inode);	spin_lock(&info->lock);	while ((msg = msg_get(info)) != NULL)		list_add_tail(&msg->m_list, &tmp_msg);	kfree(info->node_cache);	spin_unlock(&info->lock);	list_for_each_entry_safe(msg, nmsg, &tmp_msg, m_list) {		list_del(&msg->m_list);		free_msg(msg);	}	/* Total amount of bytes accounted for the mqueue */	mq_treesize = info->attr.mq_maxmsg * sizeof(struct msg_msg) +		min_t(unsigned int, info->attr.mq_maxmsg, MQ_PRIO_MAX) *		sizeof(struct posix_msg_tree_node);	mq_bytes = mq_treesize + (info->attr.mq_maxmsg *				  info->attr.mq_msgsize);	user = info->user;	if (user) {		spin_lock(&mq_lock);		user->mq_bytes -= mq_bytes;		/*		 * get_ns_from_inode() ensures that the		 * (ipc_ns = sb->s_fs_info) is either a valid ipc_ns		 * to which we now hold a reference, or it is NULL.		 * We can't put it here under mq_lock, though.		 */		if (ipc_ns)			ipc_ns->mq_queues_count--;		spin_unlock(&mq_lock);		free_uid(user);	}	if (ipc_ns)		put_ipc_ns(ipc_ns);}
static void
mqueue_evict_inode(struct inode *inode)
mqueue_evict_inode
struct inode *inode
struct inode
inode
*inode
*
inode
{	struct mqueue_inode_info *info;	struct user_struct *user;	unsigned long mq_bytes, mq_treesize;	struct ipc_namespace *ipc_ns;	struct msg_msg *msg, *nmsg;	LIST_HEAD(tmp_msg);	clear_inode(inode);	if (S_ISDIR(inode->i_mode))		return;	ipc_ns = get_ns_from_inode(inode);	info = MQUEUE_I(inode);	spin_lock(&info->lock);	while ((msg = msg_get(info)) != NULL)		list_add_tail(&msg->m_list, &tmp_msg);	kfree(info->node_cache);	spin_unlock(&info->lock);	list_for_each_entry_safe(msg, nmsg, &tmp_msg, m_list) {		list_del(&msg->m_list);		free_msg(msg);	}	/* Total amount of bytes accounted for the mqueue */	mq_treesize = info->attr.mq_maxmsg * sizeof(struct msg_msg) +		min_t(unsigned int, info->attr.mq_maxmsg, MQ_PRIO_MAX) *		sizeof(struct posix_msg_tree_node);	mq_bytes = mq_treesize + (info->attr.mq_maxmsg *				  info->attr.mq_msgsize);	user = info->user;	if (user) {		spin_lock(&mq_lock);		user->mq_bytes -= mq_bytes;		/*		 * get_ns_from_inode() ensures that the		 * (ipc_ns = sb->s_fs_info) is either a valid ipc_ns		 * to which we now hold a reference, or it is NULL.		 * We can't put it here under mq_lock, though.		 */		if (ipc_ns)			ipc_ns->mq_queues_count--;		spin_unlock(&mq_lock);		free_uid(user);	}	if (ipc_ns)		put_ipc_ns(ipc_ns);}
struct mqueue_inode_info *info;
struct mqueue_inode_info *info;
struct mqueue_inode_info
mqueue_inode_info
*info
*
info
struct user_struct *user;
struct user_struct *user;
struct user_struct
user_struct
*user
*
user
unsigned long mq_bytes, mq_treesize;
unsigned long mq_bytes, mq_treesize;
unsigned long
mq_bytes
mq_bytes
mq_treesize
mq_treesize
struct ipc_namespace *ipc_ns;
struct ipc_namespace *ipc_ns;
struct ipc_namespace
ipc_namespace
*ipc_ns
*
ipc_ns
struct msg_msg *msg, *nmsg;
struct msg_msg *msg, *nmsg;
struct msg_msg
msg_msg
*msg
*
msg
*nmsg
*
nmsg
LIST_HEAD(tmp_msg);
LIST_HEAD(tmp_msg);
LIST_HEAD
LIST_HEAD
(tmp_msg)
tmp_msg
tmp_msg
clear_inode(inode);
clear_inode(inode)
clear_inode
clear_inode
inode
inode
if (S_ISDIR(inode->i_mode))		return;
S_ISDIR(inode->i_mode)
S_ISDIR
S_ISDIR
inode->i_mode
inode
inode
i_mode
return;
ipc_ns = get_ns_from_inode(inode);
ipc_ns = get_ns_from_inode(inode)
ipc_ns
ipc_ns
get_ns_from_inode(inode)
get_ns_from_inode
get_ns_from_inode
inode
inode
info = MQUEUE_I(inode);
info = MQUEUE_I(inode)
info
info
MQUEUE_I(inode)
MQUEUE_I
MQUEUE_I
inode
inode
spin_lock(&info->lock);
spin_lock(&info->lock)
spin_lock
spin_lock
&info->lock
info->lock
info
info
lock
while ((msg = msg_get(info)) != NULL)		list_add_tail(&msg->m_list, &tmp_msg);
(msg = msg_get(info)) != NULL
(msg = msg_get(info))
msg = msg_get(info)
msg
msg
msg_get(info)
msg_get
msg_get
info
info
NULL
NULL
list_add_tail(&msg->m_list, &tmp_msg);
list_add_tail(&msg->m_list, &tmp_msg)
list_add_tail
list_add_tail
&msg->m_list
msg->m_list
msg
msg
m_list
&tmp_msg
tmp_msg
tmp_msg
kfree(info->node_cache);
kfree(info->node_cache)
kfree
kfree
info->node_cache
info
info
node_cache
spin_unlock(&info->lock);
spin_unlock(&info->lock)
spin_unlock
spin_unlock
&info->lock
info->lock
info
info
lock
list_for_each_entry_safe(msg, nmsg, &tmp_msg, m_list)
list_for_each_entry_safe(msg, nmsg, &tmp_msg, m_list)
list_for_each_entry_safe
list_for_each_entry_safe
msg
msg
nmsg
nmsg
&tmp_msg
tmp_msg
tmp_msg
m_list
m_list
)
{		list_del(&msg->m_list);		free_msg(msg);	}
list_del(&msg->m_list);
list_del(&msg->m_list)
list_del
list_del
&msg->m_list
msg->m_list
msg
msg
m_list
free_msg(msg);
free_msg(msg)
free_msg
free_msg
msg
msg
mq_treesize = info->attr.mq_maxmsg * sizeof(struct msg_msg) +		min_t(unsigned int, info->attr.mq_maxmsg, MQ_PRIO_MAX) *		sizeof(struct posix_msg_tree_node);
mq_bytes = mq_treesize + (info->attr.mq_maxmsg *				  info->attr.mq_msgsize);
mq_bytes = mq_treesize + (info->attr.mq_maxmsg *				  info->attr.mq_msgsize)
mq_bytes
mq_bytes
mq_treesize + (info->attr.mq_maxmsg *				  info->attr.mq_msgsize)
mq_treesize
mq_treesize
(info->attr.mq_maxmsg *				  info->attr.mq_msgsize)
info->attr.mq_maxmsg *				  info->attr.mq_msgsize
info->attr.mq_maxmsg
info->attr
info
info
attr
mq_maxmsg
info->attr.mq_msgsize
info->attr
info
info
attr
mq_msgsize
user = info->user;
user = info->user
user
user
info->user
info
info
user
if (user) {		spin_lock(&mq_lock);		user->mq_bytes -= mq_bytes;		/*		 * get_ns_from_inode() ensures that the		 * (ipc_ns = sb->s_fs_info) is either a valid ipc_ns		 * to which we now hold a reference, or it is NULL.		 * We can't put it here under mq_lock, though.		 */		if (ipc_ns)			ipc_ns->mq_queues_count--;		spin_unlock(&mq_lock);		free_uid(user);	}
user
user
{		spin_lock(&mq_lock);		user->mq_bytes -= mq_bytes;		/*		 * get_ns_from_inode() ensures that the		 * (ipc_ns = sb->s_fs_info) is either a valid ipc_ns		 * to which we now hold a reference, or it is NULL.		 * We can't put it here under mq_lock, though.		 */		if (ipc_ns)			ipc_ns->mq_queues_count--;		spin_unlock(&mq_lock);		free_uid(user);	}
spin_lock(&mq_lock);
spin_lock(&mq_lock);
spin_lock
spin_lock
(&mq_lock)
&mq_lock
&
mq_lock
user->mq_bytes -= mq_bytes;
user->mq_bytes -= mq_bytes
user->mq_bytes
user
user
mq_bytes
mq_bytes
mq_bytes
if (ipc_ns)			ipc_ns->mq_queues_count--;
ipc_ns
ipc_ns
ipc_ns->mq_queues_count--;
ipc_ns->mq_queues_count--
ipc_ns->mq_queues_count
ipc_ns
ipc_ns
mq_queues_count
spin_unlock(&mq_lock);
spin_unlock(&mq_lock)
spin_unlock
spin_unlock
&mq_lock
mq_lock
mq_lock
free_uid(user);
free_uid(user)
free_uid
free_uid
user
user
if (ipc_ns)		put_ipc_ns(ipc_ns);
ipc_ns
ipc_ns
put_ipc_ns(ipc_ns);
put_ipc_ns(ipc_ns)
put_ipc_ns
put_ipc_ns
ipc_ns
ipc_ns
-----joern-----
(67,59,0)
(108,89,0)
(64,8,0)
(13,66,0)
(96,59,0)
(22,58,0)
(83,102,0)
(11,12,0)
(8,66,0)
(23,69,0)
(26,24,0)
(103,32,0)
(46,1,0)
(21,32,0)
(5,99,0)
(29,59,0)
(27,94,0)
(73,59,0)
(40,55,0)
(52,42,0)
(8,98,0)
(36,61,0)
(110,33,0)
(10,24,0)
(47,50,0)
(78,59,0)
(75,59,0)
(105,98,0)
(3,59,0)
(80,77,0)
(61,98,0)
(77,80,0)
(7,37,0)
(22,95,0)
(24,75,0)
(86,52,0)
(75,44,0)
(18,99,0)
(69,22,0)
(107,59,0)
(4,110,0)
(37,17,0)
(89,108,0)
(50,47,0)
(72,61,0)
(33,17,0)
(94,65,0)
(85,56,0)
(38,60,0)
(78,95,0)
(76,27,0)
(31,55,0)
(52,60,0)
(16,89,0)
(90,0,0)
(95,78,0)
(23,60,0)
(45,43,0)
(65,94,0)
(81,59,0)
(84,23,0)
(58,22,0)
(34,12,0)
(14,110,0)
(32,103,0)
(35,59,0)
(93,44,0)
(71,24,0)
(58,99,0)
(63,78,0)
(2,60,0)
(0,47,0)
(44,75,0)
(12,98,0)
(22,69,0)
(43,60,0)
(12,63,0)
(57,103,0)
(87,59,0)
(62,0,0)
(99,60,0)
(68,59,0)
(17,37,0)
(106,58,0)
(53,111,0)
(97,89,0)
(0,60,0)
(63,66,0)
(3,42,0)
(91,3,0)
(98,61,0)
(41,75,0)
(44,42,0)
(94,27,0)
(103,43,0)
(24,71,0)
(100,63,0)
(50,59,0)
(13,109,0)
(92,2,0)
(95,22,0)
(46,6,0)
(48,59,0)
(49,27,0)
(6,59,0)
(17,33,0)
(2,67,0)
(102,103,0)
(9,77,0)
(47,0,0)
(65,59,0)
(54,59,0)
(60,59,0)
(28,79,0)
(111,75,0)
(55,56,0)
(60,52,0)
(51,59,0)
(82,69,0)
(56,55,0)
(27,60,0)
(110,103,0)
(112,66,0)
(101,95,0)
(55,103,0)
(33,110,0)
(61,60,0)
(88,78,0)
(85,48,0)
(104,23,0)
(99,58,0)
(1,46,0)
(25,73,0)
(6,46,0)
(20,59,0)
(67,2,0)
(39,109,0)
(70,2,0)
(80,66,0)
(102,48,0)
(89,42,0)
(19,59,0)
(56,85,0)
(69,23,0)
(109,13,0)
(43,103,0)
(98,59,0)
(93,41,1)
(15,74,1)
(73,25,1)
(8,98,1)
(32,103,1)
(15,8,1)
(12,98,1)
(34,11,1)
(99,18,1)
(62,90,1)
(74,98,1)
(103,43,1)
(23,104,1)
(43,60,1)
(100,12,1)
(101,88,1)
(41,108,1)
(4,32,1)
(17,33,1)
(69,82,1)
(71,24,1)
(39,74,1)
(90,60,1)
(92,32,1)
(110,103,1)
(46,102,1)
(56,55,1)
(0,60,1)
(31,40,1)
(58,99,1)
(57,50,1)
(30,63,1)
(17,37,1)
(9,30,1)
(65,94,1)
(27,49,1)
(23,60,1)
(32,21,1)
(75,44,1)
(7,33,1)
(110,14,1)
(95,22,1)
(3,91,1)
(37,7,1)
(55,103,1)
(67,2,1)
(58,106,1)
(33,110,1)
(40,65,1)
(102,83,1)
(89,42,1)
(104,84,1)
(91,73,1)
(80,77,1)
(46,1,1)
(0,62,1)
(5,69,1)
(77,9,1)
(2,70,1)
(52,42,1)
(99,60,1)
(3,42,1)
(28,111,1)
(14,4,1)
(102,103,1)
(16,3,1)
(28,15,1)
(86,38,1)
(27,60,1)
(6,46,1)
(111,53,1)
(36,105,1)
(105,78,1)
(61,60,1)
(38,75,1)
(13,109,1)
(50,47,1)
(26,10,1)
(2,60,1)
(89,97,1)
(57,17,1)
(12,34,1)
(60,52,1)
(9,71,1)
(10,30,1)
(24,75,1)
(83,85,1)
(69,23,1)
(84,101,1)
(111,75,1)
(11,13,1)
(70,92,1)
(52,86,1)
(49,76,1)
(44,42,1)
(64,80,1)
(98,61,1)
(108,89,1)
(63,78,1)
(76,67,1)
(78,95,1)
(18,5,1)
(97,16,1)
(8,64,1)
(44,93,1)
(82,23,1)
(43,45,1)
(88,6,1)
(53,15,1)
(79,108,1)
(28,79,1)
(45,57,1)
(106,99,1)
(94,27,1)
(109,39,1)
(22,58,1)
(55,31,1)
(72,36,1)
(61,72,1)
(22,69,1)
(63,100,1)
(85,56,1)
(24,26,1)
(47,0,1)
(21,103,1)
(55,108,2)
(13,109,2)
(60,52,2)
(12,98,2)
(76,108,2)
(7,32,2)
(22,58,2)
(43,32,2)
(24,30,2)
(24,75,2)
(84,108,2)
(44,42,2)
(0,60,2)
(0,108,2)
(27,108,2)
(85,56,2)
(32,103,2)
(60,108,2)
(31,108,2)
(49,108,2)
(56,108,2)
(65,108,2)
(99,108,2)
(45,108,2)
(21,32,2)
(37,32,2)
(75,44,2)
(52,108,2)
(61,60,2)
(28,79,2)
(47,108,2)
(63,78,2)
(110,103,2)
(69,23,2)
(30,74,2)
(33,32,2)
(94,27,2)
(39,74,2)
(67,2,2)
(2,60,2)
(10,30,2)
(98,61,2)
(4,32,2)
(108,89,2)
(56,55,2)
(74,108,2)
(111,15,2)
(98,108,2)
(12,74,2)
(79,108,2)
(83,108,2)
(18,108,2)
(80,74,2)
(50,47,2)
(17,32,2)
(32,32,2)
(58,99,2)
(44,108,2)
(45,32,2)
(52,42,2)
(50,108,2)
(17,37,2)
(69,108,2)
(103,43,2)
(105,108,2)
(3,42,2)
(89,42,2)
(104,108,2)
(53,15,2)
(23,108,2)
(32,108,2)
(62,108,2)
(27,60,2)
(95,22,2)
(46,1,2)
(72,108,2)
(38,108,2)
(21,108,2)
(15,108,2)
(34,74,2)
(23,60,2)
(100,74,2)
(57,32,2)
(78,108,2)
(86,108,2)
(11,74,2)
(64,74,2)
(22,108,2)
(102,108,2)
(57,108,2)
(90,108,2)
(75,108,2)
(103,108,2)
(82,108,2)
(103,32,2)
(95,108,2)
(6,46,2)
(109,74,2)
(63,74,2)
(43,108,2)
(58,108,2)
(61,108,2)
(8,74,2)
(88,108,2)
(26,30,2)
(110,32,2)
(102,103,2)
(36,108,2)
(85,108,2)
(78,95,2)
(71,30,2)
(67,108,2)
(2,108,2)
(33,110,2)
(70,108,2)
(6,108,2)
(9,74,2)
(17,33,2)
(111,75,2)
(92,108,2)
(8,98,2)
(13,74,2)
(14,32,2)
(77,74,2)
(41,108,2)
(93,108,2)
(22,69,2)
(40,108,2)
(101,108,2)
(106,108,2)
(46,108,2)
(55,103,2)
(80,77,2)
(99,60,2)
(94,108,2)
(43,60,2)
(65,94,2)
(47,0,2)
(71,24,2)
(5,108,2)
-----------------------------------
(0,info->lock)
(1,struct posix_msg_tree_node)
(2,info->node_cache)
(3,clear_inode(inode)
(4,msg)
(5,info)
(6,*\n\\n\\t\\tsizeof(struct posix_msg_tree_node)
(7,tmp_msg)
(8,free_uid(user)
(9,mq_lock)
(10,ipc_ns)
(11,user)
(12,user->mq_bytes)
(13,spin_lock(&mq_lock)
(14,m_list)
(15,ipc_ns)
(16,inode)
(17,list_add_tail(&msg->m_list, &tmp_msg)
(18,attr)
(19,if (S_ISDIR(inode->i_mode)
(20,while ((msg = msg_get(info)
(21,NULL)
(22,info->attr.mq_maxmsg *\n\\n\\t\\t\\t\\t  info->attr.mq_msgsize)
(23,info->attr)
(24,ipc_ns->mq_queues_count)
(25,tmp_msg)
(26,mq_queues_count)
(27,info->lock)
(28,RET)
(29,ipc_ns)
(30,ipc_ns)
(31,m_list)
(32,(msg = msg_get(info)
(33,&msg->m_list)
(34,mq_bytes)
(35,mq_bytes)
(36,info)
(37,&tmp_msg)
(38,info)
(39,mq_lock)
(40,msg)
(41,ipc_ns)
(42,struct inode *inode)
(43,msg_get(info)
(44,get_ns_from_inode(inode)
(45,info)
(46,sizeof(struct posix_msg_tree_node)
(47,&info->lock)
(48,)
(49,lock)
(50,spin_lock(&info->lock)
(51,info)
(52,MQUEUE_I(inode)
(53,ipc_ns)
(54,msg)
(55,msg->m_list)
(56,&msg->m_list)
(57,msg)
(58,info->attr.mq_msgsize)
(59,)
(60,info = MQUEUE_I(inode)
(61,info->user)
(62,lock)
(63,user->mq_bytes -= mq_bytes)
(64,user)
(65,spin_unlock(&info->lock)
(66,)
(67,kfree(info->node_cache)
(68,user)
(69,info->attr.mq_maxmsg)
(70,node_cache)
(71,ipc_ns->mq_queues_count--)
(72,user)
(73,LIST_HEAD(tmp_msg)
(74,user)
(75,ipc_ns = get_ns_from_inode(inode)
(76,info)
(77,&mq_lock)
(78,mq_bytes = mq_treesize + (info->attr.mq_maxmsg *\n\\n\\t\\t\\t\\t  info->attr.mq_msgsize)
(79,return;)
(80,spin_unlock(&mq_lock)
(81,if (user)
(82,mq_maxmsg)
(83,msg)
(84,info)
(85,list_del(&msg->m_list)
(86,inode)
(87,if (ipc_ns)
(88,mq_bytes)
(89,inode->i_mode)
(90,info)
(91,inode)
(92,info)
(93,inode)
(94,&info->lock)
(95,mq_treesize + (info->attr.mq_maxmsg *\n\\n\\t\\t\\t\\t  info->attr.mq_msgsize)
(96,mq_treesize)
(97,i_mode)
(98,user = info->user)
(99,info->attr)
(100,mq_bytes)
(101,mq_treesize)
(102,free_msg(msg)
(103,msg = msg_get(info)
(104,attr)
(105,user)
(106,mq_msgsize)
(107,nmsg)
(108,S_ISDIR(inode->i_mode)
(109,&mq_lock)
(110,msg->m_list)
(111,put_ipc_ns(ipc_ns)
(112,if (ipc_ns)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^