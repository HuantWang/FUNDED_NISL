-----label-----
1
-----code-----
unsigned long
arch_get_unmapped_area(struct file *filp, unsigned long addr,
		unsigned long len, unsigned long pgoff, unsigned long flags)
{
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma;
	int do_align = 0;
	int aliasing = cache_is_vipt_aliasing();
	struct vm_unmapped_area_info info;

	/*
	 * We only need to do colour alignment if D cache aliases.
	 */
	if (aliasing)
		do_align = filp || (flags & MAP_SHARED);

	/*
	 * We enforce the MAP_FIXED case.
	 */
	if (flags & MAP_FIXED) {
		if (aliasing && flags & MAP_SHARED &&
		    (addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1))
			return -EINVAL;
		return addr;
	}

	if (len > TASK_SIZE)
		return -ENOMEM;

	if (addr) {
		if (do_align)
			addr = COLOUR_ALIGN(addr, pgoff);
		else
			addr = PAGE_ALIGN(addr);

		vma = find_vma(mm, addr);
		if (TASK_SIZE - len >= addr &&
		    (!vma || addr + len <= vma->vm_start))
			return addr;
	}

	info.flags = 0;
	info.length = len;
	info.low_limit = mm->mmap_base;
	info.high_limit = TASK_SIZE;
	info.align_mask = do_align ? (PAGE_MASK & (SHMLBA - 1)) : 0;
	info.align_offset = pgoff << PAGE_SHIFT;
	return vm_unmapped_area(&info);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
3,9
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
15,16
15,17
17,18
19,20
19,21
21,22
23,24
23,25
25,26
27,28
27,29
27,30
27,31
27,32
27,33
27,34
27,35
27,36
27,37
27,38
27,39
27,40
27,41
27,42
27,43
28,29
29,30
29,31
30,31
32,33
32,34
32,35
35,36
36,37
36,38
37,38
40,41
41,42
41,43
42,43
44,45
44,46
47,48
48,49
48,50
50,51
50,52
52,53
54,55
55,56
55,57
57,58
57,59
59,60
60,61
61,62
63,64
64,65
64,66
65,66
67,68
69,70
69,71
70,71
72,73
73,74
73,75
74,75
76,77
76,78
77,78
79,80
80,81
80,82
81,82
83,84
85,86
85,87
86,87
86,88
87,88
89,90
91,92
91,93
92,93
92,94
93,94
93,95
94,95
94,96
95,96
97,98
97,99
98,99
100,101
102,103
102,104
103,104
104,105
104,106
105,106
107,108
108,109
108,110
109,110
111,112
113,114
114,115
114,116
115,116
118,119
119,120
120,121
122,123
123,124
125,126
125,127
126,127
126,128
127,128
129,130
131,132
132,133
133,134
135,136
135,137
136,137
138,139
138,140
138,141
139,140
139,141
139,142
140,141
142,143
143,144
143,145
144,145
146,147
146,148
146,149
147,148
149,150
151,152
153,154
154,155
154,156
155,156
157,158
157,159
158,159
160,161
162,163
163,164
163,165
164,165
166,167
166,168
166,169
167,168
169,170
171,172
173,174
173,175
174,175
174,176
175,176
175,177
176,177
176,178
177,178
179,180
181,182
183,184
184,185
184,186
185,186
186,187
188,189
188,190
189,190
189,191
190,191
192,193
194,195
194,196
195,196
198,199
199,200
201,202
202,203
202,204
203,204
203,205
204,205
208,209
209,210
209,211
210,211
210,212
211,212
214,215
216,217
217,218
217,219
218,219
218,220
219,220
222,223
222,224
223,224
226,227
227,228
227,229
228,229
228,230
229,230
232,233
234,235
235,236
235,237
236,237
236,238
237,238
240,241
240,242
240,243
241,242
243,244
244,245
244,246
245,246
247,248
248,249
248,250
249,250
253,254
254,255
254,256
255,256
255,257
256,257
259,260
259,261
260,261
262,263
264,265
265,266
265,267
266,267
268,269
269,270
-----nextToken-----
2,4,7,9,10,12,14,16,18,20,22,24,26,31,33,34,38,39,43,45,46,49,51,53,56,58,62,66,68,71,75,78,82,84,88,90,96,99,101,106,110,112,116,117,121,124,128,130,134,137,141,145,148,150,152,156,159,161,165,168,170,172,178,180,182,187,191,193,196,197,200,205,206,207,212,213,215,220,221,224,225,230,231,233,238,239,242,246,250,251,252,257,258,261,263,267,270
-----computeFrom-----
73,74
73,75
76,77
76,78
80,81
80,82
86,87
86,88
93,94
93,95
94,95
94,96
97,98
97,99
102,103
102,104
104,105
104,106
108,109
108,110
114,115
114,116
126,127
126,128
143,144
143,145
154,155
154,156
163,164
163,165
174,175
174,176
175,176
175,177
176,177
176,178
184,185
184,186
188,189
188,190
189,190
189,191
202,203
202,204
209,210
209,211
217,218
217,219
227,228
227,229
235,236
235,237
244,245
244,246
248,249
248,250
254,255
254,256
259,260
259,261
-----guardedBy-----
88,99
191,200
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;IfStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;IdExpression;Name;ReturnStatement;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;BinaryExpression;UnaryExpression;IdExpression;Name;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;ConditionalExpression;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;
-----ast_node-----
unsigned longarch_get_unmapped_area(struct file *filp, unsigned long addr,		unsigned long len, unsigned long pgoff, unsigned long flags){	struct mm_struct *mm = current->mm;	struct vm_area_struct *vma;	int do_align = 0;	int aliasing = cache_is_vipt_aliasing();	struct vm_unmapped_area_info info;	/*	 * We only need to do colour alignment if D cache aliases.	 */	if (aliasing)		do_align = filp || (flags & MAP_SHARED);	/*	 * We enforce the MAP_FIXED case.	 */	if (flags & MAP_FIXED) {		if (aliasing && flags & MAP_SHARED &&		    (addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1))			return -EINVAL;		return addr;	}	if (len > TASK_SIZE)		return -ENOMEM;	if (addr) {		if (do_align)			addr = COLOUR_ALIGN(addr, pgoff);		else			addr = PAGE_ALIGN(addr);		vma = find_vma(mm, addr);		if (TASK_SIZE - len >= addr &&		    (!vma || addr + len <= vma->vm_start))			return addr;	}	info.flags = 0;	info.length = len;	info.low_limit = mm->mmap_base;	info.high_limit = TASK_SIZE;	info.align_mask = do_align ? (PAGE_MASK & (SHMLBA - 1)) : 0;	info.align_offset = pgoff << PAGE_SHIFT;	return vm_unmapped_area(&info);}
unsigned long
arch_get_unmapped_area(struct file *filp, unsigned long addr,		unsigned long len, unsigned long pgoff, unsigned long flags)
arch_get_unmapped_area
struct file *filp
struct file
file
*filp
*
filp
unsigned long addr
unsigned long
addr
addr
unsigned long len
unsigned long
len
len
unsigned long pgoff
unsigned long
pgoff
pgoff
unsigned long flags
unsigned long
flags
flags
{	struct mm_struct *mm = current->mm;	struct vm_area_struct *vma;	int do_align = 0;	int aliasing = cache_is_vipt_aliasing();	struct vm_unmapped_area_info info;	/*	 * We only need to do colour alignment if D cache aliases.	 */	if (aliasing)		do_align = filp || (flags & MAP_SHARED);	/*	 * We enforce the MAP_FIXED case.	 */	if (flags & MAP_FIXED) {		if (aliasing && flags & MAP_SHARED &&		    (addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1))			return -EINVAL;		return addr;	}	if (len > TASK_SIZE)		return -ENOMEM;	if (addr) {		if (do_align)			addr = COLOUR_ALIGN(addr, pgoff);		else			addr = PAGE_ALIGN(addr);		vma = find_vma(mm, addr);		if (TASK_SIZE - len >= addr &&		    (!vma || addr + len <= vma->vm_start))			return addr;	}	info.flags = 0;	info.length = len;	info.low_limit = mm->mmap_base;	info.high_limit = TASK_SIZE;	info.align_mask = do_align ? (PAGE_MASK & (SHMLBA - 1)) : 0;	info.align_offset = pgoff << PAGE_SHIFT;	return vm_unmapped_area(&info);}
struct mm_struct *mm = current->mm;
struct mm_struct *mm = current->mm;
struct mm_struct
mm_struct
*mm = current->mm
*
mm
= current->mm
current->mm
current
current
mm
struct vm_area_struct *vma;
struct vm_area_struct *vma;
struct vm_area_struct
vm_area_struct
*vma
*
vma
int do_align = 0;
int do_align = 0;
int
do_align = 0
do_align
= 0
0
int aliasing = cache_is_vipt_aliasing();
int aliasing = cache_is_vipt_aliasing();
int
aliasing = cache_is_vipt_aliasing()
aliasing
= cache_is_vipt_aliasing()
cache_is_vipt_aliasing()
cache_is_vipt_aliasing
cache_is_vipt_aliasing
struct vm_unmapped_area_info info;
struct vm_unmapped_area_info info;
struct vm_unmapped_area_info
vm_unmapped_area_info
info
info
if (aliasing)		do_align = filp || (flags & MAP_SHARED);
aliasing
aliasing
do_align = filp || (flags & MAP_SHARED);
do_align = filp || (flags & MAP_SHARED)
do_align
do_align
filp || (flags & MAP_SHARED)
filp
filp
(flags & MAP_SHARED)
flags & MAP_SHARED
flags
flags
MAP_SHARED
MAP_SHARED
if (flags & MAP_FIXED) {		if (aliasing && flags & MAP_SHARED &&		    (addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1))			return -EINVAL;		return addr;	}
flags & MAP_FIXED
flags
flags
MAP_FIXED
MAP_FIXED
{		if (aliasing && flags & MAP_SHARED &&		    (addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1))			return -EINVAL;		return addr;	}
if (aliasing && flags & MAP_SHARED &&		    (addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1))			return -EINVAL;
aliasing && flags & MAP_SHARED &&		    (addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1)
aliasing && flags & MAP_SHARED
aliasing
aliasing
flags & MAP_SHARED
flags
flags
MAP_SHARED
MAP_SHARED
(addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1)
(addr - (pgoff << PAGE_SHIFT))
addr - (pgoff << PAGE_SHIFT)
addr
addr
(pgoff << PAGE_SHIFT)
pgoff << PAGE_SHIFT
pgoff
pgoff
PAGE_SHIFT
PAGE_SHIFT
(SHMLBA - 1)
SHMLBA - 1
SHMLBA
SHMLBA
1
return -EINVAL;
-EINVAL
EINVAL
EINVAL
return addr;
addr
addr
if (len > TASK_SIZE)		return -ENOMEM;
len > TASK_SIZE
len
len
TASK_SIZE
TASK_SIZE
return -ENOMEM;
-ENOMEM
ENOMEM
ENOMEM
if (addr) {		if (do_align)			addr = COLOUR_ALIGN(addr, pgoff);		else			addr = PAGE_ALIGN(addr);		vma = find_vma(mm, addr);		if (TASK_SIZE - len >= addr &&		    (!vma || addr + len <= vma->vm_start))			return addr;	}
addr
addr
{		if (do_align)			addr = COLOUR_ALIGN(addr, pgoff);		else			addr = PAGE_ALIGN(addr);		vma = find_vma(mm, addr);		if (TASK_SIZE - len >= addr &&		    (!vma || addr + len <= vma->vm_start))			return addr;	}
if (do_align)			addr = COLOUR_ALIGN(addr, pgoff);		else			addr = PAGE_ALIGN(addr);
do_align
do_align
addr = COLOUR_ALIGN(addr, pgoff);
addr = COLOUR_ALIGN(addr, pgoff)
addr
addr
COLOUR_ALIGN(addr, pgoff)
COLOUR_ALIGN
COLOUR_ALIGN
addr
addr
pgoff
pgoff
addr = PAGE_ALIGN(addr);
addr = PAGE_ALIGN(addr)
addr
addr
PAGE_ALIGN(addr)
PAGE_ALIGN
PAGE_ALIGN
addr
addr
vma = find_vma(mm, addr);
vma = find_vma(mm, addr)
vma
vma
find_vma(mm, addr)
find_vma
find_vma
mm
mm
addr
addr
if (TASK_SIZE - len >= addr &&		    (!vma || addr + len <= vma->vm_start))			return addr;
TASK_SIZE - len >= addr &&		    (!vma || addr + len <= vma->vm_start)
TASK_SIZE - len >= addr
TASK_SIZE - len
TASK_SIZE
TASK_SIZE
len
len
addr
addr
(!vma || addr + len <= vma->vm_start)
!vma || addr + len <= vma->vm_start
!vma
vma
vma
addr + len <= vma->vm_start
addr + len
addr
addr
len
len
vma->vm_start
vma
vma
vm_start
return addr;
addr
addr
info.flags = 0;
info.flags = 0
info.flags
info
info
flags
0
info.length = len;
info.length = len
info.length
info
info
length
len
len
info.low_limit = mm->mmap_base;
info.low_limit = mm->mmap_base
info.low_limit
info
info
low_limit
mm->mmap_base
mm
mm
mmap_base
info.high_limit = TASK_SIZE;
info.high_limit = TASK_SIZE
info.high_limit
info
info
high_limit
TASK_SIZE
TASK_SIZE
info.align_mask = do_align ? (PAGE_MASK & (SHMLBA - 1)) : 0;
info.align_mask = do_align ? (PAGE_MASK & (SHMLBA - 1)) : 0
info.align_mask
info
info
align_mask
do_align ? (PAGE_MASK & (SHMLBA - 1)) : 0
do_align
do_align
(PAGE_MASK & (SHMLBA - 1))
PAGE_MASK & (SHMLBA - 1)
PAGE_MASK
PAGE_MASK
(SHMLBA - 1)
SHMLBA - 1
SHMLBA
SHMLBA
1
0
info.align_offset = pgoff << PAGE_SHIFT;
info.align_offset = pgoff << PAGE_SHIFT
info.align_offset
info
info
align_offset
pgoff << PAGE_SHIFT
pgoff
pgoff
PAGE_SHIFT
PAGE_SHIFT
return vm_unmapped_area(&info);
vm_unmapped_area(&info)
vm_unmapped_area
vm_unmapped_area
&info
info
info
-----joern-----
(22,91,0)
(107,95,0)
(134,2,0)
(3,135,0)
(16,61,0)
(79,13,0)
(59,74,0)
(146,55,0)
(87,112,0)
(23,25,0)
(28,107,0)
(48,61,0)
(146,53,0)
(71,133,0)
(80,71,0)
(35,89,0)
(52,19,0)
(131,61,0)
(50,97,0)
(19,85,0)
(33,118,0)
(79,110,0)
(121,3,0)
(56,139,0)
(100,20,0)
(94,145,0)
(81,128,0)
(56,9,0)
(7,20,0)
(105,97,0)
(132,134,0)
(80,138,0)
(147,13,0)
(107,139,0)
(125,61,0)
(58,55,0)
(124,134,0)
(63,15,0)
(91,15,0)
(46,90,0)
(80,35,0)
(136,102,0)
(88,53,0)
(114,125,0)
(34,55,0)
(80,97,0)
(17,112,0)
(133,146,0)
(85,19,0)
(11,85,0)
(93,47,0)
(97,90,0)
(132,82,0)
(26,138,0)
(87,139,0)
(65,104,0)
(8,35,0)
(15,107,0)
(25,23,0)
(89,61,0)
(143,65,0)
(140,17,0)
(64,43,0)
(30,61,0)
(130,115,0)
(72,17,0)
(128,98,0)
(103,47,0)
(129,28,0)
(100,80,0)
(28,56,0)
(0,61,0)
(5,19,0)
(137,28,0)
(36,61,0)
(11,145,0)
(42,128,0)
(118,106,0)
(82,132,0)
(82,24,0)
(79,53,0)
(126,47,0)
(135,130,0)
(45,143,0)
(101,29,0)
(4,104,0)
(91,98,0)
(102,2,0)
(143,93,0)
(95,107,0)
(117,106,0)
(68,114,0)
(40,130,0)
(65,143,0)
(87,107,0)
(122,71,0)
(145,11,0)
(95,139,0)
(125,43,0)
(86,130,0)
(99,104,0)
(119,24,0)
(15,99,0)
(54,112,0)
(74,109,0)
(28,98,0)
(37,43,0)
(141,61,0)
(70,9,0)
(43,112,0)
(87,56,0)
(96,145,0)
(31,25,0)
(12,61,0)
(18,74,0)
(100,29,0)
(112,17,0)
(104,99,0)
(55,61,0)
(28,65,0)
(120,114,0)
(99,15,0)
(146,133,0)
(80,61,0)
(69,95,0)
(135,61,0)
(76,85,0)
(1,61,0)
(21,102,0)
(134,132,0)
(32,146,0)
(132,11,0)
(66,109,0)
(10,107,0)
(15,56,0)
(4,93,0)
(9,56,0)
(118,139,0)
(87,93,0)
(27,93,0)
(133,61,0)
(24,119,0)
(108,56,0)
(84,82,0)
(67,134,0)
(116,35,0)
(109,74,0)
(123,79,0)
(92,36,0)
(146,109,0)
(78,4,0)
(130,135,0)
(108,139,0)
(104,65,0)
(100,118,0)
(13,2,0)
(15,91,0)
(85,139,0)
(28,139,0)
(23,80,0)
(109,146,0)
(9,139,0)
(49,7,0)
(15,139,0)
(113,108,0)
(36,98,0)
(80,3,0)
(142,13,0)
(112,61,0)
(11,132,0)
(111,138,0)
(51,3,0)
(14,9,0)
(24,61,0)
(62,91,0)
(65,28,0)
(104,4,0)
(13,79,0)
(108,107,0)
(38,71,0)
(19,115,0)
(75,87,0)
(6,61,0)
(144,146,0)
(100,108,0)
(53,79,0)
(73,101,0)
(9,115,0)
(80,114,0)
(60,89,0)
(85,11,0)
(41,143,0)
(77,24,0)
(138,36,0)
(43,125,0)
(93,87,0)
(39,56,0)
(83,87,0)
(90,61,0)
(146,53,1)
(39,57,1)
(45,28,1)
(134,67,1)
(83,75,1)
(87,112,1)
(72,140,1)
(58,112,1)
(107,95,1)
(132,11,1)
(138,111,1)
(28,107,1)
(17,72,1)
(118,139,1)
(65,143,1)
(79,110,1)
(64,114,1)
(81,42,1)
(95,139,1)
(14,70,1)
(119,77,1)
(100,118,1)
(40,86,1)
(100,108,1)
(75,27,1)
(42,102,1)
(85,19,1)
(70,39,1)
(52,76,1)
(116,127,1)
(102,2,1)
(4,93,1)
(65,28,1)
(15,139,1)
(146,144,1)
(28,137,1)
(88,44,1)
(57,127,1)
(49,128,1)
(137,129,1)
(109,74,1)
(80,114,1)
(15,107,1)
(144,32,1)
(143,93,1)
(82,132,1)
(96,94,1)
(112,17,1)
(95,69,1)
(76,134,1)
(32,71,1)
(28,98,1)
(127,128,1)
(140,54,1)
(79,13,1)
(101,73,1)
(28,56,1)
(108,107,1)
(94,85,1)
(78,15,1)
(87,107,1)
(104,65,1)
(31,135,1)
(46,97,1)
(128,98,1)
(24,119,1)
(74,18,1)
(18,59,1)
(22,93,1)
(77,55,1)
(99,104,1)
(11,85,1)
(51,133,1)
(33,82,1)
(69,10,1)
(108,139,1)
(80,35,1)
(93,87,1)
(145,96,1)
(73,82,1)
(121,51,1)
(84,102,1)
(100,20,1)
(80,3,1)
(56,139,1)
(36,92,1)
(23,25,1)
(19,115,1)
(34,58,1)
(134,2,1)
(43,112,1)
(20,7,1)
(129,4,1)
(80,138,1)
(13,2,1)
(25,31,1)
(28,139,1)
(97,105,1)
(15,56,1)
(68,36,1)
(80,97,1)
(27,107,1)
(123,88,1)
(143,41,1)
(21,53,1)
(4,78,1)
(55,34,1)
(9,115,1)
(80,71,1)
(59,66,1)
(104,4,1)
(146,109,1)
(5,52,1)
(50,125,1)
(41,45,1)
(29,101,1)
(113,99,1)
(44,24,1)
(79,123,1)
(100,80,1)
(108,56,1)
(56,9,1)
(105,50,1)
(102,136,1)
(36,98,1)
(11,145,1)
(91,62,1)
(90,46,1)
(108,113,1)
(35,8,1)
(15,63,1)
(9,14,1)
(3,121,1)
(133,146,1)
(9,139,1)
(118,33,1)
(116,99,1)
(82,24,1)
(62,22,1)
(7,49,1)
(120,68,1)
(114,120,1)
(60,35,1)
(87,83,1)
(87,56,1)
(142,147,1)
(146,55,1)
(147,123,1)
(21,44,1)
(125,43,1)
(99,15,1)
(38,90,1)
(132,134,1)
(26,89,1)
(89,60,1)
(63,91,1)
(53,79,1)
(130,40,1)
(27,56,1)
(107,139,1)
(85,139,1)
(15,91,1)
(91,98,1)
(80,23,1)
(13,142,1)
(71,122,1)
(82,84,1)
(136,21,1)
(67,124,1)
(19,5,1)
(111,26,1)
(10,57,1)
(100,29,1)
(37,64,1)
(130,115,1)
(135,130,1)
(128,81,1)
(43,37,1)
(86,3,1)
(8,116,1)
(122,38,1)
(87,139,1)
(124,84,1)
(66,32,1)
(92,138,1)
(80,138,2)
(87,107,2)
(26,99,2)
(85,19,2)
(73,82,2)
(65,143,2)
(79,13,2)
(41,4,2)
(38,99,2)
(28,4,2)
(80,35,2)
(15,56,2)
(38,127,2)
(11,134,2)
(92,99,2)
(104,65,2)
(100,29,2)
(146,109,2)
(36,99,2)
(91,127,2)
(20,128,2)
(15,139,2)
(10,57,2)
(4,93,2)
(128,98,2)
(107,139,2)
(25,99,2)
(109,32,2)
(134,84,2)
(43,99,2)
(78,15,2)
(135,127,2)
(67,84,2)
(80,71,2)
(37,127,2)
(65,4,2)
(122,127,2)
(74,32,2)
(8,127,2)
(125,43,2)
(15,127,2)
(4,15,2)
(97,127,2)
(97,99,2)
(11,85,2)
(93,87,2)
(49,128,2)
(18,32,2)
(52,134,2)
(122,99,2)
(51,99,2)
(114,127,2)
(108,99,2)
(120,127,2)
(113,99,2)
(60,127,2)
(87,56,2)
(124,84,2)
(104,15,2)
(89,127,2)
(146,55,2)
(32,99,2)
(100,80,2)
(60,99,2)
(143,4,2)
(91,98,2)
(28,56,2)
(125,99,2)
(85,139,2)
(71,127,2)
(132,84,2)
(68,127,2)
(14,57,2)
(112,17,2)
(118,82,2)
(111,127,2)
(120,99,2)
(13,123,2)
(145,134,2)
(8,99,2)
(87,139,2)
(95,57,2)
(84,102,2)
(133,127,2)
(50,99,2)
(105,99,2)
(100,20,2)
(64,127,2)
(35,127,2)
(26,127,2)
(89,99,2)
(128,102,2)
(19,134,2)
(116,99,2)
(65,28,2)
(102,2,2)
(3,99,2)
(31,99,2)
(76,134,2)
(80,99,2)
(130,115,2)
(46,127,2)
(36,127,2)
(62,127,2)
(138,99,2)
(46,99,2)
(19,115,2)
(36,98,2)
(114,99,2)
(108,107,2)
(39,57,2)
(9,115,2)
(43,127,2)
(108,139,2)
(56,9,2)
(33,82,2)
(143,93,2)
(135,99,2)
(104,4,2)
(9,57,2)
(22,127,2)
(123,44,2)
(28,139,2)
(86,99,2)
(138,127,2)
(13,2,2)
(121,127,2)
(27,127,2)
(95,139,2)
(125,127,2)
(132,134,2)
(80,114,2)
(32,127,2)
(37,99,2)
(24,119,2)
(56,57,2)
(70,57,2)
(45,4,2)
(135,130,2)
(147,123,2)
(28,98,2)
(107,95,2)
(85,134,2)
(96,134,2)
(121,99,2)
(11,145,2)
(111,99,2)
(133,146,2)
(69,57,2)
(53,79,2)
(130,127,2)
(35,99,2)
(83,127,2)
(79,44,2)
(53,44,2)
(31,127,2)
(82,102,2)
(5,134,2)
(29,82,2)
(59,32,2)
(75,127,2)
(99,104,2)
(42,102,2)
(28,107,2)
(80,3,2)
(79,110,2)
(9,139,2)
(3,127,2)
(51,127,2)
(64,99,2)
(144,32,2)
(23,25,2)
(43,112,2)
(87,127,2)
(107,57,2)
(15,107,2)
(57,127,2)
(100,118,2)
(134,2,2)
(137,4,2)
(40,99,2)
(15,91,2)
(109,74,2)
(118,139,2)
(129,4,2)
(132,11,2)
(40,127,2)
(93,127,2)
(50,127,2)
(146,99,2)
(90,127,2)
(100,108,2)
(116,127,2)
(66,32,2)
(82,132,2)
(25,127,2)
(23,99,2)
(86,127,2)
(146,53,2)
(71,99,2)
(82,24,2)
(80,127,2)
(63,127,2)
(127,128,2)
(23,127,2)
(68,99,2)
(133,99,2)
(108,56,2)
(81,102,2)
(99,15,2)
(146,127,2)
(7,128,2)
(130,99,2)
(105,127,2)
(90,99,2)
(80,97,2)
(92,127,2)
(88,44,2)
(94,134,2)
(56,139,2)
(87,112,2)
(99,127,2)
(142,123,2)
(101,82,2)
-----------------------------------
(0,do_align)
(1,if (addr)
(2,unsigned long flags)
(3,info.align_offset)
(4,!vma)
(5,PAGE_SHIFT)
(6,mm)
(7,-ENOMEM)
(8,flags)
(9,COLOUR_ALIGN(addr, pgoff)
(10,addr)
(11,(addr - (pgoff << PAGE_SHIFT)
(12,info)
(13,flags & MAP_SHARED)
(14,pgoff)
(15,TASK_SIZE - len >= addr)
(16,if (len > TASK_SIZE)
(17,current->mm)
(18,1)
(19,pgoff << PAGE_SHIFT)
(20,return -ENOMEM;)
(21,flags)
(22,TASK_SIZE)
(23,vm_unmapped_area(&info)
(24,aliasing = cache_is_vipt_aliasing()
(25,&info)
(26,info)
(27,vma)
(28,addr + len)
(29,return -EINVAL;)
(30,if (flags & MAP_FIXED)
(31,info)
(32,do_align)
(33,addr)
(34,0)
(35,info.flags)
(36,info.length = len)
(37,mmap_base)
(38,info)
(39,addr)
(40,PAGE_SHIFT)
(41,vm_start)
(42,len)
(43,mm->mmap_base)
(44,aliasing)
(45,vma)
(46,TASK_SIZE)
(47,)
(48,aliasing)
(49,ENOMEM)
(50,info)
(51,info)
(52,pgoff)
(53,do_align = filp || (flags & MAP_SHARED)
(54,mm)
(55,do_align = 0)
(56,addr = COLOUR_ALIGN(addr, pgoff)
(57,do_align)
(58,do_align)
(59,SHMLBA)
(60,0)
(61,)
(62,len)
(63,addr)
(64,mm)
(65,addr + len <= vma->vm_start)
(66,PAGE_MASK)
(67,MAP_SHARED)
(68,info)
(69,addr)
(70,addr)
(71,info.align_mask)
(72,mm)
(73,EINVAL)
(74,SHMLBA - 1)
(75,mm)
(76,addr)
(77,aliasing)
(78,vma)
(79,filp || (flags & MAP_SHARED)
(80,return vm_unmapped_area(&info)
(81,TASK_SIZE)
(82,aliasing && flags & MAP_SHARED &&\n\\n\\t\\t    (addr - (pgoff << PAGE_SHIFT)
(83,addr)
(84,aliasing)
(85,addr - (pgoff << PAGE_SHIFT)
(86,pgoff)
(87,find_vma(mm, addr)
(88,do_align)
(89,info.flags = 0)
(90,info.high_limit = TASK_SIZE)
(91,TASK_SIZE - len)
(92,len)
(93,vma = find_vma(mm, addr)
(94,SHMLBA)
(95,PAGE_ALIGN(addr)
(96,1)
(97,info.high_limit)
(98,unsigned long len)
(99,TASK_SIZE - len >= addr &&\n\\n\\t\\t    (!vma || addr + len <= vma->vm_start)
(100,RET)
(101,-EINVAL)
(102,flags & MAP_FIXED)
(103,if (do_align)
(104,!vma || addr + len <= vma->vm_start)
(105,high_limit)
(106,)
(107,addr = PAGE_ALIGN(addr)
(108,return addr;)
(109,PAGE_MASK & (SHMLBA - 1)
(110,struct file *filp)
(111,length)
(112,*mm = current->mm)
(113,addr)
(114,info.low_limit)
(115,unsigned long pgoff)
(116,info)
(117,if (aliasing && flags & MAP_SHARED &&\n\\n\\t\\t    (addr - (pgoff << PAGE_SHIFT)
(118,return addr;)
(119,cache_is_vipt_aliasing()
(120,low_limit)
(121,align_offset)
(122,align_mask)
(123,filp)
(124,flags)
(125,info.low_limit = mm->mmap_base)
(126,if (TASK_SIZE - len >= addr &&\n\\n\\t\\t    (!vma || addr + len <= vma->vm_start)
(127,addr)
(128,len > TASK_SIZE)
(129,addr)
(130,pgoff << PAGE_SHIFT)
(131,vma)
(132,flags & MAP_SHARED &&\n\\n\\t\\t    (addr - (pgoff << PAGE_SHIFT)
(133,info.align_mask = do_align ? (PAGE_MASK & (SHMLBA - 1)
(134,flags & MAP_SHARED)
(135,info.align_offset = pgoff << PAGE_SHIFT)
(136,MAP_FIXED)
(137,len)
(138,info.length)
(139,unsigned long addr)
(140,current)
(141,if (aliasing)
(142,MAP_SHARED)
(143,vma->vm_start)
(144,0)
(145,SHMLBA - 1)
(146,do_align ? (PAGE_MASK & (SHMLBA - 1)
(147,flags)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^