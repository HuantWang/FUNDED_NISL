-----label-----
0
-----code-----
static void dw_mci_tasklet_func(unsigned long priv)
{
	struct dw_mci *host = (struct dw_mci *)priv;
	struct mmc_data	*data;
	struct mmc_command *cmd;
	struct mmc_request *mrq;
	enum dw_mci_state state;
	enum dw_mci_state prev_state;
	unsigned int err;

	spin_lock(&host->lock);

	state = host->state;
	data = host->data;
	mrq = host->mrq;

	do {
		prev_state = state;

		switch (state) {
		case STATE_IDLE:
		case STATE_WAITING_CMD11_DONE:
			break;

		case STATE_SENDING_CMD11:
		case STATE_SENDING_CMD:
			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,
						&host->pending_events))
				break;

			cmd = host->cmd;
			host->cmd = NULL;
			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);
			err = dw_mci_command_complete(host, cmd);
			if (cmd == mrq->sbc && !err) {
				prev_state = state = STATE_SENDING_CMD;
				__dw_mci_start_request(host, host->cur_slot,
						       mrq->cmd);
				goto unlock;
			}

			if (cmd->data && err) {
				/*
				 * During UHS tuning sequence, sending the stop
				 * command after the response CRC error would
				 * throw the system into a confused state
				 * causing all future tuning phases to report
				 * failure.
				 *
				 * In such case controller will move into a data
				 * transfer state after a response error or
				 * response CRC error. Let's let that finish
				 * before trying to send a stop, so we'll go to
				 * STATE_SENDING_DATA.
				 *
				 * Although letting the data transfer take place
				 * will waste a bit of time (we already know
				 * the command was bad), it can't cause any
				 * errors since it's possible it would have
				 * taken place anyway if this tasklet got
				 * delayed. Allowing the transfer to take place
				 * avoids races and keeps things simple.
				 */
				if (err != -ETIMEDOUT) {
					state = STATE_SENDING_DATA;
					continue;
				}

				dw_mci_stop_dma(host);
				send_stop_abort(host, data);
				state = STATE_SENDING_STOP;
				break;
			}

			if (!cmd->data || err) {
				dw_mci_request_end(host, mrq);
				goto unlock;
			}

			prev_state = state = STATE_SENDING_DATA;
			/* fall through */

		case STATE_SENDING_DATA:
			/*
			 * We could get a data error and never a transfer
			 * complete so we'd better check for it here.
			 *
			 * Note that we don't really care if we also got a
			 * transfer complete; stopping the DMA and sending an
			 * abort won't hurt.
			 */
			if (test_and_clear_bit(EVENT_DATA_ERROR,
					       &host->pending_events)) {
				dw_mci_stop_dma(host);
				if (data->stop ||
				    !(host->data_status & (SDMMC_INT_DRTO |
							   SDMMC_INT_EBE)))
					send_stop_abort(host, data);
				state = STATE_DATA_ERROR;
				break;
			}

			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,
						&host->pending_events)) {
				/*
				 * If all data-related interrupts don't come
				 * within the given time in reading data state.
				 */
				if (host->dir_status == DW_MCI_RECV_STATUS)
					dw_mci_set_drto(host);
				break;
			}

			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);

			/*
			 * Handle an EVENT_DATA_ERROR that might have shown up
			 * before the transfer completed.  This might not have
			 * been caught by the check above because the interrupt
			 * could have gone off between the previous check and
			 * the check for transfer complete.
			 *
			 * Technically this ought not be needed assuming we
			 * get a DATA_COMPLETE eventually (we'll notice the
			 * error and end the request), but it shouldn't hurt.
			 *
			 * This has the advantage of sending the stop command.
			 */
			if (test_and_clear_bit(EVENT_DATA_ERROR,
					       &host->pending_events)) {
				dw_mci_stop_dma(host);
				if (data->stop ||
				    !(host->data_status & (SDMMC_INT_DRTO |
							   SDMMC_INT_EBE)))
					send_stop_abort(host, data);
				state = STATE_DATA_ERROR;
				break;
			}
			prev_state = state = STATE_DATA_BUSY;

			/* fall through */

		case STATE_DATA_BUSY:
			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,
						&host->pending_events)) {
				/*
				 * If data error interrupt comes but data over
				 * interrupt doesn't come within the given time.
				 * in reading data state.
				 */
				if (host->dir_status == DW_MCI_RECV_STATUS)
					dw_mci_set_drto(host);
				break;
			}

			host->data = NULL;
			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);
			err = dw_mci_data_complete(host, data);

			if (!err) {
				if (!data->stop || mrq->sbc) {
					if (mrq->sbc && data->stop)
						data->stop->error = 0;
					dw_mci_request_end(host, mrq);
					goto unlock;
				}

				/* stop command for open-ended transfer*/
				if (data->stop)
					send_stop_abort(host, data);
			} else {
				/*
				 * If we don't have a command complete now we'll
				 * never get one since we just reset everything;
				 * better end the request.
				 *
				 * If we do have a command complete we'll fall
				 * through to the SENDING_STOP command and
				 * everything will be peachy keen.
				 */
				if (!test_bit(EVENT_CMD_COMPLETE,
					      &host->pending_events)) {
					host->cmd = NULL;
					dw_mci_request_end(host, mrq);
					goto unlock;
				}
			}

			/*
			 * If err has non-zero,
			 * stop-abort command has been already issued.
			 */
			prev_state = state = STATE_SENDING_STOP;

			/* fall through */

		case STATE_SENDING_STOP:
			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,
						&host->pending_events))
				break;

			/* CMD error in data command */
			if (mrq->cmd->error && mrq->data)
				dw_mci_reset(host);

			host->cmd = NULL;
			host->data = NULL;

			if (mrq->stop)
				dw_mci_command_complete(host, mrq->stop);
			else
				host->cmd_status = 0;

			dw_mci_request_end(host, mrq);
			goto unlock;

		case STATE_DATA_ERROR:
			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,
						&host->pending_events))
				break;

			state = STATE_DATA_BUSY;
			break;
		}
	} while (state != prev_state);

	host->state = state;
unlock:
	spin_unlock(&host->lock);

}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
9,10
9,11
9,12
9,13
9,14
9,15
9,16
9,17
9,18
9,19
9,20
9,21
9,22
9,23
10,11
11,12
11,13
12,13
14,15
14,16
14,17
17,18
18,19
18,20
19,20
19,21
20,21
22,23
24,25
26,27
27,28
27,29
28,29
30,31
30,32
33,34
34,35
34,36
35,36
37,38
37,39
40,41
41,42
41,43
42,43
44,45
44,46
47,48
48,49
48,50
49,50
51,52
53,54
54,55
54,56
55,56
57,58
59,60
60,61
60,62
62,63
64,65
65,66
65,67
66,67
68,69
69,70
69,71
70,71
73,74
74,75
74,76
75,76
77,78
77,79
78,79
81,82
82,83
82,84
83,84
85,86
85,87
86,87
89,90
90,91
90,92
91,92
93,94
93,95
94,95
97,98
97,99
98,99
98,100
99,100
100,101
100,102
101,102
103,104
105,106
105,107
106,107
108,109
108,110
108,111
108,112
108,113
108,114
108,115
108,116
108,117
108,118
108,119
108,120
108,121
108,122
108,123
108,124
108,125
108,126
108,127
108,128
108,129
108,130
108,131
108,132
108,133
108,134
108,135
108,136
108,137
108,138
108,139
108,140
108,141
108,142
108,143
108,144
108,145
108,146
108,147
109,110
110,111
112,113
113,114
116,117
117,118
119,120
120,121
122,123
122,124
123,124
124,125
124,126
124,127
125,126
127,128
129,130
130,131
130,132
131,132
135,136
136,137
136,138
137,138
139,140
139,141
140,141
143,144
144,145
144,146
145,146
145,147
146,147
149,150
151,152
152,153
152,154
152,155
153,154
155,156
157,158
158,159
158,160
159,160
162,163
163,164
163,165
164,165
166,167
166,168
166,169
167,168
169,170
171,172
173,174
173,175
174,175
174,176
175,176
175,177
176,177
178,179
178,180
179,180
182,183
183,184
185,186
185,187
185,188
186,187
187,188
187,189
188,189
190,191
190,192
191,192
193,194
195,196
196,197
196,198
196,199
196,200
197,198
199,200
201,202
201,203
202,203
205,206
205,207
206,207
209,210
211,212
211,213
212,213
212,214
213,214
213,215
214,215
217,218
219,220
219,221
219,222
219,223
219,224
220,221
220,222
221,222
221,223
222,223
224,225
225,226
227,228
227,229
228,229
229,230
229,231
230,231
232,233
235,236
236,237
236,238
237,238
239,240
241,242
242,243
242,244
242,245
243,244
245,246
247,248
249,250
250,251
250,252
251,252
253,254
256,257
256,258
257,258
257,259
258,259
259,260
259,261
260,261
263,264
265,266
265,267
266,267
267,268
267,269
267,270
268,269
270,271
272,273
274,275
276,277
277,278
277,279
278,279
280,281
280,282
281,282
283,284
285,286
286,287
288,289
288,290
289,290
289,291
289,292
290,291
292,293
294,295
295,296
295,297
296,297
299,300
299,301
299,302
299,303
300,301
301,302
301,303
302,303
304,305
306,307
306,308
307,308
307,309
308,309
308,310
309,310
312,313
313,314
314,315
314,316
315,316
315,317
316,317
319,320
320,321
320,322
321,322
323,324
325,326
326,327
326,328
326,329
327,328
329,330
331,332
333,334
334,335
334,336
335,336
337,338
340,341
340,342
341,342
342,343
342,344
342,345
343,344
345,346
347,348
348,349
348,350
349,350
352,353
352,354
353,354
353,355
354,355
354,356
355,356
355,357
356,357
359,360
361,362
362,363
362,364
363,364
365,366
368,369
369,370
369,371
369,372
370,371
372,373
374,375
375,376
375,377
376,377
379,380
379,381
380,381
380,382
380,383
381,382
383,384
385,386
386,387
386,388
387,388
390,391
390,392
390,393
390,394
391,392
392,393
392,394
393,394
395,396
397,398
397,399
398,399
398,400
399,400
399,401
400,401
403,404
404,405
405,406
405,407
406,407
406,408
407,408
410,411
411,412
411,413
412,413
414,415
416,417
417,418
417,419
417,420
418,419
420,421
422,423
424,425
425,426
425,427
426,427
428,429
431,432
432,433
432,434
433,434
435,436
435,437
436,437
438,439
440,441
441,442
443,444
443,445
444,445
445,446
445,447
445,448
446,447
448,449
450,451
451,452
451,453
452,453
455,456
455,457
456,457
456,458
457,458
457,459
458,459
458,460
459,460
462,463
464,465
465,466
465,467
466,467
468,469
471,472
472,473
472,474
473,474
473,475
474,475
477,478
479,480
480,481
480,482
480,483
481,482
483,484
485,486
486,487
486,488
487,488
490,491
491,492
491,493
492,493
494,495
494,496
494,497
495,496
497,498
499,500
501,502
501,503
501,504
502,503
503,504
505,506
505,507
506,507
506,508
507,508
507,509
508,509
509,510
509,511
510,511
513,514
513,515
514,515
517,518
517,519
517,520
518,519
518,520
519,520
519,521
520,521
520,522
521,522
524,525
524,526
525,526
528,529
529,530
529,531
530,531
530,532
531,532
531,533
532,533
537,538
538,539
538,540
538,541
539,540
541,542
543,544
545,546
547,548
547,549
548,549
548,550
549,550
552,553
553,554
553,555
553,556
554,555
556,557
558,559
560,561
561,562
561,563
562,563
563,564
563,565
563,566
564,565
566,567
568,569
569,570
569,571
570,571
573,574
573,575
573,576
574,575
575,576
575,577
576,577
576,578
577,578
580,581
582,583
583,584
583,585
583,586
584,585
586,587
588,589
590,591
592,593
593,594
593,595
594,595
596,597
596,598
597,598
599,600
601,602
602,603
604,605
604,606
605,606
606,607
606,608
606,609
607,608
609,610
611,612
612,613
612,614
613,614
617,618
617,619
618,619
618,620
619,620
619,621
620,621
620,622
621,622
625,626
625,627
626,627
629,630
630,631
630,632
631,632
633,634
635,636
636,637
636,638
637,638
637,639
638,639
641,642
643,644
644,645
644,646
645,646
645,647
646,647
649,650
651,652
651,653
651,654
652,653
652,654
653,654
656,657
657,658
657,659
657,660
658,659
660,661
662,663
662,664
663,664
666,667
667,668
667,669
668,669
668,670
669,670
673,674
674,675
674,676
674,677
675,676
677,678
679,680
681,682
683,684
684,685
686,687
686,688
687,688
688,689
688,690
688,691
689,690
691,692
693,694
694,695
694,696
695,696
699,700
700,701
700,702
701,702
703,704
706,707
706,708
707,708
709,710
711,712
712,713
712,714
713,714
713,715
714,715
717,718
719,720
719,721
721,722
722,723
722,724
723,724
725,726
726,727
726,728
727,728
-----nextToken-----
2,4,6,8,13,15,16,21,23,25,29,31,32,36,38,39,43,45,46,50,52,56,58,61,63,67,71,72,76,79,80,84,87,88,92,95,96,102,104,107,111,114,115,118,121,126,128,132,133,134,138,141,142,147,148,150,154,156,160,161,165,168,170,172,177,180,181,184,189,192,194,198,200,203,204,207,208,210,215,216,218,223,226,231,233,234,238,240,244,246,248,252,254,255,261,262,264,269,271,273,275,279,282,284,287,291,293,297,298,303,305,310,311,317,318,322,324,328,330,332,336,338,339,344,346,350,351,357,358,360,364,366,367,371,373,377,378,382,384,388,389,394,396,401,402,408,409,413,415,419,421,423,427,429,430,434,437,439,442,447,449,453,454,460,461,463,467,469,470,475,476,478,482,484,488,489,493,496,498,500,504,511,512,515,516,522,523,526,527,533,534,535,536,540,542,544,546,550,551,555,557,559,565,567,571,572,578,579,581,585,587,589,591,595,598,600,603,608,610,614,615,616,622,623,624,627,628,632,634,639,640,642,647,648,650,654,655,659,661,664,665,670,671,672,676,678,680,682,685,690,692,696,697,698,702,704,705,708,710,715,716,718,720,724,728,729
-----computeFrom-----
74,75
74,76
82,83
82,84
90,91
90,92
100,101
100,102
136,137
136,138
144,145
144,146
163,164
163,165
174,175
174,176
175,176
175,177
187,188
187,189
190,191
190,192
212,213
212,214
221,222
221,223
229,230
229,231
250,251
250,252
257,258
257,259
277,278
277,279
280,281
280,282
307,308
307,309
314,315
314,316
320,321
320,322
334,335
334,336
354,355
354,356
398,399
398,400
405,406
405,407
411,412
411,413
425,426
425,427
432,433
432,434
435,436
435,437
457,458
457,459
472,473
472,474
491,492
491,493
507,508
507,509
519,520
519,521
529,530
529,531
575,576
575,577
593,594
593,595
596,597
596,598
618,619
618,620
636,637
636,638
644,645
644,646
667,668
667,669
700,701
700,702
706,707
706,708
712,713
712,714
-----guardedBy-----
177,208
180,207
216,248
218,223
310,332
317,330
357,366
401,423
408,421
460,469
511,533
512,534
516,523
515,544
526,533
527,534
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DoStatement;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;GotoStatement;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ContinueStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;UnaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;UnaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BreakStatement;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;GotoStatement;Name;CaseStatement;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;LabelStatement;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;
-----ast_node-----
static void dw_mci_tasklet_func(unsigned long priv){	struct dw_mci *host = (struct dw_mci *)priv;	struct mmc_data	*data;	struct mmc_command *cmd;	struct mmc_request *mrq;	enum dw_mci_state state;	enum dw_mci_state prev_state;	unsigned int err;	spin_lock(&host->lock);	state = host->state;	data = host->data;	mrq = host->mrq;	do {		prev_state = state;		switch (state) {		case STATE_IDLE:		case STATE_WAITING_CMD11_DONE:			break;		case STATE_SENDING_CMD11:		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			err = dw_mci_command_complete(host, cmd);			if (cmd == mrq->sbc && !err) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);				goto unlock;			}			if (cmd->data && err) {				/*				 * During UHS tuning sequence, sending the stop				 * command after the response CRC error would				 * throw the system into a confused state				 * causing all future tuning phases to report				 * failure.				 *				 * In such case controller will move into a data				 * transfer state after a response error or				 * response CRC error. Let's let that finish				 * before trying to send a stop, so we'll go to				 * STATE_SENDING_DATA.				 *				 * Although letting the data transfer take place				 * will waste a bit of time (we already know				 * the command was bad), it can't cause any				 * errors since it's possible it would have				 * taken place anyway if this tasklet got				 * delayed. Allowing the transfer to take place				 * avoids races and keeps things simple.				 */				if (err != -ETIMEDOUT) {					state = STATE_SENDING_DATA;					continue;				}				dw_mci_stop_dma(host);				send_stop_abort(host, data);				state = STATE_SENDING_STOP;				break;			}			if (!cmd->data || err) {				dw_mci_request_end(host, mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			/*			 * We could get a data error and never a transfer			 * complete so we'd better check for it here.			 *			 * Note that we don't really care if we also got a			 * transfer complete; stopping the DMA and sending an			 * abort won't hurt.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)) {				/*				 * If all data-related interrupts don't come				 * within the given time in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			/*			 * Handle an EVENT_DATA_ERROR that might have shown up			 * before the transfer completed.  This might not have			 * been caught by the check above because the interrupt			 * could have gone off between the previous check and			 * the check for transfer complete.			 *			 * Technically this ought not be needed assuming we			 * get a DATA_COMPLETE eventually (we'll notice the			 * error and end the request), but it shouldn't hurt.			 *			 * This has the advantage of sending the stop command.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)) {				/*				 * If data error interrupt comes but data over				 * interrupt doesn't come within the given time.				 * in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			err = dw_mci_data_complete(host, data);			if (!err) {				if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}				/* stop command for open-ended transfer*/				if (data->stop)					send_stop_abort(host, data);			} else {				/*				 * If we don't have a command complete now we'll				 * never get one since we just reset everything;				 * better end the request.				 *				 * If we do have a command complete we'll fall				 * through to the SENDING_STOP command and				 * everything will be peachy keen.				 */				if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}			}			/*			 * If err has non-zero,			 * stop-abort command has been already issued.			 */			prev_state = state = STATE_SENDING_STOP;			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			/* CMD error in data command */			if (mrq->cmd->error && mrq->data)				dw_mci_reset(host);			host->cmd = NULL;			host->data = NULL;			if (mrq->stop)				dw_mci_command_complete(host, mrq->stop);			else				host->cmd_status = 0;			dw_mci_request_end(host, mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}	} while (state != prev_state);	host->state = state;unlock:	spin_unlock(&host->lock);}
static void
dw_mci_tasklet_func(unsigned long priv)
dw_mci_tasklet_func
unsigned long priv
unsigned long
priv
priv
{	struct dw_mci *host = (struct dw_mci *)priv;	struct mmc_data	*data;	struct mmc_command *cmd;	struct mmc_request *mrq;	enum dw_mci_state state;	enum dw_mci_state prev_state;	unsigned int err;	spin_lock(&host->lock);	state = host->state;	data = host->data;	mrq = host->mrq;	do {		prev_state = state;		switch (state) {		case STATE_IDLE:		case STATE_WAITING_CMD11_DONE:			break;		case STATE_SENDING_CMD11:		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			err = dw_mci_command_complete(host, cmd);			if (cmd == mrq->sbc && !err) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);				goto unlock;			}			if (cmd->data && err) {				/*				 * During UHS tuning sequence, sending the stop				 * command after the response CRC error would				 * throw the system into a confused state				 * causing all future tuning phases to report				 * failure.				 *				 * In such case controller will move into a data				 * transfer state after a response error or				 * response CRC error. Let's let that finish				 * before trying to send a stop, so we'll go to				 * STATE_SENDING_DATA.				 *				 * Although letting the data transfer take place				 * will waste a bit of time (we already know				 * the command was bad), it can't cause any				 * errors since it's possible it would have				 * taken place anyway if this tasklet got				 * delayed. Allowing the transfer to take place				 * avoids races and keeps things simple.				 */				if (err != -ETIMEDOUT) {					state = STATE_SENDING_DATA;					continue;				}				dw_mci_stop_dma(host);				send_stop_abort(host, data);				state = STATE_SENDING_STOP;				break;			}			if (!cmd->data || err) {				dw_mci_request_end(host, mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			/*			 * We could get a data error and never a transfer			 * complete so we'd better check for it here.			 *			 * Note that we don't really care if we also got a			 * transfer complete; stopping the DMA and sending an			 * abort won't hurt.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)) {				/*				 * If all data-related interrupts don't come				 * within the given time in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			/*			 * Handle an EVENT_DATA_ERROR that might have shown up			 * before the transfer completed.  This might not have			 * been caught by the check above because the interrupt			 * could have gone off between the previous check and			 * the check for transfer complete.			 *			 * Technically this ought not be needed assuming we			 * get a DATA_COMPLETE eventually (we'll notice the			 * error and end the request), but it shouldn't hurt.			 *			 * This has the advantage of sending the stop command.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)) {				/*				 * If data error interrupt comes but data over				 * interrupt doesn't come within the given time.				 * in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			err = dw_mci_data_complete(host, data);			if (!err) {				if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}				/* stop command for open-ended transfer*/				if (data->stop)					send_stop_abort(host, data);			} else {				/*				 * If we don't have a command complete now we'll				 * never get one since we just reset everything;				 * better end the request.				 *				 * If we do have a command complete we'll fall				 * through to the SENDING_STOP command and				 * everything will be peachy keen.				 */				if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}			}			/*			 * If err has non-zero,			 * stop-abort command has been already issued.			 */			prev_state = state = STATE_SENDING_STOP;			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			/* CMD error in data command */			if (mrq->cmd->error && mrq->data)				dw_mci_reset(host);			host->cmd = NULL;			host->data = NULL;			if (mrq->stop)				dw_mci_command_complete(host, mrq->stop);			else				host->cmd_status = 0;			dw_mci_request_end(host, mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}	} while (state != prev_state);	host->state = state;unlock:	spin_unlock(&host->lock);}
struct dw_mci *host = (struct dw_mci *)priv;
struct dw_mci *host = (struct dw_mci *)priv;
struct dw_mci
dw_mci
*host = (struct dw_mci *)priv
*
host
= (struct dw_mci *)priv
(struct dw_mci *)priv
struct dw_mci *
struct dw_mci
dw_mci
*
*
priv
priv
struct mmc_data	*data;
struct mmc_data	*data;
struct mmc_data
mmc_data
*data
*
data
struct mmc_command *cmd;
struct mmc_command *cmd;
struct mmc_command
mmc_command
*cmd
*
cmd
struct mmc_request *mrq;
struct mmc_request *mrq;
struct mmc_request
mmc_request
*mrq
*
mrq
enum dw_mci_state state;
enum dw_mci_state state;
enum dw_mci_state
dw_mci_state
state
state
enum dw_mci_state prev_state;
enum dw_mci_state prev_state;
enum dw_mci_state
dw_mci_state
prev_state
prev_state
unsigned int err;
unsigned int err;
unsigned int
err
err
spin_lock(&host->lock);
spin_lock(&host->lock)
spin_lock
spin_lock
&host->lock
host->lock
host
host
lock
state = host->state;
state = host->state
state
state
host->state
host
host
state
data = host->data;
data = host->data
data
data
host->data
host
host
data
mrq = host->mrq;
mrq = host->mrq
mrq
mrq
host->mrq
host
host
mrq
do {		prev_state = state;		switch (state) {		case STATE_IDLE:		case STATE_WAITING_CMD11_DONE:			break;		case STATE_SENDING_CMD11:		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			err = dw_mci_command_complete(host, cmd);			if (cmd == mrq->sbc && !err) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);				goto unlock;			}			if (cmd->data && err) {				/*				 * During UHS tuning sequence, sending the stop				 * command after the response CRC error would				 * throw the system into a confused state				 * causing all future tuning phases to report				 * failure.				 *				 * In such case controller will move into a data				 * transfer state after a response error or				 * response CRC error. Let's let that finish				 * before trying to send a stop, so we'll go to				 * STATE_SENDING_DATA.				 *				 * Although letting the data transfer take place				 * will waste a bit of time (we already know				 * the command was bad), it can't cause any				 * errors since it's possible it would have				 * taken place anyway if this tasklet got				 * delayed. Allowing the transfer to take place				 * avoids races and keeps things simple.				 */				if (err != -ETIMEDOUT) {					state = STATE_SENDING_DATA;					continue;				}				dw_mci_stop_dma(host);				send_stop_abort(host, data);				state = STATE_SENDING_STOP;				break;			}			if (!cmd->data || err) {				dw_mci_request_end(host, mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			/*			 * We could get a data error and never a transfer			 * complete so we'd better check for it here.			 *			 * Note that we don't really care if we also got a			 * transfer complete; stopping the DMA and sending an			 * abort won't hurt.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)) {				/*				 * If all data-related interrupts don't come				 * within the given time in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			/*			 * Handle an EVENT_DATA_ERROR that might have shown up			 * before the transfer completed.  This might not have			 * been caught by the check above because the interrupt			 * could have gone off between the previous check and			 * the check for transfer complete.			 *			 * Technically this ought not be needed assuming we			 * get a DATA_COMPLETE eventually (we'll notice the			 * error and end the request), but it shouldn't hurt.			 *			 * This has the advantage of sending the stop command.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)) {				/*				 * If data error interrupt comes but data over				 * interrupt doesn't come within the given time.				 * in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			err = dw_mci_data_complete(host, data);			if (!err) {				if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}				/* stop command for open-ended transfer*/				if (data->stop)					send_stop_abort(host, data);			} else {				/*				 * If we don't have a command complete now we'll				 * never get one since we just reset everything;				 * better end the request.				 *				 * If we do have a command complete we'll fall				 * through to the SENDING_STOP command and				 * everything will be peachy keen.				 */				if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}			}			/*			 * If err has non-zero,			 * stop-abort command has been already issued.			 */			prev_state = state = STATE_SENDING_STOP;			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			/* CMD error in data command */			if (mrq->cmd->error && mrq->data)				dw_mci_reset(host);			host->cmd = NULL;			host->data = NULL;			if (mrq->stop)				dw_mci_command_complete(host, mrq->stop);			else				host->cmd_status = 0;			dw_mci_request_end(host, mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}	} while (state != prev_state);
{		prev_state = state;		switch (state) {		case STATE_IDLE:		case STATE_WAITING_CMD11_DONE:			break;		case STATE_SENDING_CMD11:		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			err = dw_mci_command_complete(host, cmd);			if (cmd == mrq->sbc && !err) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);				goto unlock;			}			if (cmd->data && err) {				/*				 * During UHS tuning sequence, sending the stop				 * command after the response CRC error would				 * throw the system into a confused state				 * causing all future tuning phases to report				 * failure.				 *				 * In such case controller will move into a data				 * transfer state after a response error or				 * response CRC error. Let's let that finish				 * before trying to send a stop, so we'll go to				 * STATE_SENDING_DATA.				 *				 * Although letting the data transfer take place				 * will waste a bit of time (we already know				 * the command was bad), it can't cause any				 * errors since it's possible it would have				 * taken place anyway if this tasklet got				 * delayed. Allowing the transfer to take place				 * avoids races and keeps things simple.				 */				if (err != -ETIMEDOUT) {					state = STATE_SENDING_DATA;					continue;				}				dw_mci_stop_dma(host);				send_stop_abort(host, data);				state = STATE_SENDING_STOP;				break;			}			if (!cmd->data || err) {				dw_mci_request_end(host, mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			/*			 * We could get a data error and never a transfer			 * complete so we'd better check for it here.			 *			 * Note that we don't really care if we also got a			 * transfer complete; stopping the DMA and sending an			 * abort won't hurt.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)) {				/*				 * If all data-related interrupts don't come				 * within the given time in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			/*			 * Handle an EVENT_DATA_ERROR that might have shown up			 * before the transfer completed.  This might not have			 * been caught by the check above because the interrupt			 * could have gone off between the previous check and			 * the check for transfer complete.			 *			 * Technically this ought not be needed assuming we			 * get a DATA_COMPLETE eventually (we'll notice the			 * error and end the request), but it shouldn't hurt.			 *			 * This has the advantage of sending the stop command.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)) {				/*				 * If data error interrupt comes but data over				 * interrupt doesn't come within the given time.				 * in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			err = dw_mci_data_complete(host, data);			if (!err) {				if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}				/* stop command for open-ended transfer*/				if (data->stop)					send_stop_abort(host, data);			} else {				/*				 * If we don't have a command complete now we'll				 * never get one since we just reset everything;				 * better end the request.				 *				 * If we do have a command complete we'll fall				 * through to the SENDING_STOP command and				 * everything will be peachy keen.				 */				if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}			}			/*			 * If err has non-zero,			 * stop-abort command has been already issued.			 */			prev_state = state = STATE_SENDING_STOP;			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			/* CMD error in data command */			if (mrq->cmd->error && mrq->data)				dw_mci_reset(host);			host->cmd = NULL;			host->data = NULL;			if (mrq->stop)				dw_mci_command_complete(host, mrq->stop);			else				host->cmd_status = 0;			dw_mci_request_end(host, mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}	}
prev_state = state;
prev_state = state
prev_state
prev_state
state
state
switch (state) {		case STATE_IDLE:		case STATE_WAITING_CMD11_DONE:			break;		case STATE_SENDING_CMD11:		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			err = dw_mci_command_complete(host, cmd);			if (cmd == mrq->sbc && !err) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);				goto unlock;			}			if (cmd->data && err) {				/*				 * During UHS tuning sequence, sending the stop				 * command after the response CRC error would				 * throw the system into a confused state				 * causing all future tuning phases to report				 * failure.				 *				 * In such case controller will move into a data				 * transfer state after a response error or				 * response CRC error. Let's let that finish				 * before trying to send a stop, so we'll go to				 * STATE_SENDING_DATA.				 *				 * Although letting the data transfer take place				 * will waste a bit of time (we already know				 * the command was bad), it can't cause any				 * errors since it's possible it would have				 * taken place anyway if this tasklet got				 * delayed. Allowing the transfer to take place				 * avoids races and keeps things simple.				 */				if (err != -ETIMEDOUT) {					state = STATE_SENDING_DATA;					continue;				}				dw_mci_stop_dma(host);				send_stop_abort(host, data);				state = STATE_SENDING_STOP;				break;			}			if (!cmd->data || err) {				dw_mci_request_end(host, mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			/*			 * We could get a data error and never a transfer			 * complete so we'd better check for it here.			 *			 * Note that we don't really care if we also got a			 * transfer complete; stopping the DMA and sending an			 * abort won't hurt.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)) {				/*				 * If all data-related interrupts don't come				 * within the given time in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			/*			 * Handle an EVENT_DATA_ERROR that might have shown up			 * before the transfer completed.  This might not have			 * been caught by the check above because the interrupt			 * could have gone off between the previous check and			 * the check for transfer complete.			 *			 * Technically this ought not be needed assuming we			 * get a DATA_COMPLETE eventually (we'll notice the			 * error and end the request), but it shouldn't hurt.			 *			 * This has the advantage of sending the stop command.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)) {				/*				 * If data error interrupt comes but data over				 * interrupt doesn't come within the given time.				 * in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			err = dw_mci_data_complete(host, data);			if (!err) {				if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}				/* stop command for open-ended transfer*/				if (data->stop)					send_stop_abort(host, data);			} else {				/*				 * If we don't have a command complete now we'll				 * never get one since we just reset everything;				 * better end the request.				 *				 * If we do have a command complete we'll fall				 * through to the SENDING_STOP command and				 * everything will be peachy keen.				 */				if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}			}			/*			 * If err has non-zero,			 * stop-abort command has been already issued.			 */			prev_state = state = STATE_SENDING_STOP;			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			/* CMD error in data command */			if (mrq->cmd->error && mrq->data)				dw_mci_reset(host);			host->cmd = NULL;			host->data = NULL;			if (mrq->stop)				dw_mci_command_complete(host, mrq->stop);			else				host->cmd_status = 0;			dw_mci_request_end(host, mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}
state
state
{		case STATE_IDLE:		case STATE_WAITING_CMD11_DONE:			break;		case STATE_SENDING_CMD11:		case STATE_SENDING_CMD:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			cmd = host->cmd;			host->cmd = NULL;			set_bit(EVENT_CMD_COMPLETE, &host->completed_events);			err = dw_mci_command_complete(host, cmd);			if (cmd == mrq->sbc && !err) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);				goto unlock;			}			if (cmd->data && err) {				/*				 * During UHS tuning sequence, sending the stop				 * command after the response CRC error would				 * throw the system into a confused state				 * causing all future tuning phases to report				 * failure.				 *				 * In such case controller will move into a data				 * transfer state after a response error or				 * response CRC error. Let's let that finish				 * before trying to send a stop, so we'll go to				 * STATE_SENDING_DATA.				 *				 * Although letting the data transfer take place				 * will waste a bit of time (we already know				 * the command was bad), it can't cause any				 * errors since it's possible it would have				 * taken place anyway if this tasklet got				 * delayed. Allowing the transfer to take place				 * avoids races and keeps things simple.				 */				if (err != -ETIMEDOUT) {					state = STATE_SENDING_DATA;					continue;				}				dw_mci_stop_dma(host);				send_stop_abort(host, data);				state = STATE_SENDING_STOP;				break;			}			if (!cmd->data || err) {				dw_mci_request_end(host, mrq);				goto unlock;			}			prev_state = state = STATE_SENDING_DATA;			/* fall through */		case STATE_SENDING_DATA:			/*			 * We could get a data error and never a transfer			 * complete so we'd better check for it here.			 *			 * Note that we don't really care if we also got a			 * transfer complete; stopping the DMA and sending an			 * abort won't hurt.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)) {				/*				 * If all data-related interrupts don't come				 * within the given time in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			set_bit(EVENT_XFER_COMPLETE, &host->completed_events);			/*			 * Handle an EVENT_DATA_ERROR that might have shown up			 * before the transfer completed.  This might not have			 * been caught by the check above because the interrupt			 * could have gone off between the previous check and			 * the check for transfer complete.			 *			 * Technically this ought not be needed assuming we			 * get a DATA_COMPLETE eventually (we'll notice the			 * error and end the request), but it shouldn't hurt.			 *			 * This has the advantage of sending the stop command.			 */			if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}			prev_state = state = STATE_DATA_BUSY;			/* fall through */		case STATE_DATA_BUSY:			if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)) {				/*				 * If data error interrupt comes but data over				 * interrupt doesn't come within the given time.				 * in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}			host->data = NULL;			set_bit(EVENT_DATA_COMPLETE, &host->completed_events);			err = dw_mci_data_complete(host, data);			if (!err) {				if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}				/* stop command for open-ended transfer*/				if (data->stop)					send_stop_abort(host, data);			} else {				/*				 * If we don't have a command complete now we'll				 * never get one since we just reset everything;				 * better end the request.				 *				 * If we do have a command complete we'll fall				 * through to the SENDING_STOP command and				 * everything will be peachy keen.				 */				if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}			}			/*			 * If err has non-zero,			 * stop-abort command has been already issued.			 */			prev_state = state = STATE_SENDING_STOP;			/* fall through */		case STATE_SENDING_STOP:			if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;			/* CMD error in data command */			if (mrq->cmd->error && mrq->data)				dw_mci_reset(host);			host->cmd = NULL;			host->data = NULL;			if (mrq->stop)				dw_mci_command_complete(host, mrq->stop);			else				host->cmd_status = 0;			dw_mci_request_end(host, mrq);			goto unlock;		case STATE_DATA_ERROR:			if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;			state = STATE_DATA_BUSY;			break;		}
case STATE_IDLE:
STATE_IDLE
STATE_IDLE
case STATE_WAITING_CMD11_DONE:
STATE_WAITING_CMD11_DONE
STATE_WAITING_CMD11_DONE
break;
case STATE_SENDING_CMD11:
STATE_SENDING_CMD11
STATE_SENDING_CMD11
case STATE_SENDING_CMD:
STATE_SENDING_CMD
STATE_SENDING_CMD
if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;
!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_CMD_COMPLETE
EVENT_CMD_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
break;
cmd = host->cmd;
cmd = host->cmd
cmd
cmd
host->cmd
host
host
cmd
host->cmd = NULL;
host->cmd = NULL
host->cmd
host
host
cmd
NULL
NULL
set_bit(EVENT_CMD_COMPLETE, &host->completed_events);
set_bit(EVENT_CMD_COMPLETE, &host->completed_events)
set_bit
set_bit
EVENT_CMD_COMPLETE
EVENT_CMD_COMPLETE
&host->completed_events
host->completed_events
host
host
completed_events
err = dw_mci_command_complete(host, cmd);
err = dw_mci_command_complete(host, cmd)
err
err
dw_mci_command_complete(host, cmd)
dw_mci_command_complete
dw_mci_command_complete
host
host
cmd
cmd
if (cmd == mrq->sbc && !err) {				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);				goto unlock;			}
cmd == mrq->sbc && !err
cmd == mrq->sbc
cmd
cmd
mrq->sbc
mrq
mrq
sbc
!err
err
err
{				prev_state = state = STATE_SENDING_CMD;				__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);				goto unlock;			}
prev_state = state = STATE_SENDING_CMD;
prev_state = state = STATE_SENDING_CMD
prev_state
prev_state
state = STATE_SENDING_CMD
state
state
STATE_SENDING_CMD
STATE_SENDING_CMD
__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd);
__dw_mci_start_request(host, host->cur_slot,						       mrq->cmd)
__dw_mci_start_request
__dw_mci_start_request
host
host
host->cur_slot
host
host
cur_slot
mrq->cmd
mrq
mrq
cmd
goto unlock;
unlock
if (cmd->data && err) {				/*				 * During UHS tuning sequence, sending the stop				 * command after the response CRC error would				 * throw the system into a confused state				 * causing all future tuning phases to report				 * failure.				 *				 * In such case controller will move into a data				 * transfer state after a response error or				 * response CRC error. Let's let that finish				 * before trying to send a stop, so we'll go to				 * STATE_SENDING_DATA.				 *				 * Although letting the data transfer take place				 * will waste a bit of time (we already know				 * the command was bad), it can't cause any				 * errors since it's possible it would have				 * taken place anyway if this tasklet got				 * delayed. Allowing the transfer to take place				 * avoids races and keeps things simple.				 */				if (err != -ETIMEDOUT) {					state = STATE_SENDING_DATA;					continue;				}				dw_mci_stop_dma(host);				send_stop_abort(host, data);				state = STATE_SENDING_STOP;				break;			}
cmd->data && err
cmd->data
cmd
cmd
data
err
err
{				/*				 * During UHS tuning sequence, sending the stop				 * command after the response CRC error would				 * throw the system into a confused state				 * causing all future tuning phases to report				 * failure.				 *				 * In such case controller will move into a data				 * transfer state after a response error or				 * response CRC error. Let's let that finish				 * before trying to send a stop, so we'll go to				 * STATE_SENDING_DATA.				 *				 * Although letting the data transfer take place				 * will waste a bit of time (we already know				 * the command was bad), it can't cause any				 * errors since it's possible it would have				 * taken place anyway if this tasklet got				 * delayed. Allowing the transfer to take place				 * avoids races and keeps things simple.				 */				if (err != -ETIMEDOUT) {					state = STATE_SENDING_DATA;					continue;				}				dw_mci_stop_dma(host);				send_stop_abort(host, data);				state = STATE_SENDING_STOP;				break;			}
if (err != -ETIMEDOUT) {					state = STATE_SENDING_DATA;					continue;				}
err != -ETIMEDOUT
err
err
-ETIMEDOUT
ETIMEDOUT
ETIMEDOUT
{					state = STATE_SENDING_DATA;					continue;				}
state = STATE_SENDING_DATA;
state = STATE_SENDING_DATA
state
state
STATE_SENDING_DATA
STATE_SENDING_DATA
continue;
dw_mci_stop_dma(host);
dw_mci_stop_dma(host)
dw_mci_stop_dma
dw_mci_stop_dma
host
host
send_stop_abort(host, data);
send_stop_abort(host, data)
send_stop_abort
send_stop_abort
host
host
data
data
state = STATE_SENDING_STOP;
state = STATE_SENDING_STOP
state
state
STATE_SENDING_STOP
STATE_SENDING_STOP
break;
if (!cmd->data || err) {				dw_mci_request_end(host, mrq);				goto unlock;			}
!cmd->data || err
!cmd->data
cmd->data
cmd
cmd
data
err
err
{				dw_mci_request_end(host, mrq);				goto unlock;			}
dw_mci_request_end(host, mrq);
dw_mci_request_end(host, mrq)
dw_mci_request_end
dw_mci_request_end
host
host
mrq
mrq
goto unlock;
unlock
prev_state = state = STATE_SENDING_DATA;
prev_state = state = STATE_SENDING_DATA
prev_state
prev_state
state = STATE_SENDING_DATA
state
state
STATE_SENDING_DATA
STATE_SENDING_DATA
case STATE_SENDING_DATA:
STATE_SENDING_DATA
STATE_SENDING_DATA
if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}
test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_DATA_ERROR
EVENT_DATA_ERROR
&host->pending_events
host->pending_events
host
host
pending_events
{				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}
dw_mci_stop_dma(host);
dw_mci_stop_dma(host)
dw_mci_stop_dma
dw_mci_stop_dma
host
host
if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);
data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE))
data->stop
data
data
stop
!(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE))
(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE))
host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)
host->data_status
host
host
data_status
(SDMMC_INT_DRTO |							   SDMMC_INT_EBE)
SDMMC_INT_DRTO |							   SDMMC_INT_EBE
SDMMC_INT_DRTO
SDMMC_INT_DRTO
SDMMC_INT_EBE
SDMMC_INT_EBE
send_stop_abort(host, data);
send_stop_abort(host, data)
send_stop_abort
send_stop_abort
host
host
data
data
state = STATE_DATA_ERROR;
state = STATE_DATA_ERROR
state
state
STATE_DATA_ERROR
STATE_DATA_ERROR
break;
if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)) {				/*				 * If all data-related interrupts don't come				 * within the given time in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}
!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_XFER_COMPLETE
EVENT_XFER_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
{				/*				 * If all data-related interrupts don't come				 * within the given time in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}
if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);
host->dir_status == DW_MCI_RECV_STATUS
host->dir_status
host
host
dir_status
DW_MCI_RECV_STATUS
DW_MCI_RECV_STATUS
dw_mci_set_drto(host);
dw_mci_set_drto(host)
dw_mci_set_drto
dw_mci_set_drto
host
host
break;
set_bit(EVENT_XFER_COMPLETE, &host->completed_events);
set_bit(EVENT_XFER_COMPLETE, &host->completed_events)
set_bit
set_bit
EVENT_XFER_COMPLETE
EVENT_XFER_COMPLETE
&host->completed_events
host->completed_events
host
host
completed_events
if (test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)) {				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}
test_and_clear_bit(EVENT_DATA_ERROR,					       &host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_DATA_ERROR
EVENT_DATA_ERROR
&host->pending_events
host->pending_events
host
host
pending_events
{				dw_mci_stop_dma(host);				if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);				state = STATE_DATA_ERROR;				break;			}
dw_mci_stop_dma(host);
dw_mci_stop_dma(host)
dw_mci_stop_dma
dw_mci_stop_dma
host
host
if (data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)))					send_stop_abort(host, data);
data->stop ||				    !(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE))
data->stop
data
data
stop
!(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE))
(host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE))
host->data_status & (SDMMC_INT_DRTO |							   SDMMC_INT_EBE)
host->data_status
host
host
data_status
(SDMMC_INT_DRTO |							   SDMMC_INT_EBE)
SDMMC_INT_DRTO |							   SDMMC_INT_EBE
SDMMC_INT_DRTO
SDMMC_INT_DRTO
SDMMC_INT_EBE
SDMMC_INT_EBE
send_stop_abort(host, data);
send_stop_abort(host, data)
send_stop_abort
send_stop_abort
host
host
data
data
state = STATE_DATA_ERROR;
state = STATE_DATA_ERROR
state
state
STATE_DATA_ERROR
STATE_DATA_ERROR
break;
prev_state = state = STATE_DATA_BUSY;
prev_state = state = STATE_DATA_BUSY
prev_state
prev_state
state = STATE_DATA_BUSY
state
state
STATE_DATA_BUSY
STATE_DATA_BUSY
case STATE_DATA_BUSY:
STATE_DATA_BUSY
STATE_DATA_BUSY
if (!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)) {				/*				 * If data error interrupt comes but data over				 * interrupt doesn't come within the given time.				 * in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}
!test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_DATA_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_DATA_COMPLETE
EVENT_DATA_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
{				/*				 * If data error interrupt comes but data over				 * interrupt doesn't come within the given time.				 * in reading data state.				 */				if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);				break;			}
if (host->dir_status == DW_MCI_RECV_STATUS)					dw_mci_set_drto(host);
host->dir_status == DW_MCI_RECV_STATUS
host->dir_status
host
host
dir_status
DW_MCI_RECV_STATUS
DW_MCI_RECV_STATUS
dw_mci_set_drto(host);
dw_mci_set_drto(host)
dw_mci_set_drto
dw_mci_set_drto
host
host
break;
host->data = NULL;
host->data = NULL
host->data
host
host
data
NULL
NULL
set_bit(EVENT_DATA_COMPLETE, &host->completed_events);
set_bit(EVENT_DATA_COMPLETE, &host->completed_events)
set_bit
set_bit
EVENT_DATA_COMPLETE
EVENT_DATA_COMPLETE
&host->completed_events
host->completed_events
host
host
completed_events
err = dw_mci_data_complete(host, data);
err = dw_mci_data_complete(host, data)
err
err
dw_mci_data_complete(host, data)
dw_mci_data_complete
dw_mci_data_complete
host
host
data
data
if (!err) {				if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}				/* stop command for open-ended transfer*/				if (data->stop)					send_stop_abort(host, data);			} else {				/*				 * If we don't have a command complete now we'll				 * never get one since we just reset everything;				 * better end the request.				 *				 * If we do have a command complete we'll fall				 * through to the SENDING_STOP command and				 * everything will be peachy keen.				 */				if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}			}
!err
err
err
{				if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}				/* stop command for open-ended transfer*/				if (data->stop)					send_stop_abort(host, data);			}
if (!data->stop || mrq->sbc) {					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}
!data->stop || mrq->sbc
!data->stop
data->stop
data
data
stop
mrq->sbc
mrq
mrq
sbc
{					if (mrq->sbc && data->stop)						data->stop->error = 0;					dw_mci_request_end(host, mrq);					goto unlock;				}
if (mrq->sbc && data->stop)						data->stop->error = 0;
mrq->sbc && data->stop
mrq->sbc
mrq
mrq
sbc
data->stop
data
data
stop
data->stop->error = 0;
data->stop->error = 0
data->stop->error
data->stop
data
data
stop
error
0
dw_mci_request_end(host, mrq);
dw_mci_request_end(host, mrq)
dw_mci_request_end
dw_mci_request_end
host
host
mrq
mrq
goto unlock;
unlock
if (data->stop)					send_stop_abort(host, data);
data->stop
data
data
stop
send_stop_abort(host, data);
send_stop_abort(host, data)
send_stop_abort
send_stop_abort
host
host
data
data
{				/*				 * If we don't have a command complete now we'll				 * never get one since we just reset everything;				 * better end the request.				 *				 * If we do have a command complete we'll fall				 * through to the SENDING_STOP command and				 * everything will be peachy keen.				 */				if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}			}
if (!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)) {					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}
!test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)
test_bit(EVENT_CMD_COMPLETE,					      &host->pending_events)
test_bit
test_bit
EVENT_CMD_COMPLETE
EVENT_CMD_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
{					host->cmd = NULL;					dw_mci_request_end(host, mrq);					goto unlock;				}
host->cmd = NULL;
host->cmd = NULL
host->cmd
host
host
cmd
NULL
NULL
dw_mci_request_end(host, mrq);
dw_mci_request_end(host, mrq)
dw_mci_request_end
dw_mci_request_end
host
host
mrq
mrq
goto unlock;
unlock
prev_state = state = STATE_SENDING_STOP;
prev_state = state = STATE_SENDING_STOP
prev_state
prev_state
state = STATE_SENDING_STOP
state
state
STATE_SENDING_STOP
STATE_SENDING_STOP
case STATE_SENDING_STOP:
STATE_SENDING_STOP
STATE_SENDING_STOP
if (!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events))				break;
!test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_CMD_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_CMD_COMPLETE
EVENT_CMD_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
break;
if (mrq->cmd->error && mrq->data)				dw_mci_reset(host);
mrq->cmd->error && mrq->data
mrq->cmd->error
mrq->cmd
mrq
mrq
cmd
error
mrq->data
mrq
mrq
data
dw_mci_reset(host);
dw_mci_reset(host)
dw_mci_reset
dw_mci_reset
host
host
host->cmd = NULL;
host->cmd = NULL
host->cmd
host
host
cmd
NULL
NULL
host->data = NULL;
host->data = NULL
host->data
host
host
data
NULL
NULL
if (mrq->stop)				dw_mci_command_complete(host, mrq->stop);			else				host->cmd_status = 0;
mrq->stop
mrq
mrq
stop
dw_mci_command_complete(host, mrq->stop);
dw_mci_command_complete(host, mrq->stop)
dw_mci_command_complete
dw_mci_command_complete
host
host
mrq->stop
mrq
mrq
stop
host->cmd_status = 0;
host->cmd_status = 0
host->cmd_status
host
host
cmd_status
0
dw_mci_request_end(host, mrq);
dw_mci_request_end(host, mrq)
dw_mci_request_end
dw_mci_request_end
host
host
mrq
mrq
goto unlock;
unlock
case STATE_DATA_ERROR:
STATE_DATA_ERROR
STATE_DATA_ERROR
if (!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events))				break;
!test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)
test_and_clear_bit(EVENT_XFER_COMPLETE,						&host->pending_events)
test_and_clear_bit
test_and_clear_bit
EVENT_XFER_COMPLETE
EVENT_XFER_COMPLETE
&host->pending_events
host->pending_events
host
host
pending_events
break;
state = STATE_DATA_BUSY;
state = STATE_DATA_BUSY
state
state
STATE_DATA_BUSY
STATE_DATA_BUSY
break;
state != prev_state
state
state
prev_state
prev_state
host->state = state;
host->state = state
host->state
host
host
state
state
state
unlock:	spin_unlock(&host->lock);
unlock
spin_unlock(&host->lock);
spin_unlock(&host->lock)
spin_unlock
spin_unlock
&host->lock
host->lock
host
host
lock
-----joern-----
(153,217,0)
(309,226,0)
(66,70,0)
(261,11,0)
(141,30,0)
(125,99,0)
(1,41,0)
(403,41,0)
(105,334,0)
(46,315,0)
(155,379,0)
(101,38,0)
(341,296,0)
(23,327,0)
(108,144,0)
(386,41,0)
(287,306,0)
(140,161,0)
(399,196,0)
(305,390,0)
(249,375,0)
(190,41,0)
(363,344,0)
(9,41,0)
(4,68,0)
(381,390,0)
(226,41,0)
(173,207,0)
(87,196,0)
(218,108,0)
(197,154,0)
(76,221,0)
(152,156,0)
(365,6,0)
(85,390,0)
(58,358,0)
(318,256,0)
(343,41,0)
(121,73,0)
(72,41,0)
(179,89,0)
(215,164,0)
(63,307,0)
(24,30,0)
(299,78,0)
(132,113,0)
(38,307,0)
(319,229,0)
(33,201,0)
(270,390,0)
(44,307,0)
(368,283,0)
(401,214,0)
(365,5,0)
(231,307,0)
(361,314,0)
(157,315,0)
(180,84,0)
(214,390,0)
(37,380,0)
(378,65,0)
(322,383,0)
(372,315,0)
(25,8,0)
(340,152,0)
(377,391,0)
(245,392,0)
(217,41,0)
(409,307,0)
(214,41,0)
(204,9,0)
(31,108,0)
(338,390,0)
(118,176,0)
(292,41,0)
(279,106,0)
(117,315,0)
(30,141,0)
(9,236,0)
(392,194,0)
(410,390,0)
(250,263,0)
(260,194,0)
(52,239,0)
(10,53,0)
(236,9,0)
(144,133,0)
(152,41,0)
(196,399,0)
(172,275,0)
(396,320,0)
(246,29,0)
(380,110,0)
(6,178,0)
(380,129,0)
(23,374,0)
(108,31,0)
(296,25,0)
(151,132,0)
(98,244,0)
(365,380,0)
(297,89,0)
(7,286,0)
(368,51,0)
(286,41,0)
(307,315,0)
(371,100,0)
(351,219,0)
(347,144,0)
(57,408,0)
(78,390,0)
(383,307,0)
(150,22,0)
(88,315,0)
(50,72,0)
(223,307,0)
(154,112,0)
(217,56,0)
(227,324,0)
(121,125,0)
(165,73,0)
(111,41,0)
(148,56,0)
(182,113,0)
(387,236,0)
(38,234,0)
(391,307,0)
(288,323,0)
(307,409,0)
(407,5,0)
(303,215,0)
(23,372,0)
(376,11,0)
(386,178,0)
(400,352,0)
(116,357,0)
(192,296,0)
(194,260,0)
(212,298,0)
(33,390,0)
(256,219,0)
(92,176,0)
(411,391,0)
(186,178,0)
(23,5,0)
(268,129,0)
(119,214,0)
(177,203,0)
(221,170,0)
(217,70,0)
(31,337,0)
(188,390,0)
(156,152,0)
(330,64,0)
(161,41,0)
(251,56,0)
(392,41,0)
(237,170,0)
(360,57,0)
(300,390,0)
(398,74,0)
(171,387,0)
(255,390,0)
(275,144,0)
(128,122,0)
(388,256,0)
(94,154,0)
(132,41,0)
(397,63,0)
(292,89,0)
(40,100,0)
(3,239,0)
(131,100,0)
(301,109,0)
(334,303,0)
(137,390,0)
(375,167,0)
(267,133,0)
(334,41,0)
(232,315,0)
(109,301,0)
(291,272,0)
(211,325,0)
(266,73,0)
(365,110,0)
(32,231,0)
(56,144,0)
(380,228,0)
(256,144,0)
(333,390,0)
(203,201,0)
(265,231,0)
(19,390,0)
(332,292,0)
(13,390,0)
(78,110,0)
(365,129,0)
(125,121,0)
(82,190,0)
(244,14,0)
(23,315,0)
(23,129,0)
(391,41,0)
(382,84,0)
(379,41,0)
(181,282,0)
(138,112,0)
(365,248,0)
(367,365,0)
(316,174,0)
(303,334,0)
(337,246,0)
(319,379,0)
(313,109,0)
(234,275,0)
(229,319,0)
(98,41,0)
(352,29,0)
(221,41,0)
(329,144,0)
(395,390,0)
(311,29,0)
(25,296,0)
(74,399,0)
(43,156,0)
(14,262,0)
(202,174,0)
(271,390,0)
(35,203,0)
(80,348,0)
(45,213,0)
(115,390,0)
(403,307,0)
(222,379,0)
(356,383,0)
(353,374,0)
(366,390,0)
(385,275,0)
(81,110,0)
(328,253,0)
(290,41,0)
(104,328,0)
(15,383,0)
(154,144,0)
(141,0,0)
(327,248,0)
(97,390,0)
(324,227,0)
(133,144,0)
(365,374,0)
(247,403,0)
(99,325,0)
(324,41,0)
(11,41,0)
(215,303,0)
(41,315,0)
(359,198,0)
(196,41,0)
(23,228,0)
(167,213,0)
(161,301,0)
(226,47,0)
(243,315,0)
(59,152,0)
(364,6,0)
(274,184,0)
(343,348,0)
(21,390,0)
(23,6,0)
(57,29,0)
(160,215,0)
(31,236,0)
(283,329,0)
(124,408,0)
(63,41,0)
(357,199,0)
(54,3,0)
(113,182,0)
(293,38,0)
(43,315,0)
(133,41,0)
(28,409,0)
(64,41,0)
(357,212,0)
(55,324,0)
(339,29,0)
(191,178,0)
(284,12,0)
(365,327,0)
(224,323,0)
(280,368,0)
(348,390,0)
(23,110,0)
(84,213,0)
(51,368,0)
(258,170,0)
(329,283,0)
(200,41,0)
(91,227,0)
(154,41,0)
(136,390,0)
(253,390,0)
(15,135,0)
(194,392,0)
(212,357,0)
(369,30,0)
(406,408,0)
(220,51,0)
(122,41,0)
(344,363,0)
(166,390,0)
(22,41,0)
(73,307,0)
(391,178,0)
(295,403,0)
(352,358,0)
(325,41,0)
(281,329,0)
(99,125,0)
(304,286,0)
(384,41,0)
(230,68,0)
(365,228,0)
(231,351,0)
(48,98,0)
(51,144,0)
(158,323,0)
(362,390,0)
(389,298,0)
(79,315,0)
(195,198,0)
(110,78,0)
(296,41,0)
(381,374,0)
(262,14,0)
(73,121,0)
(235,374,0)
(60,63,0)
(5,184,0)
(301,161,0)
(147,365,0)
(175,9,0)
(380,237,0)
(176,144,0)
(1,29,0)
(208,170,0)
(365,78,0)
(173,41,0)
(183,182,0)
(145,327,0)
(203,41,0)
(312,14,0)
(317,253,0)
(285,71,0)
(106,272,0)
(365,381,0)
(346,47,0)
(408,57,0)
(27,255,0)
(372,11,0)
(41,190,0)
(12,390,0)
(351,231,0)
(107,228,0)
(114,326,0)
(131,72,0)
(374,381,0)
(239,390,0)
(120,21,0)
(144,315,0)
(102,8,0)
(219,351,0)
(238,390,0)
(162,129,0)
(123,325,0)
(130,169,0)
(248,390,0)
(402,110,0)
(345,409,0)
(72,131,0)
(23,237,0)
(298,212,0)
(302,384,0)
(308,272,0)
(380,6,0)
(311,171,0)
(310,314,0)
(69,200,0)
(49,135,0)
(20,51,0)
(248,327,0)
(142,386,0)
(126,329,0)
(127,182,0)
(358,352,0)
(380,5,0)
(214,144,0)
(283,368,0)
(16,326,0)
(174,405,0)
(294,327,0)
(0,141,0)
(8,25,0)
(9,12,0)
(292,144,0)
(252,380,0)
(210,381,0)
(379,319,0)
(205,392,0)
(156,43,0)
(189,228,0)
(185,311,0)
(298,41,0)
(30,307,0)
(272,106,0)
(77,375,0)
(113,132,0)
(323,224,0)
(323,41,0)
(75,31,0)
(259,290,0)
(409,41,0)
(219,256,0)
(365,237,0)
(109,390,0)
(282,41,0)
(289,33,0)
(71,41,0)
(34,237,0)
(336,169,0)
(349,1,0)
(62,328,0)
(26,237,0)
(169,307,0)
(21,224,0)
(159,372,0)
(8,102,0)
(337,31,0)
(0,131,0)
(95,292,0)
(314,41,0)
(99,326,0)
(275,234,0)
(39,282,0)
(363,207,0)
(365,372,0)
(17,229,0)
(380,327,0)
(260,315,0)
(306,286,0)
(373,246,0)
(380,372,0)
(84,144,0)
(193,387,0)
(387,171,0)
(18,132,0)
(240,1,0)
(61,363,0)
(246,337,0)
(370,196,0)
(325,99,0)
(234,38,0)
(355,387,0)
(36,390,0)
(143,405,0)
(182,127,0)
(233,23,0)
(83,320,0)
(224,21,0)
(169,41,0)
(239,403,0)
(93,390,0)
(384,255,0)
(321,15,0)
(217,314,0)
(163,223,0)
(394,200,0)
(190,216,0)
(29,390,0)
(286,306,0)
(84,41,0)
(134,390,0)
(269,298,0)
(257,5,0)
(282,307,0)
(11,372,0)
(380,65,0)
(328,41,0)
(199,357,0)
(139,248,0)
(201,33,0)
(56,217,0)
(100,131,0)
(129,198,0)
(206,98,0)
(342,315,0)
(174,41,0)
(264,8,0)
(64,198,0)
(103,167,0)
(399,74,0)
(225,226,0)
(276,343,0)
(200,12,0)
(350,390,0)
(22,23,0)
(190,2,0)
(171,311,0)
(106,70,0)
(14,244,0)
(216,190,0)
(201,203,0)
(404,108,0)
(383,15,0)
(131,0,0)
(405,174,0)
(314,217,0)
(380,374,0)
(164,215,0)
(149,343,0)
(375,41,0)
(67,227,0)
(273,334,0)
(29,1,0)
(331,53,0)
(1,236,0)
(241,236,0)
(86,173,0)
(242,22,0)
(408,236,0)
(254,161,0)
(146,384,0)
(168,133,0)
(228,390,0)
(326,99,0)
(227,144,0)
(187,6,0)
(42,315,0)
(403,239,0)
(244,98,0)
(209,223,0)
(354,72,0)
(236,390,0)
(207,363,0)
(90,173,0)
(207,173,0)
(302,146,1)
(131,72,1)
(290,259,1)
(23,110,1)
(84,180,1)
(82,111,1)
(18,183,1)
(141,0,1)
(31,236,1)
(296,192,1)
(282,307,1)
(389,116,1)
(171,387,1)
(189,107,1)
(64,330,1)
(10,306,1)
(286,41,1)
(254,140,1)
(67,55,1)
(332,95,1)
(180,382,1)
(119,324,1)
(139,74,1)
(120,12,1)
(128,405,1)
(210,169,1)
(203,177,1)
(240,339,1)
(339,21,1)
(221,41,1)
(392,41,1)
(69,236,1)
(47,346,1)
(316,164,1)
(8,25,1)
(23,5,1)
(303,334,1)
(224,323,1)
(391,307,1)
(343,276,1)
(33,201,1)
(74,399,1)
(11,41,1)
(11,261,1)
(135,49,1)
(140,313,1)
(388,351,1)
(391,41,1)
(56,148,1)
(9,175,1)
(129,268,1)
(376,159,1)
(169,307,1)
(199,357,1)
(275,172,1)
(193,355,1)
(358,58,1)
(266,221,1)
(351,231,1)
(367,10,1)
(257,352,1)
(277,262,1)
(194,392,1)
(304,199,1)
(311,171,1)
(276,149,1)
(328,41,1)
(173,41,1)
(176,144,1)
(201,203,1)
(298,269,1)
(148,251,1)
(380,5,1)
(132,151,1)
(35,289,1)
(122,41,1)
(160,96,1)
(403,41,1)
(408,406,1)
(17,96,1)
(219,256,1)
(361,153,1)
(73,165,1)
(26,34,1)
(311,29,1)
(223,163,1)
(142,352,1)
(294,139,1)
(49,15,1)
(314,310,1)
(43,156,1)
(317,328,1)
(371,40,1)
(121,125,1)
(328,62,1)
(343,41,1)
(260,194,1)
(72,41,1)
(310,361,1)
(154,144,1)
(105,273,1)
(15,321,1)
(400,57,1)
(398,109,1)
(162,282,1)
(38,307,1)
(91,67,1)
(71,41,1)
(384,302,1)
(122,128,1)
(295,52,1)
(41,190,1)
(380,237,1)
(6,187,1)
(95,234,1)
(169,41,1)
(162,141,1)
(229,319,1)
(292,41,1)
(231,307,1)
(113,132,1)
(30,307,1)
(323,158,1)
(214,144,1)
(241,127,1)
(218,75,1)
(217,314,1)
(106,272,1)
(146,290,1)
(210,102,1)
(126,281,1)
(154,197,1)
(141,30,1)
(234,275,1)
(264,3,1)
(116,229,1)
(20,344,1)
(290,41,1)
(386,41,1)
(220,20,1)
(309,225,1)
(380,252,1)
(103,375,1)
(269,389,1)
(367,335,1)
(334,105,1)
(23,228,1)
(158,288,1)
(61,381,1)
(108,404,1)
(169,336,1)
(367,278,1)
(21,224,1)
(233,22,1)
(337,246,1)
(22,242,1)
(406,124,1)
(261,376,1)
(144,133,1)
(226,41,1)
(244,98,1)
(9,12,1)
(367,195,1)
(292,332,1)
(37,144,1)
(385,219,1)
(143,174,1)
(155,222,1)
(196,41,1)
(99,326,1)
(124,337,1)
(365,78,1)
(104,255,1)
(246,373,1)
(383,356,1)
(87,398,1)
(383,307,1)
(55,176,1)
(168,347,1)
(161,41,1)
(403,247,1)
(29,1,1)
(247,295,1)
(325,41,1)
(314,41,1)
(80,343,1)
(205,188,1)
(380,129,1)
(365,372,1)
(396,122,1)
(377,411,1)
(64,41,1)
(223,307,1)
(149,164,1)
(278,127,1)
(287,286,1)
(379,155,1)
(78,110,1)
(336,130,1)
(396,405,1)
(12,284,1)
(211,123,1)
(30,369,1)
(118,92,1)
(108,144,1)
(341,264,1)
(23,327,1)
(0,131,1)
(73,307,1)
(381,374,1)
(275,144,1)
(94,311,1)
(346,226,1)
(367,134,1)
(365,129,1)
(96,380,1)
(299,311,1)
(219,351,1)
(190,2,1)
(134,96,1)
(318,388,1)
(227,144,1)
(196,370,1)
(265,32,1)
(202,316,1)
(245,205,1)
(177,35,1)
(280,51,1)
(363,207,1)
(372,11,1)
(34,121,1)
(365,381,1)
(283,329,1)
(274,5,1)
(181,39,1)
(292,144,1)
(16,325,1)
(150,365,1)
(367,191,1)
(246,29,1)
(200,394,1)
(27,384,1)
(329,126,1)
(365,6,1)
(231,265,1)
(393,260,1)
(57,360,1)
(308,291,1)
(330,229,1)
(348,80,1)
(131,100,1)
(10,71,1)
(203,41,1)
(301,161,1)
(386,142,1)
(84,144,1)
(307,409,1)
(288,120,1)
(130,223,1)
(7,304,1)
(62,104,1)
(334,41,1)
(321,383,1)
(153,106,1)
(107,262,1)
(191,6,1)
(319,379,1)
(364,391,1)
(268,162,1)
(54,239,1)
(380,372,1)
(380,6,1)
(375,77,1)
(352,358,1)
(100,371,1)
(101,293,1)
(225,176,1)
(251,314,1)
(282,41,1)
(147,367,1)
(365,5,1)
(284,200,1)
(408,236,1)
(352,29,1)
(174,41,1)
(402,81,1)
(190,216,1)
(102,8,1)
(152,340,1)
(327,145,1)
(252,37,1)
(159,43,1)
(380,228,1)
(58,400,1)
(110,402,1)
(369,24,1)
(407,257,1)
(312,96,1)
(204,241,1)
(210,223,1)
(298,41,1)
(45,84,1)
(226,309,1)
(81,299,1)
(23,129,1)
(207,173,1)
(57,408,1)
(23,233,1)
(289,348,1)
(60,397,1)
(22,41,1)
(235,210,1)
(48,312,1)
(61,96,1)
(63,307,1)
(387,236,1)
(324,41,1)
(56,144,1)
(409,345,1)
(248,327,1)
(282,181,1)
(405,143,1)
(52,33,1)
(132,41,1)
(37,365,1)
(59,41,1)
(183,96,1)
(283,368,1)
(212,298,1)
(313,199,1)
(23,372,1)
(281,368,1)
(404,218,1)
(187,364,1)
(285,306,1)
(365,237,1)
(394,69,1)
(205,297,1)
(63,41,1)
(5,407,1)
(324,227,1)
(382,167,1)
(127,182,1)
(367,96,1)
(90,61,1)
(98,206,1)
(367,396,1)
(31,108,1)
(228,189,1)
(92,253,1)
(365,327,1)
(380,110,1)
(401,119,1)
(335,344,1)
(176,118,1)
(214,401,1)
(236,9,1)
(164,215,1)
(242,150,1)
(387,193,1)
(296,41,1)
(353,235,1)
(399,196,1)
(384,41,1)
(262,14,1)
(357,212,1)
(279,337,1)
(272,308,1)
(76,74,1)
(172,385,1)
(84,41,1)
(221,76,1)
(77,249,1)
(163,209,1)
(209,219,1)
(253,317,1)
(24,64,1)
(368,51,1)
(365,248,1)
(166,228,1)
(174,202,1)
(154,41,1)
(391,377,1)
(1,236,1)
(23,237,1)
(347,307,1)
(32,3,1)
(160,248,1)
(173,86,1)
(39,141,1)
(146,283,1)
(57,29,1)
(145,294,1)
(267,168,1)
(215,303,1)
(86,90,1)
(255,27,1)
(34,63,1)
(340,59,1)
(222,17,1)
(14,244,1)
(197,94,1)
(200,41,1)
(365,380,1)
(367,274,1)
(123,73,1)
(71,285,1)
(206,48,1)
(28,44,1)
(356,322,1)
(40,72,1)
(329,144,1)
(208,237,1)
(345,28,1)
(1,41,1)
(373,31,1)
(98,41,1)
(349,240,1)
(38,101,1)
(44,372,1)
(156,152,1)
(365,374,1)
(355,57,1)
(217,41,1)
(380,374,1)
(344,363,1)
(409,41,1)
(75,29,1)
(405,174,1)
(185,171,1)
(306,287,1)
(249,102,1)
(337,31,1)
(133,267,1)
(354,30,1)
(326,114,1)
(165,266,1)
(161,254,1)
(167,103,1)
(205,23,1)
(259,283,1)
(3,239,1)
(367,208,1)
(403,307,1)
(237,26,1)
(205,45,1)
(397,121,1)
(365,147,1)
(1,349,1)
(72,50,1)
(256,318,1)
(190,82,1)
(291,279,1)
(99,325,1)
(138,154,1)
(188,214,1)
(293,275,1)
(217,56,1)
(151,18,1)
(17,78,1)
(152,41,1)
(311,185,1)
(392,245,1)
(23,374,1)
(411,386,1)
(95,135,1)
(367,166,1)
(322,234,1)
(367,277,1)
(51,220,1)
(114,16,1)
(374,353,1)
(175,204,1)
(182,113,1)
(323,41,1)
(133,41,1)
(360,408,1)
(23,6,1)
(63,60,1)
(368,280,1)
(15,383,1)
(205,138,1)
(286,7,1)
(273,160,1)
(297,292,1)
(256,144,1)
(375,41,1)
(121,73,1)
(109,301,1)
(306,286,1)
(214,41,1)
(205,66,1)
(9,41,1)
(365,228,1)
(66,217,1)
(51,144,1)
(3,54,1)
(325,211,1)
(234,38,1)
(125,99,1)
(195,129,1)
(379,41,1)
(50,354,1)
(380,327,1)
(192,341,1)
(25,296,1)
(365,110,1)
(119,47,1)
(239,403,1)
(370,87,1)
(227,91,1)
(171,57,2)
(365,96,2)
(334,41,2)
(282,141,2)
(201,164,2)
(317,344,2)
(246,31,2)
(212,229,2)
(20,344,2)
(311,57,2)
(307,409,2)
(215,74,2)
(324,176,2)
(207,96,2)
(190,216,2)
(229,96,2)
(260,194,2)
(363,96,2)
(293,275,2)
(231,307,2)
(54,164,2)
(234,219,2)
(262,14,2)
(282,41,2)
(143,164,2)
(309,176,2)
(312,96,2)
(185,171,2)
(102,8,2)
(210,102,2)
(155,311,2)
(365,6,2)
(91,176,2)
(207,173,2)
(222,311,2)
(301,199,2)
(10,199,2)
(280,344,2)
(375,41,2)
(399,196,2)
(275,219,2)
(45,102,2)
(353,102,2)
(226,41,2)
(379,96,2)
(147,127,2)
(23,365,2)
(313,199,2)
(318,351,2)
(214,144,2)
(156,152,2)
(217,337,2)
(61,96,2)
(23,374,2)
(365,229,2)
(187,352,2)
(33,164,2)
(164,74,2)
(302,344,2)
(242,365,2)
(193,57,2)
(227,144,2)
(75,127,2)
(182,96,2)
(325,73,2)
(377,352,2)
(204,127,2)
(199,229,2)
(23,110,2)
(337,246,2)
(306,286,2)
(229,319,2)
(357,212,2)
(227,176,2)
(61,102,2)
(166,262,2)
(74,199,2)
(110,311,2)
(268,229,2)
(311,29,2)
(66,337,2)
(73,307,2)
(127,96,2)
(372,11,2)
(31,127,2)
(217,41,2)
(298,229,2)
(148,337,2)
(352,57,2)
(48,96,2)
(69,127,2)
(225,176,2)
(120,127,2)
(337,31,2)
(113,132,2)
(287,199,2)
(365,199,2)
(100,30,2)
(147,199,2)
(23,228,2)
(285,306,2)
(228,262,2)
(323,41,2)
(114,73,2)
(380,129,2)
(109,301,2)
(15,234,2)
(9,12,2)
(403,41,2)
(172,219,2)
(208,74,2)
(365,110,2)
(132,41,2)
(67,176,2)
(306,199,2)
(94,311,2)
(380,110,2)
(361,337,2)
(379,311,2)
(126,368,2)
(405,174,2)
(87,199,2)
(256,144,2)
(244,96,2)
(163,219,2)
(257,352,2)
(86,102,2)
(364,352,2)
(98,41,2)
(23,5,2)
(310,337,2)
(329,144,2)
(288,127,2)
(380,327,2)
(329,368,2)
(173,41,2)
(147,74,2)
(365,344,2)
(99,325,2)
(233,365,2)
(388,351,2)
(358,57,2)
(286,41,2)
(212,298,2)
(81,311,2)
(181,141,2)
(334,74,2)
(387,236,2)
(72,30,2)
(382,102,2)
(289,164,2)
(374,102,2)
(34,74,2)
(63,41,2)
(235,102,2)
(64,229,2)
(5,352,2)
(77,102,2)
(176,344,2)
(291,337,2)
(349,127,2)
(25,3,2)
(1,127,2)
(55,176,2)
(295,164,2)
(411,352,2)
(409,41,2)
(269,229,2)
(40,30,2)
(314,41,2)
(311,171,2)
(374,219,2)
(41,190,2)
(247,164,2)
(164,96,2)
(196,41,2)
(99,326,2)
(304,199,2)
(237,74,2)
(203,164,2)
(402,311,2)
(355,57,2)
(218,127,2)
(64,41,2)
(131,100,2)
(118,344,2)
(206,96,2)
(63,307,2)
(147,96,2)
(365,129,2)
(389,229,2)
(398,199,2)
(363,207,2)
(344,363,2)
(104,344,2)
(197,311,2)
(217,314,2)
(31,236,2)
(403,307,2)
(158,127,2)
(174,164,2)
(121,74,2)
(51,344,2)
(400,57,2)
(147,344,2)
(367,344,2)
(369,229,2)
(86,96,2)
(47,176,2)
(71,41,2)
(314,337,2)
(380,365,2)
(273,96,2)
(57,337,2)
(367,199,2)
(367,229,2)
(0,30,2)
(96,365,2)
(21,127,2)
(121,125,2)
(203,41,2)
(351,3,2)
(18,96,2)
(371,30,2)
(385,219,2)
(133,41,2)
(11,41,2)
(73,74,2)
(319,96,2)
(222,96,2)
(324,227,2)
(368,51,2)
(207,102,2)
(8,25,2)
(49,234,2)
(380,6,2)
(368,344,2)
(147,229,2)
(125,73,2)
(277,262,2)
(365,248,2)
(107,262,2)
(303,96,2)
(86,219,2)
(160,96,2)
(224,127,2)
(108,144,2)
(144,133,2)
(141,30,2)
(284,127,2)
(90,102,2)
(375,102,2)
(72,41,2)
(236,9,2)
(365,372,2)
(132,96,2)
(308,337,2)
(403,164,2)
(380,372,2)
(332,219,2)
(173,102,2)
(283,368,2)
(373,31,2)
(367,96,2)
(365,327,2)
(219,256,2)
(189,262,2)
(180,102,2)
(6,352,2)
(62,344,2)
(3,164,2)
(192,3,2)
(74,399,2)
(239,403,2)
(379,41,2)
(392,41,2)
(290,41,2)
(24,229,2)
(357,229,2)
(328,41,2)
(367,127,2)
(396,164,2)
(194,392,2)
(106,337,2)
(145,74,2)
(380,5,2)
(141,229,2)
(283,344,2)
(248,74,2)
(23,6,2)
(138,311,2)
(299,311,2)
(154,144,2)
(122,405,2)
(383,307,2)
(128,405,2)
(401,344,2)
(328,344,2)
(160,74,2)
(405,164,2)
(354,30,2)
(7,199,2)
(105,74,2)
(344,219,2)
(325,41,2)
(135,234,2)
(21,224,2)
(17,311,2)
(323,127,2)
(153,337,2)
(219,3,2)
(363,102,2)
(171,387,2)
(113,96,2)
(234,275,2)
(30,307,2)
(188,344,2)
(387,57,2)
(169,307,2)
(23,372,2)
(239,164,2)
(363,219,2)
(224,323,2)
(236,127,2)
(161,199,2)
(259,283,2)
(367,57,2)
(29,1,2)
(35,164,2)
(56,337,2)
(356,234,2)
(154,41,2)
(16,73,2)
(131,30,2)
(38,275,2)
(200,41,2)
(12,127,2)
(408,236,2)
(266,74,2)
(292,219,2)
(384,344,2)
(109,199,2)
(196,199,2)
(106,272,2)
(220,344,2)
(292,41,2)
(215,303,2)
(84,144,2)
(52,164,2)
(1,41,2)
(240,127,2)
(343,41,2)
(142,352,2)
(339,127,2)
(131,72,2)
(150,365,2)
(215,96,2)
(177,164,2)
(176,144,2)
(102,3,2)
(292,144,2)
(286,199,2)
(209,219,2)
(39,141,2)
(381,102,2)
(17,96,2)
(190,2,2)
(98,96,2)
(165,74,2)
(22,365,2)
(95,219,2)
(26,74,2)
(324,41,2)
(353,219,2)
(262,96,2)
(147,57,2)
(50,30,2)
(298,41,2)
(404,127,2)
(167,102,2)
(290,283,2)
(141,0,2)
(296,3,2)
(129,229,2)
(116,229,2)
(256,351,2)
(406,337,2)
(195,229,2)
(57,29,2)
(90,219,2)
(407,352,2)
(252,365,2)
(322,234,2)
(63,121,2)
(99,73,2)
(80,164,2)
(282,307,2)
(140,199,2)
(121,73,2)
(51,144,2)
(57,408,2)
(76,74,2)
(174,41,2)
(221,41,2)
(164,215,2)
(58,57,2)
(386,41,2)
(327,74,2)
(183,96,2)
(380,374,2)
(84,41,2)
(229,311,2)
(365,228,2)
(241,127,2)
(147,164,2)
(336,223,2)
(326,73,2)
(343,164,2)
(279,337,2)
(161,41,2)
(399,199,2)
(162,229,2)
(386,352,2)
(365,374,2)
(219,351,2)
(248,327,2)
(29,127,2)
(348,164,2)
(316,164,2)
(14,96,2)
(15,383,2)
(124,337,2)
(275,144,2)
(384,41,2)
(173,219,2)
(276,164,2)
(78,110,2)
(191,352,2)
(214,344,2)
(23,237,2)
(134,96,2)
(272,337,2)
(202,164,2)
(231,3,2)
(56,144,2)
(274,352,2)
(139,74,2)
(341,3,2)
(254,199,2)
(391,41,2)
(303,74,2)
(330,229,2)
(391,307,2)
(122,41,2)
(344,96,2)
(92,344,2)
(105,96,2)
(381,219,2)
(32,3,2)
(253,344,2)
(365,380,2)
(265,3,2)
(25,296,2)
(223,307,2)
(334,96,2)
(397,121,2)
(319,379,2)
(9,41,2)
(125,99,2)
(391,352,2)
(394,127,2)
(223,219,2)
(301,161,2)
(319,311,2)
(146,344,2)
(199,357,2)
(22,41,2)
(249,102,2)
(0,131,2)
(3,239,2)
(78,311,2)
(365,381,2)
(264,3,2)
(200,127,2)
(365,237,2)
(352,358,2)
(207,219,2)
(33,201,2)
(210,219,2)
(321,234,2)
(27,344,2)
(43,156,2)
(127,182,2)
(244,98,2)
(23,327,2)
(108,127,2)
(211,73,2)
(8,3,2)
(283,329,2)
(221,74,2)
(344,102,2)
(30,229,2)
(169,41,2)
(71,306,2)
(278,127,2)
(337,127,2)
(173,96,2)
(169,223,2)
(281,368,2)
(60,121,2)
(294,74,2)
(155,96,2)
(152,41,2)
(101,275,2)
(37,365,2)
(175,127,2)
(365,78,2)
(351,231,2)
(14,244,2)
(367,74,2)
(1,236,2)
(235,219,2)
(365,5,2)
(103,102,2)
(119,344,2)
(251,337,2)
(370,199,2)
(365,164,2)
(408,337,2)
(123,73,2)
(352,29,2)
(381,374,2)
(296,41,2)
(226,176,2)
(38,307,2)
(380,228,2)
(367,164,2)
(130,223,2)
(84,102,2)
(217,56,2)
(360,408,2)
(380,237,2)
(234,38,2)
(346,176,2)
(149,164,2)
(31,108,2)
(201,203,2)
(335,344,2)
(383,234,2)
(255,344,2)
(9,127,2)
(61,219,2)
(23,129,2)
(246,29,2)
(303,334,2)
(214,41,2)
(365,57,2)
(273,74,2)
(365,74,2)
(182,113,2)
(154,311,2)
(151,96,2)
(365,127,2)
(297,219,2)
(90,96,2)
-----------------------------------
(0,!(host->data_status & (SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(1,dw_mci_command_complete(host, cmd)
(2,unsigned long priv)
(3,!err)
(4,if (data->stop)
(5,state = STATE_SENDING_DATA)
(6,state = STATE_SENDING_STOP)
(7,dir_status)
(8,test_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t      &host->pending_events)
(9,host->cmd)
(10,break;)
(11,host->state)
(12,host->cmd = NULL)
(13,case STATE_SENDING_STOP:)
(14,test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(15,data->stop->error)
(16,SDMMC_INT_DRTO)
(17,EVENT_DATA_ERROR)
(18,host)
(19,if (cmd == mrq->sbc && !err)
(20,mrq)
(21,set_bit(EVENT_CMD_COMPLETE, &host->completed_events)
(22,host->state)
(23,host->state = state)
(24,data)
(25,&host->pending_events)
(26,STATE_DATA_ERROR)
(27,NULL)
(28,host)
(29,err = dw_mci_command_complete(host, cmd)
(30,data->stop)
(31,cmd == mrq->sbc)
(32,data)
(33,set_bit(EVENT_DATA_COMPLETE, &host->completed_events)
(34,state)
(35,host)
(36,case STATE_DATA_BUSY:)
(37,prev_state)
(38,data->stop)
(39,host)
(40,SDMMC_INT_DRTO)
(41,*host = (struct dw_mci *)
(42,cmd)
(43,spin_lock(&host->lock)
(44,data)
(45,goto unlock;)
(46,prev_state)
(47,host->cmd_status = 0)
(48,host)
(49,0)
(50,data_status)
(51,mrq->cmd)
(52,err)
(53,)
(54,err)
(55,host)
(56,mrq->cmd)
(57,cmd->data && err)
(58,ETIMEDOUT)
(59,host)
(60,data)
(61,EVENT_CMD_COMPLETE)
(62,data)
(63,send_stop_abort(host, data)
(64,dw_mci_stop_dma(host)
(65,)
(66,goto unlock;)
(67,mrq)
(68,)
(69,host)
(70,)
(71,dw_mci_set_drto(host)
(72,host->data_status)
(73,data->stop)
(74,test_and_clear_bit(EVENT_DATA_ERROR,\n\\n\\t\\t\\t\\t\\t       &host->pending_events)
(75,cmd)
(76,host)
(77,cmd)
(78,prev_state = state = STATE_SENDING_DATA)
(79,do)
(80,NULL)
(81,state)
(82,priv)
(83,if (host->dir_status == DW_MCI_RECV_STATUS)
(84,dw_mci_request_end(host, mrq)
(85,case STATE_WAITING_CMD11_DONE:)
(86,pending_events)
(87,host)
(88,unlock:)
(89,)
(90,host)
(91,stop)
(92,mrq)
(93,case STATE_SENDING_DATA:)
(94,host)
(95,host)
(96,state)
(97,if (!test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(98,host->pending_events)
(99,host->data_status & (SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(100,SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(101,stop)
(102,!test_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t      &host->pending_events)
(103,NULL)
(104,host)
(105,pending_events)
(106,prev_state = state = STATE_SENDING_CMD)
(107,state)
(108,mrq->sbc)
(109,set_bit(EVENT_XFER_COMPLETE, &host->completed_events)
(110,state = STATE_SENDING_DATA)
(111,host)
(112,)
(113,&host->pending_events)
(114,SDMMC_INT_EBE)
(115,case STATE_DATA_ERROR:)
(116,EVENT_XFER_COMPLETE)
(117,mrq)
(118,stop)
(119,host)
(120,EVENT_CMD_COMPLETE)
(121,data->stop ||\n\\n\\t\\t\\t\\t    !(host->data_status & (SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(122,dw_mci_set_drto(host)
(123,host)
(124,cmd)
(125,!(host->data_status & (SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(126,data)
(127,!test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(128,host)
(129,state = STATE_DATA_ERROR)
(130,host)
(131,host->data_status & (SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(132,host->pending_events)
(133,host->mrq)
(134,break;)
(135,data->stop->error = 0)
(136,if (!test_and_clear_bit(EVENT_DATA_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(137,if (!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(138,goto unlock;)
(139,prev_state)
(140,host)
(141,data->stop ||\n\\n\\t\\t\\t\\t    !(host->data_status & (SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(142,host)
(143,DW_MCI_RECV_STATUS)
(144,mrq = host->mrq)
(145,STATE_DATA_BUSY)
(146,host)
(147,prev_state)
(148,cmd)
(149,host)
(150,host)
(151,pending_events)
(152,host->lock)
(153,host)
(154,dw_mci_request_end(host, mrq)
(155,pending_events)
(156,&host->lock)
(157,data)
(158,completed_events)
(159,state)
(160,EVENT_DATA_COMPLETE)
(161,host->completed_events)
(162,state)
(163,stop)
(164,!test_and_clear_bit(EVENT_DATA_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(165,stop)
(166,break;)
(167,host->cmd = NULL)
(168,host)
(169,send_stop_abort(host, data)
(170,)
(171,!cmd->data)
(172,sbc)
(173,host->pending_events)
(174,host->dir_status)
(175,cmd)
(176,mrq->stop)
(177,completed_events)
(178,)
(179,if (mrq->sbc && data->stop)
(180,mrq)
(181,data)
(182,test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(183,EVENT_CMD_COMPLETE)
(184,)
(185,err)
(186,if (err != -ETIMEDOUT)
(187,STATE_SENDING_STOP)
(188,goto unlock;)
(189,STATE_DATA_BUSY)
(190,(struct dw_mci *)
(191,break;)
(192,pending_events)
(193,data)
(194,&host->lock)
(195,break;)
(196,host->pending_events)
(197,mrq)
(198,)
(199,!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(200,host->cmd)
(201,&host->completed_events)
(202,dir_status)
(203,host->completed_events)
(204,host)
(205,host)
(206,pending_events)
(207,&host->pending_events)
(208,break;)
(209,data)
(210,prev_state)
(211,data_status)
(212,&host->pending_events)
(213,)
(214,dw_mci_request_end(host, mrq)
(215,test_and_clear_bit(EVENT_DATA_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(216,struct dw_mci *)
(217,__dw_mci_start_request(host, host->cur_slot,\n\\n\\t\\t\\t\\t\\t\\t       mrq->cmd)
(218,mrq)
(219,!data->stop || mrq->sbc)
(220,cmd)
(221,dw_mci_stop_dma(host)
(222,host)
(223,data->stop)
(224,&host->completed_events)
(225,host)
(226,host->cmd_status)
(227,mrq->stop)
(228,state = STATE_DATA_BUSY)
(229,test_and_clear_bit(EVENT_DATA_ERROR,\n\\n\\t\\t\\t\\t\\t       &host->pending_events)
(230,if (!data->stop || mrq->sbc)
(231,data->stop)
(232,host)
(233,state)
(234,mrq->sbc && data->stop)
(235,state)
(236,cmd = host->cmd)
(237,state = STATE_DATA_ERROR)
(238,if (test_and_clear_bit(EVENT_DATA_ERROR,\n\\n\\t\\t\\t\\t\\t       &host->pending_events)
(239,err = dw_mci_data_complete(host, data)
(240,host)
(241,cmd)
(242,state)
(243,state)
(244,&host->pending_events)
(245,lock)
(246,!err)
(247,data)
(248,prev_state = state = STATE_DATA_BUSY)
(249,host)
(250,if (!test_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t      &host->pending_events)
(251,mrq)
(252,state)
(253,host->data = NULL)
(254,completed_events)
(255,host->cmd = NULL)
(256,mrq->sbc)
(257,state)
(258,if (data->stop ||\n\\n\\t\\t\\t\\t    !(host->data_status & (SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(259,host)
(260,spin_unlock(&host->lock)
(261,state)
(262,!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(263,)
(264,EVENT_CMD_COMPLETE)
(265,stop)
(266,data)
(267,mrq)
(268,STATE_DATA_ERROR)
(269,pending_events)
(270,if (test_and_clear_bit(EVENT_DATA_ERROR,\n\\n\\t\\t\\t\\t\\t       &host->pending_events)
(271,case STATE_SENDING_CMD11:)
(272,state = STATE_SENDING_CMD)
(273,host)
(274,continue;)
(275,mrq->sbc)
(276,data)
(277,break;)
(278,break;)
(279,prev_state)
(280,error)
(281,mrq)
(282,send_stop_abort(host, data)
(283,mrq->cmd->error && mrq->data)
(284,NULL)
(285,host)
(286,host->dir_status)
(287,DW_MCI_RECV_STATUS)
(288,host)
(289,EVENT_DATA_COMPLETE)
(290,dw_mci_reset(host)
(291,state)
(292,dw_mci_request_end(host, mrq)
(293,data)
(294,state)
(295,host)
(296,host->pending_events)
(297,goto unlock;)
(298,host->pending_events)
(299,prev_state)
(300,case STATE_SENDING_CMD:)
(301,&host->completed_events)
(302,cmd)
(303,&host->pending_events)
(304,host)
(305,if (!test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(306,host->dir_status == DW_MCI_RECV_STATUS)
(307,data = host->data)
(308,STATE_SENDING_CMD)
(309,cmd_status)
(310,cur_slot)
(311,!cmd->data || err)
(312,EVENT_XFER_COMPLETE)
(313,EVENT_XFER_COMPLETE)
(314,host->cur_slot)
(315,)
(316,host)
(317,NULL)
(318,sbc)
(319,&host->pending_events)
(320,)
(321,error)
(322,data)
(323,host->completed_events)
(324,dw_mci_command_complete(host, mrq->stop)
(325,host->data_status)
(326,SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(327,state = STATE_DATA_BUSY)
(328,host->data)
(329,mrq->data)
(330,host)
(331,if (host->dir_status == DW_MCI_RECV_STATUS)
(332,mrq)
(333,if (cmd->data && err)
(334,host->pending_events)
(335,break;)
(336,data)
(337,cmd == mrq->sbc && !err)
(338,if (!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(339,err)
(340,lock)
(341,host)
(342,err)
(343,host->data)
(344,!test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(345,data)
(346,0)
(347,mrq)
(348,host->data = NULL)
(349,cmd)
(350,case STATE_IDLE:)
(351,!data->stop)
(352,err != -ETIMEDOUT)
(353,STATE_SENDING_STOP)
(354,host)
(355,cmd)
(356,stop)
(357,test_and_clear_bit(EVENT_XFER_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(358,-ETIMEDOUT)
(359,if (data->stop ||\n\\n\\t\\t\\t\\t    !(host->data_status & (SDMMC_INT_DRTO |\n\\n\\t\\t\\t\\t\\t\\t\\t   SDMMC_INT_EBE)
(360,err)
(361,host)
(362,if (mrq->cmd->error && mrq->data)
(363,test_and_clear_bit(EVENT_CMD_COMPLETE,\n\\n\\t\\t\\t\\t\\t\\t&host->pending_events)
(364,state)
(365,state != prev_state)
(366,if (!err)
(367,state)
(368,mrq->cmd->error)
(369,stop)
(370,pending_events)
(371,SDMMC_INT_EBE)
(372,state = host->state)
(373,err)
(374,state = STATE_SENDING_STOP)
(375,host->cmd)
(376,host)
(377,data)
(378,switch (state)
(379,host->pending_events)
(380,prev_state = state)
(381,prev_state = state = STATE_SENDING_STOP)
(382,host)
(383,data->stop)
(384,host->cmd)
(385,mrq)
(386,dw_mci_stop_dma(host)
(387,cmd->data)
(388,mrq)
(389,host)
(390,)
(391,send_stop_abort(host, data)
(392,host->lock)
(393,RET)
(394,cmd)
(395,if (mrq->stop)
(396,break;)
(397,host)
(398,EVENT_DATA_ERROR)
(399,&host->pending_events)
(400,err)
(401,mrq)
(402,STATE_SENDING_DATA)
(403,dw_mci_data_complete(host, data)
(404,sbc)
(405,host->dir_status == DW_MCI_RECV_STATUS)
(406,data)
(407,STATE_SENDING_DATA)
(408,cmd->data)
(409,host->data)
(410,if (!cmd->data || err)
(411,host)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^