-----label-----
1
-----code-----
static int r600_shader_select(struct pipe_context *ctx,
        struct r600_pipe_shader_selector* sel,
        unsigned *dirty)
{
	struct r600_shader_key key;
	struct r600_context *rctx = (struct r600_context *)ctx;
	struct r600_pipe_shader * shader = NULL;
	int r;

	key = r600_shader_selector_key(ctx, sel);

	/* Check if we don't need to change anything.
	 * This path is also used for most shaders that don't need multiple
	 * variants, it will cost just a computation of the key and this
	 * test. */
	if (likely(sel->current && memcmp(&sel->current->key, &key, sizeof(key)) == 0)) {
		return 0;
	}

	/* lookup if we have other variants in the list */
	if (sel->num_shaders > 1) {
		struct r600_pipe_shader *p = sel->current, *c = p->next_variant;

		while (c && memcmp(&c->key, &key, sizeof(key)) != 0) {
			p = c;
			c = c->next_variant;
		}

		if (c) {
			p->next_variant = c->next_variant;
			shader = c;
		}
	}

	if (unlikely(!shader)) {
		shader = CALLOC(1, sizeof(struct r600_pipe_shader));
		shader->selector = sel;

		r = r600_pipe_shader_create(ctx, shader, key);
		if (unlikely(r)) {
			R600_ERR("Failed to build shader variant (type=%u) %d\n",
				 sel->type, r);
			sel->current = NULL;
			return r;
		}

		/* We don't know the value of nr_ps_max_color_exports until we built
		 * at least one variant, so we may need to recompute the key after
		 * building first variant. */
		if (sel->type == PIPE_SHADER_FRAGMENT &&
				sel->num_shaders == 0) {
			sel->nr_ps_max_color_exports = shader->shader.nr_ps_max_color_exports;
			key = r600_shader_selector_key(ctx, sel);
		}

		shader->key = key;
		sel->num_shaders++;
	}

	if (dirty)
		*dirty = 1;

	shader->next_variant = sel->current;
	sel->current = shader;

	if (rctx->ps_shader &&
	    rctx->cb_misc_state.nr_ps_color_outputs != rctx->ps_shader->current->nr_ps_color_outputs) {
		rctx->cb_misc_state.nr_ps_color_outputs = rctx->ps_shader->current->nr_ps_color_outputs;
		rctx->cb_misc_state.atom.dirty = true;
	}
	return 0;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
6,7
8,9
8,10
11,12
11,13
12,13
14,15
14,16
17,18
17,19
19,20
19,21
22,23
22,24
22,25
22,26
22,27
22,28
22,29
22,30
22,31
22,32
22,33
22,34
22,35
23,24
24,25
24,26
25,26
27,28
29,30
30,31
30,32
31,32
33,34
33,35
33,36
36,37
37,38
37,39
38,39
38,40
39,40
41,42
43,44
45,46
46,47
46,48
47,48
49,50
49,51
49,52
52,53
53,54
55,56
56,57
56,58
58,59
60,61
61,62
61,63
62,63
64,65
64,66
64,67
65,66
67,68
69,70
71,72
71,73
72,73
72,74
73,74
75,76
75,77
76,77
76,78
77,78
80,81
80,82
81,82
81,83
81,84
81,85
82,83
84,85
85,86
85,87
86,87
86,88
87,88
91,92
92,93
94,95
95,96
96,97
99,100
100,101
102,103
102,104
103,104
103,105
104,105
104,106
105,106
109,110
109,111
109,112
110,111
111,112
111,113
111,114
112,113
114,115
114,116
114,117
117,118
118,119
118,120
119,120
122,123
122,124
122,125
125,126
126,127
126,128
127,128
130,131
130,132
131,132
131,133
132,133
134,135
134,136
135,136
135,137
135,138
135,139
136,137
138,139
139,140
139,141
140,141
143,144
144,145
146,147
147,148
148,149
151,152
151,153
152,153
153,154
153,155
154,155
156,157
158,159
159,160
159,161
160,161
162,163
162,164
163,164
166,167
166,168
167,168
169,170
169,171
170,171
171,172
171,173
172,173
172,174
173,174
176,177
176,178
177,178
180,181
181,182
181,183
182,183
184,185
186,187
186,188
187,188
187,189
188,189
190,191
191,192
193,194
193,195
193,196
193,197
193,198
193,199
193,200
194,195
195,196
195,197
196,197
198,199
198,200
198,201
199,200
202,203
203,204
203,205
204,205
207,208
208,209
208,210
209,210
209,211
210,211
213,214
215,216
216,217
216,218
217,218
219,220
219,221
219,222
219,223
220,221
222,223
224,225
226,227
228,229
228,230
229,230
229,231
230,231
232,233
234,235
234,236
234,237
235,236
236,237
236,238
236,239
236,240
237,238
240,241
240,242
241,242
244,245
246,247
247,248
247,249
248,249
248,250
249,250
252,253
254,255
255,256
257,258
257,259
258,259
258,260
259,260
259,261
260,261
260,262
261,262
264,265
266,267
266,268
267,268
267,269
268,269
272,273
272,274
273,274
274,275
274,276
275,276
275,277
276,277
279,280
279,281
280,281
280,282
281,282
285,286
286,287
286,288
287,288
289,290
289,291
289,292
290,291
292,293
294,295
296,297
297,298
297,299
298,299
298,300
299,300
302,303
304,305
305,306
306,307
306,308
307,308
310,311
310,312
311,312
313,314
314,315
314,316
315,316
316,317
319,320
320,321
320,322
321,322
321,323
322,323
325,326
325,327
326,327
329,330
330,331
330,332
331,332
331,333
332,333
335,336
337,338
337,339
338,339
338,340
339,340
339,341
340,341
343,344
343,345
344,345
344,346
345,346
345,347
346,347
350,351
350,352
351,352
351,353
352,353
352,354
353,354
358,359
358,360
359,360
360,361
360,362
361,362
361,363
362,363
362,364
363,364
367,368
367,369
368,369
368,370
369,370
369,371
370,371
375,376
376,377
376,378
377,378
377,379
378,379
378,380
379,380
379,381
380,381
386,387
-----nextToken-----
2,4,7,9,10,13,15,16,18,20,21,26,28,32,34,35,40,42,44,48,50,51,54,57,59,63,66,68,70,74,78,79,83,88,89,90,93,97,98,101,106,107,108,113,115,116,120,121,123,124,128,129,133,137,141,142,145,149,150,155,157,161,164,165,168,174,175,178,179,183,185,189,192,197,200,201,205,206,211,212,214,218,221,223,225,227,231,233,238,239,242,243,245,250,251,253,256,262,263,265,269,270,271,277,278,282,283,284,288,291,293,295,300,301,303,308,309,312,317,318,323,324,327,328,333,334,336,341,342,347,348,349,354,355,356,357,364,365,366,371,372,373,374,381,382,383,384,385,387
-----computeFrom-----
61,62
61,63
75,76
75,77
80,81
80,82
103,104
103,105
131,132
131,133
134,135
134,136
153,154
153,155
159,160
159,161
171,172
171,173
181,182
181,183
195,196
195,197
208,209
208,210
216,217
216,218
247,248
247,249
258,259
258,260
259,260
259,261
266,267
266,268
274,275
274,276
286,287
286,288
297,298
297,299
314,315
314,316
320,321
320,322
330,331
330,332
338,339
338,340
343,344
343,345
360,361
360,362
376,377
376,378
-----guardedBy-----
106,120
269,295
354,381
356,373
357,374
348,382
355,372
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;Pointer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ReturnStatement;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;Declarator;Pointer;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;WhileStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;LiteralExpression;ReturnStatement;LiteralExpression;
-----ast_node-----
static int r600_shader_select(struct pipe_context *ctx,        struct r600_pipe_shader_selector* sel,        unsigned *dirty){	struct r600_shader_key key;	struct r600_context *rctx = (struct r600_context *)ctx;	struct r600_pipe_shader * shader = NULL;	int r;	key = r600_shader_selector_key(ctx, sel);	/* Check if we don't need to change anything.	 * This path is also used for most shaders that don't need multiple	 * variants, it will cost just a computation of the key and this	 * test. */	if (likely(sel->current && memcmp(&sel->current->key, &key, sizeof(key)) == 0)) {		return 0;	}	/* lookup if we have other variants in the list */	if (sel->num_shaders > 1) {		struct r600_pipe_shader *p = sel->current, *c = p->next_variant;		while (c && memcmp(&c->key, &key, sizeof(key)) != 0) {			p = c;			c = c->next_variant;		}		if (c) {			p->next_variant = c->next_variant;			shader = c;		}	}	if (unlikely(!shader)) {		shader = CALLOC(1, sizeof(struct r600_pipe_shader));		shader->selector = sel;		r = r600_pipe_shader_create(ctx, shader, key);		if (unlikely(r)) {			R600_ERR("Failed to build shader variant (type=%u) %d\n",				 sel->type, r);			sel->current = NULL;			return r;		}		/* We don't know the value of nr_ps_max_color_exports until we built		 * at least one variant, so we may need to recompute the key after		 * building first variant. */		if (sel->type == PIPE_SHADER_FRAGMENT &&				sel->num_shaders == 0) {			sel->nr_ps_max_color_exports = shader->shader.nr_ps_max_color_exports;			key = r600_shader_selector_key(ctx, sel);		}		shader->key = key;		sel->num_shaders++;	}	if (dirty)		*dirty = 1;	shader->next_variant = sel->current;	sel->current = shader;	if (rctx->ps_shader &&	    rctx->cb_misc_state.nr_ps_color_outputs != rctx->ps_shader->current->nr_ps_color_outputs) {		rctx->cb_misc_state.nr_ps_color_outputs = rctx->ps_shader->current->nr_ps_color_outputs;		rctx->cb_misc_state.atom.dirty = true;	}	return 0;}
static int
r600_shader_select(struct pipe_context *ctx,        struct r600_pipe_shader_selector* sel,        unsigned *dirty)
r600_shader_select
struct pipe_context *ctx
struct pipe_context
pipe_context
*ctx
*
ctx
struct r600_pipe_shader_selector* sel
struct r600_pipe_shader_selector
r600_pipe_shader_selector
* sel
*
sel
unsigned *dirty
unsigned
*dirty
*
dirty
{	struct r600_shader_key key;	struct r600_context *rctx = (struct r600_context *)ctx;	struct r600_pipe_shader * shader = NULL;	int r;	key = r600_shader_selector_key(ctx, sel);	/* Check if we don't need to change anything.	 * This path is also used for most shaders that don't need multiple	 * variants, it will cost just a computation of the key and this	 * test. */	if (likely(sel->current && memcmp(&sel->current->key, &key, sizeof(key)) == 0)) {		return 0;	}	/* lookup if we have other variants in the list */	if (sel->num_shaders > 1) {		struct r600_pipe_shader *p = sel->current, *c = p->next_variant;		while (c && memcmp(&c->key, &key, sizeof(key)) != 0) {			p = c;			c = c->next_variant;		}		if (c) {			p->next_variant = c->next_variant;			shader = c;		}	}	if (unlikely(!shader)) {		shader = CALLOC(1, sizeof(struct r600_pipe_shader));		shader->selector = sel;		r = r600_pipe_shader_create(ctx, shader, key);		if (unlikely(r)) {			R600_ERR("Failed to build shader variant (type=%u) %d\n",				 sel->type, r);			sel->current = NULL;			return r;		}		/* We don't know the value of nr_ps_max_color_exports until we built		 * at least one variant, so we may need to recompute the key after		 * building first variant. */		if (sel->type == PIPE_SHADER_FRAGMENT &&				sel->num_shaders == 0) {			sel->nr_ps_max_color_exports = shader->shader.nr_ps_max_color_exports;			key = r600_shader_selector_key(ctx, sel);		}		shader->key = key;		sel->num_shaders++;	}	if (dirty)		*dirty = 1;	shader->next_variant = sel->current;	sel->current = shader;	if (rctx->ps_shader &&	    rctx->cb_misc_state.nr_ps_color_outputs != rctx->ps_shader->current->nr_ps_color_outputs) {		rctx->cb_misc_state.nr_ps_color_outputs = rctx->ps_shader->current->nr_ps_color_outputs;		rctx->cb_misc_state.atom.dirty = true;	}	return 0;}
struct r600_shader_key key;
struct r600_shader_key key;
struct r600_shader_key
r600_shader_key
key
key
struct r600_context *rctx = (struct r600_context *)ctx;
struct r600_context *rctx = (struct r600_context *)ctx;
struct r600_context
r600_context
*rctx = (struct r600_context *)ctx
*
rctx
= (struct r600_context *)ctx
(struct r600_context *)ctx
struct r600_context *
struct r600_context
r600_context
*
*
ctx
ctx
struct r600_pipe_shader * shader = NULL;
struct r600_pipe_shader * shader = NULL;
struct r600_pipe_shader
r600_pipe_shader
* shader = NULL
*
shader
= NULL
NULL
NULL
int r;
int r;
int
r
r
key = r600_shader_selector_key(ctx, sel);
key = r600_shader_selector_key(ctx, sel)
key
key
r600_shader_selector_key(ctx, sel)
r600_shader_selector_key
r600_shader_selector_key
ctx
ctx
sel
sel
if (likely(sel->current && memcmp(&sel->current->key, &key, sizeof(key)) == 0)) {		return 0;	}
likely(sel->current && memcmp(&sel->current->key, &key, sizeof(key)) == 0)
likely
likely
sel->current && memcmp(&sel->current->key, &key, sizeof(key)) == 0
sel->current
sel
sel
current
memcmp(&sel->current->key, &key, sizeof(key)) == 0
memcmp(&sel->current->key, &key, sizeof(key))
memcmp
memcmp
&sel->current->key
sel->current->key
sel->current
sel
sel
current
key
&key
key
key
sizeof(key)
(key)
key
key
0
{		return 0;	}
return 0;
0
if (sel->num_shaders > 1) {		struct r600_pipe_shader *p = sel->current, *c = p->next_variant;		while (c && memcmp(&c->key, &key, sizeof(key)) != 0) {			p = c;			c = c->next_variant;		}		if (c) {			p->next_variant = c->next_variant;			shader = c;		}	}
sel->num_shaders > 1
sel->num_shaders
sel
sel
num_shaders
1
{		struct r600_pipe_shader *p = sel->current, *c = p->next_variant;		while (c && memcmp(&c->key, &key, sizeof(key)) != 0) {			p = c;			c = c->next_variant;		}		if (c) {			p->next_variant = c->next_variant;			shader = c;		}	}
struct r600_pipe_shader *p = sel->current, *c = p->next_variant;
struct r600_pipe_shader *p = sel->current, *c = p->next_variant;
struct r600_pipe_shader
r600_pipe_shader
*p = sel->current
*
p
= sel->current
sel->current
sel
sel
current
*c = p->next_variant
*
c
= p->next_variant
p->next_variant
p
p
next_variant
while (c && memcmp(&c->key, &key, sizeof(key)) != 0) {			p = c;			c = c->next_variant;		}
c && memcmp(&c->key, &key, sizeof(key)) != 0
c
c
memcmp(&c->key, &key, sizeof(key)) != 0
memcmp(&c->key, &key, sizeof(key))
memcmp
memcmp
&c->key
c->key
c
c
key
&key
key
key
sizeof(key)
(key)
key
key
0
{			p = c;			c = c->next_variant;		}
p = c;
p = c
p
p
c
c
c = c->next_variant;
c = c->next_variant
c
c
c->next_variant
c
c
next_variant
if (c) {			p->next_variant = c->next_variant;			shader = c;		}
c
c
{			p->next_variant = c->next_variant;			shader = c;		}
p->next_variant = c->next_variant;
p->next_variant = c->next_variant
p->next_variant
p
p
next_variant
c->next_variant
c
c
next_variant
shader = c;
shader = c
shader
shader
c
c
if (unlikely(!shader)) {		shader = CALLOC(1, sizeof(struct r600_pipe_shader));		shader->selector = sel;		r = r600_pipe_shader_create(ctx, shader, key);		if (unlikely(r)) {			R600_ERR("Failed to build shader variant (type=%u) %d\n",				 sel->type, r);			sel->current = NULL;			return r;		}		/* We don't know the value of nr_ps_max_color_exports until we built		 * at least one variant, so we may need to recompute the key after		 * building first variant. */		if (sel->type == PIPE_SHADER_FRAGMENT &&				sel->num_shaders == 0) {			sel->nr_ps_max_color_exports = shader->shader.nr_ps_max_color_exports;			key = r600_shader_selector_key(ctx, sel);		}		shader->key = key;		sel->num_shaders++;	}
unlikely(!shader)
unlikely
unlikely
!shader
shader
shader
{		shader = CALLOC(1, sizeof(struct r600_pipe_shader));		shader->selector = sel;		r = r600_pipe_shader_create(ctx, shader, key);		if (unlikely(r)) {			R600_ERR("Failed to build shader variant (type=%u) %d\n",				 sel->type, r);			sel->current = NULL;			return r;		}		/* We don't know the value of nr_ps_max_color_exports until we built		 * at least one variant, so we may need to recompute the key after		 * building first variant. */		if (sel->type == PIPE_SHADER_FRAGMENT &&				sel->num_shaders == 0) {			sel->nr_ps_max_color_exports = shader->shader.nr_ps_max_color_exports;			key = r600_shader_selector_key(ctx, sel);		}		shader->key = key;		sel->num_shaders++;	}
shader = CALLOC(1, sizeof(struct r600_pipe_shader));
shader = CALLOC(1, sizeof(struct r600_pipe_shader))
shader
shader
CALLOC(1, sizeof(struct r600_pipe_shader))
CALLOC
CALLOC
1
sizeof(struct r600_pipe_shader)
struct r600_pipe_shader
struct r600_pipe_shader
r600_pipe_shader

shader->selector = sel;
shader->selector = sel
shader->selector
shader
shader
selector
sel
sel
r = r600_pipe_shader_create(ctx, shader, key);
r = r600_pipe_shader_create(ctx, shader, key)
r
r
r600_pipe_shader_create(ctx, shader, key)
r600_pipe_shader_create
r600_pipe_shader_create
ctx
ctx
shader
shader
key
key
if (unlikely(r)) {			R600_ERR("Failed to build shader variant (type=%u) %d\n",				 sel->type, r);			sel->current = NULL;			return r;		}
unlikely(r)
unlikely
unlikely
r
r
{			R600_ERR("Failed to build shader variant (type=%u) %d\n",				 sel->type, r);			sel->current = NULL;			return r;		}
R600_ERR("Failed to build shader variant (type=%u) %d\n",				 sel->type, r);
R600_ERR("Failed to build shader variant (type=%u) %d\n",				 sel->type, r)
R600_ERR
R600_ERR
"Failed to build shader variant (type=%u) %d\n"
sel->type
sel
sel
type
r
r
sel->current = NULL;
sel->current = NULL
sel->current
sel
sel
current
NULL
NULL
return r;
r
r
if (sel->type == PIPE_SHADER_FRAGMENT &&				sel->num_shaders == 0) {			sel->nr_ps_max_color_exports = shader->shader.nr_ps_max_color_exports;			key = r600_shader_selector_key(ctx, sel);		}
sel->type == PIPE_SHADER_FRAGMENT &&				sel->num_shaders == 0
sel->type == PIPE_SHADER_FRAGMENT
sel->type
sel
sel
type
PIPE_SHADER_FRAGMENT
PIPE_SHADER_FRAGMENT
sel->num_shaders == 0
sel->num_shaders
sel
sel
num_shaders
0
{			sel->nr_ps_max_color_exports = shader->shader.nr_ps_max_color_exports;			key = r600_shader_selector_key(ctx, sel);		}
sel->nr_ps_max_color_exports = shader->shader.nr_ps_max_color_exports;
sel->nr_ps_max_color_exports = shader->shader.nr_ps_max_color_exports
sel->nr_ps_max_color_exports
sel
sel
nr_ps_max_color_exports
shader->shader.nr_ps_max_color_exports
shader->shader
shader
shader
shader
nr_ps_max_color_exports
key = r600_shader_selector_key(ctx, sel);
key = r600_shader_selector_key(ctx, sel)
key
key
r600_shader_selector_key(ctx, sel)
r600_shader_selector_key
r600_shader_selector_key
ctx
ctx
sel
sel
shader->key = key;
shader->key = key
shader->key
shader
shader
key
key
key
sel->num_shaders++;
sel->num_shaders++
sel->num_shaders
sel
sel
num_shaders
if (dirty)		*dirty = 1;
dirty
dirty
*dirty = 1;
*dirty = 1
*dirty
dirty
dirty
1
shader->next_variant = sel->current;
shader->next_variant = sel->current
shader->next_variant
shader
shader
next_variant
sel->current
sel
sel
current
sel->current = shader;
sel->current = shader
sel->current
sel
sel
current
shader
shader
if (rctx->ps_shader &&	    rctx->cb_misc_state.nr_ps_color_outputs != rctx->ps_shader->current->nr_ps_color_outputs) {		rctx->cb_misc_state.nr_ps_color_outputs = rctx->ps_shader->current->nr_ps_color_outputs;		rctx->cb_misc_state.atom.dirty = true;	}
rctx->ps_shader &&	    rctx->cb_misc_state.nr_ps_color_outputs != rctx->ps_shader->current->nr_ps_color_outputs
rctx->ps_shader
rctx
rctx
ps_shader
rctx->cb_misc_state.nr_ps_color_outputs != rctx->ps_shader->current->nr_ps_color_outputs
rctx->cb_misc_state.nr_ps_color_outputs
rctx->cb_misc_state
rctx
rctx
cb_misc_state
nr_ps_color_outputs
rctx->ps_shader->current->nr_ps_color_outputs
rctx->ps_shader->current
rctx->ps_shader
rctx
rctx
ps_shader
current
nr_ps_color_outputs
{		rctx->cb_misc_state.nr_ps_color_outputs = rctx->ps_shader->current->nr_ps_color_outputs;		rctx->cb_misc_state.atom.dirty = true;	}
rctx->cb_misc_state.nr_ps_color_outputs = rctx->ps_shader->current->nr_ps_color_outputs;
rctx->cb_misc_state.nr_ps_color_outputs = rctx->ps_shader->current->nr_ps_color_outputs
rctx->cb_misc_state.nr_ps_color_outputs
rctx->cb_misc_state
rctx
rctx
cb_misc_state
nr_ps_color_outputs
rctx->ps_shader->current->nr_ps_color_outputs
rctx->ps_shader->current
rctx->ps_shader
rctx
rctx
ps_shader
current
nr_ps_color_outputs
rctx->cb_misc_state.atom.dirty = true;
rctx->cb_misc_state.atom.dirty = true
rctx->cb_misc_state.atom.dirty
rctx->cb_misc_state.atom
rctx->cb_misc_state
rctx
rctx
cb_misc_state
atom
dirty
true
return 0;
0
-----joern-----
(188,134,0)
(138,24,0)
(140,234,0)
(213,141,0)
(6,179,0)
(88,83,0)
(143,170,0)
(136,143,0)
(112,67,0)
(158,48,0)
(11,192,0)
(168,9,0)
(21,202,0)
(173,87,0)
(166,144,0)
(99,176,0)
(109,170,0)
(160,41,0)
(163,46,0)
(117,141,0)
(72,155,0)
(170,233,0)
(94,46,0)
(28,223,0)
(132,127,0)
(38,97,0)
(110,196,0)
(159,124,0)
(147,155,0)
(99,169,0)
(113,120,0)
(68,158,0)
(179,133,0)
(134,188,0)
(224,32,0)
(171,170,0)
(85,139,0)
(180,140,0)
(175,106,0)
(20,118,0)
(39,173,0)
(106,138,0)
(62,220,0)
(25,201,0)
(178,9,0)
(182,222,0)
(61,147,0)
(226,233,0)
(86,147,0)
(58,83,0)
(51,41,0)
(126,28,0)
(97,46,0)
(149,93,0)
(66,169,0)
(203,226,0)
(20,196,0)
(214,62,0)
(222,132,0)
(17,101,0)
(107,8,0)
(173,36,0)
(105,123,0)
(205,17,0)
(190,155,0)
(206,151,0)
(232,186,0)
(149,69,0)
(56,22,0)
(108,50,0)
(8,151,0)
(209,102,0)
(172,124,0)
(179,25,0)
(9,199,0)
(49,103,0)
(209,18,0)
(157,168,0)
(133,141,0)
(111,137,0)
(69,141,0)
(149,225,0)
(26,46,0)
(137,111,0)
(77,24,0)
(127,101,0)
(215,139,0)
(148,191,0)
(170,143,0)
(151,15,0)
(50,54,0)
(212,130,0)
(220,199,0)
(67,234,0)
(140,170,0)
(230,163,0)
(171,133,0)
(74,48,0)
(106,18,0)
(35,12,0)
(154,217,0)
(94,133,0)
(125,25,0)
(132,233,0)
(223,124,0)
(130,15,0)
(144,176,0)
(45,219,0)
(120,86,0)
(19,226,0)
(35,81,0)
(26,192,0)
(5,46,0)
(12,133,0)
(3,163,0)
(27,31,0)
(115,85,0)
(198,158,0)
(217,154,0)
(154,35,0)
(48,141,0)
(169,99,0)
(82,103,0)
(194,28,0)
(202,46,0)
(168,223,0)
(102,15,0)
(155,147,0)
(83,46,0)
(130,116,0)
(60,171,0)
(50,46,0)
(125,134,0)
(187,148,0)
(69,203,0)
(171,219,0)
(97,127,0)
(169,223,0)
(76,141,0)
(163,17,0)
(191,148,0)
(164,171,0)
(134,186,0)
(148,15,0)
(0,220,0)
(205,109,0)
(202,21,0)
(71,33,0)
(196,20,0)
(143,111,0)
(220,223,0)
(153,233,0)
(28,9,0)
(211,12,0)
(54,50,0)
(25,11,0)
(93,219,0)
(74,170,0)
(15,141,0)
(69,163,0)
(146,148,0)
(18,106,0)
(64,140,0)
(84,5,0)
(186,46,0)
(165,26,0)
(69,22,0)
(116,118,0)
(33,120,0)
(12,35,0)
(147,86,0)
(134,125,0)
(185,203,0)
(11,25,0)
(93,123,0)
(73,141,0)
(219,233,0)
(161,130,0)
(220,9,0)
(17,205,0)
(29,74,0)
(55,221,0)
(57,26,0)
(7,62,0)
(155,46,0)
(234,141,0)
(138,106,0)
(5,105,0)
(21,124,0)
(69,85,0)
(204,183,0)
(69,209,0)
(69,51,0)
(70,233,0)
(222,170,0)
(31,21,0)
(131,217,0)
(62,99,0)
(184,45,0)
(13,48,0)
(118,116,0)
(45,123,0)
(51,181,0)
(201,25,0)
(18,227,0)
(127,97,0)
(129,102,0)
(192,11,0)
(25,179,0)
(192,26,0)
(2,31,0)
(122,132,0)
(94,36,0)
(201,133,0)
(47,209,0)
(25,125,0)
(121,141,0)
(228,97,0)
(158,198,0)
(32,219,0)
(30,127,0)
(44,170,0)
(8,85,0)
(207,93,0)
(85,8,0)
(96,186,0)
(9,28,0)
(140,144,0)
(83,58,0)
(15,173,0)
(142,124,0)
(183,35,0)
(144,9,0)
(103,15,0)
(81,35,0)
(171,36,0)
(24,15,0)
(98,21,0)
(69,62,0)
(90,51,0)
(196,103,0)
(23,22,0)
(200,205,0)
(35,154,0)
(111,143,0)
(97,36,0)
(92,109,0)
(217,9,0)
(69,222,0)
(102,209,0)
(140,48,0)
(139,227,0)
(65,45,0)
(62,21,0)
(87,173,0)
(75,201,0)
(119,141,0)
(120,33,0)
(195,15,0)
(151,8,0)
(104,124,0)
(183,133,0)
(74,144,0)
(128,225,0)
(216,219,0)
(89,50,0)
(52,171,0)
(158,144,0)
(234,67,0)
(150,102,0)
(10,192,0)
(152,94,0)
(210,220,0)
(133,94,0)
(229,48,0)
(167,5,0)
(43,202,0)
(173,15,0)
(135,141,0)
(145,105,0)
(59,138,0)
(118,20,0)
(24,138,0)
(74,141,0)
(40,144,0)
(95,203,0)
(4,221,0)
(86,120,0)
(225,197,0)
(162,133,0)
(34,24,0)
(174,69,0)
(103,196,0)
(218,223,0)
(221,45,0)
(37,141,0)
(109,205,0)
(81,168,0)
(22,46,0)
(221,46,0)
(100,222,0)
(53,217,0)
(116,130,0)
(33,46,0)
(169,9,0)
(80,141,0)
(191,118,0)
(208,83,0)
(14,58,0)
(226,46,0)
(144,223,0)
(54,233,0)
(114,33,0)
(22,74,0)
(63,151,0)
(78,191,0)
(35,183,0)
(132,133,0)
(189,81,0)
(217,223,0)
(67,46,0)
(45,221,0)
(1,20,0)
(177,109,0)
(231,67,0)
(91,94,0)
(223,31,0)
(118,191,0)
(219,171,0)
(69,140,0)
(16,125,0)
(203,170,0)
(186,134,0)
(42,202,0)
(168,81,0)
(79,169,0)
(31,223,0)
(145,5,1)
(200,109,1)
(93,219,1)
(102,15,1)
(205,109,1)
(1,196,1)
(166,40,1)
(218,21,1)
(51,181,1)
(15,173,1)
(92,163,1)
(44,198,1)
(217,223,1)
(107,151,1)
(220,9,1)
(179,133,1)
(58,14,1)
(146,187,1)
(155,46,1)
(66,62,1)
(40,99,1)
(8,107,1)
(190,72,1)
(139,215,1)
(69,222,1)
(9,28,1)
(210,0,1)
(191,78,1)
(67,231,1)
(144,223,1)
(47,102,1)
(58,83,1)
(220,223,1)
(171,36,1)
(140,48,1)
(45,65,1)
(79,66,1)
(201,75,1)
(224,219,1)
(41,160,1)
(51,90,1)
(111,137,1)
(50,108,1)
(90,193,1)
(173,36,1)
(78,148,1)
(23,234,1)
(136,44,1)
(173,39,1)
(169,79,1)
(226,46,1)
(28,9,1)
(95,185,1)
(68,156,1)
(16,25,1)
(143,111,1)
(203,95,1)
(35,154,1)
(62,220,1)
(33,46,1)
(8,151,1)
(86,120,1)
(178,220,1)
(103,15,1)
(74,29,1)
(204,12,1)
(203,170,1)
(171,170,1)
(17,205,1)
(13,15,1)
(49,82,1)
(148,15,1)
(32,219,1)
(45,219,1)
(12,211,1)
(11,192,1)
(64,180,1)
(161,74,1)
(128,188,1)
(29,22,1)
(116,130,1)
(198,158,1)
(118,191,1)
(156,168,1)
(138,59,1)
(20,196,1)
(180,193,1)
(151,15,1)
(94,36,1)
(221,46,1)
(42,98,1)
(69,85,1)
(149,93,1)
(62,7,1)
(134,186,1)
(21,202,1)
(168,81,1)
(69,163,1)
(182,86,1)
(154,217,1)
(52,60,1)
(207,105,1)
(19,203,1)
(216,226,1)
(94,152,1)
(57,165,1)
(116,118,1)
(140,64,1)
(149,69,1)
(220,210,1)
(183,133,1)
(18,106,1)
(94,46,1)
(125,25,1)
(165,186,1)
(91,162,1)
(68,144,1)
(177,92,1)
(22,56,1)
(65,221,1)
(74,144,1)
(43,42,1)
(155,190,1)
(189,35,1)
(215,85,1)
(28,223,1)
(174,116,1)
(106,138,1)
(214,156,1)
(25,179,1)
(158,144,1)
(75,179,1)
(26,46,1)
(69,51,1)
(109,170,1)
(182,127,1)
(24,34,1)
(148,146,1)
(6,11,1)
(25,201,1)
(54,50,1)
(206,18,1)
(39,195,1)
(2,218,1)
(169,9,1)
(130,15,1)
(152,91,1)
(196,110,1)
(217,9,1)
(106,175,1)
(138,24,1)
(60,216,1)
(83,46,1)
(196,103,1)
(212,161,1)
(132,127,1)
(162,48,1)
(85,8,1)
(93,207,1)
(193,198,1)
(109,177,1)
(69,174,1)
(69,203,1)
(173,87,1)
(81,189,1)
(205,200,1)
(175,138,1)
(48,229,1)
(147,61,1)
(186,96,1)
(126,178,1)
(14,83,1)
(32,224,1)
(132,133,1)
(83,208,1)
(217,131,1)
(69,22,1)
(168,9,1)
(132,122,1)
(88,188,1)
(118,20,1)
(5,46,1)
(129,116,1)
(26,57,1)
(187,130,1)
(82,191,1)
(232,133,1)
(45,221,1)
(108,89,1)
(67,46,1)
(221,55,1)
(191,148,1)
(69,209,1)
(130,212,1)
(31,21,1)
(157,9,1)
(171,133,1)
(35,12,1)
(219,171,1)
(20,1,1)
(230,3,1)
(158,48,1)
(31,27,1)
(0,168,1)
(30,17,1)
(174,139,1)
(149,225,1)
(186,46,1)
(72,120,1)
(24,15,1)
(169,223,1)
(209,102,1)
(63,206,1)
(168,157,1)
(171,164,1)
(222,170,1)
(188,134,1)
(231,112,1)
(193,54,1)
(134,125,1)
(208,88,1)
(5,84,1)
(234,67,1)
(97,46,1)
(85,115,1)
(131,53,1)
(4,184,1)
(125,16,1)
(71,114,1)
(84,167,1)
(89,132,1)
(223,31,1)
(69,140,1)
(140,170,1)
(27,2,1)
(179,6,1)
(55,4,1)
(99,169,1)
(115,8,1)
(209,47,1)
(102,150,1)
(81,35,1)
(33,71,1)
(12,133,1)
(50,46,1)
(144,166,1)
(201,133,1)
(150,129,1)
(28,194,1)
(228,30,1)
(184,32,1)
(120,33,1)
(183,204,1)
(74,48,1)
(192,26,1)
(163,46,1)
(59,24,1)
(34,77,1)
(211,154,1)
(194,126,1)
(62,21,1)
(35,183,1)
(25,11,1)
(113,33,1)
(96,232,1)
(38,228,1)
(69,62,1)
(222,100,1)
(53,157,1)
(192,10,1)
(74,170,1)
(144,9,1)
(202,43,1)
(22,46,1)
(3,86,1)
(147,155,1)
(7,214,1)
(225,128,1)
(164,52,1)
(120,113,1)
(202,46,1)
(98,58,1)
(226,19,1)
(105,145,1)
(133,94,1)
(127,97,1)
(158,68,1)
(68,58,1)
(185,170,1)
(170,143,1)
(61,155,1)
(180,41,1)
(100,182,1)
(111,136,1)
(122,222,1)
(167,45,1)
(151,63,1)
(112,140,1)
(168,223,1)
(160,51,1)
(97,36,1)
(157,223,1)
(103,49,1)
(56,23,1)
(77,209,1)
(140,144,1)
(86,147,1)
(114,32,1)
(110,103,1)
(97,38,1)
(163,230,1)
(229,13,1)
(10,26,1)
(198,188,2)
(95,198,2)
(102,116,2)
(150,116,2)
(97,46,2)
(116,32,2)
(136,198,2)
(157,168,2)
(211,157,2)
(154,157,2)
(185,198,2)
(86,32,2)
(89,32,2)
(30,86,2)
(112,32,2)
(209,116,2)
(111,198,2)
(187,130,2)
(212,198,2)
(81,157,2)
(116,130,2)
(0,168,2)
(69,85,2)
(33,46,2)
(107,116,2)
(82,130,2)
(28,168,2)
(166,156,2)
(208,188,2)
(158,188,2)
(63,116,2)
(147,120,2)
(53,157,2)
(168,223,2)
(85,116,2)
(158,144,2)
(45,32,2)
(25,179,2)
(42,58,2)
(144,156,2)
(157,58,2)
(170,143,2)
(191,148,2)
(8,151,2)
(140,198,2)
(64,32,2)
(118,191,2)
(32,219,2)
(154,217,2)
(17,86,2)
(149,225,2)
(74,32,2)
(20,196,2)
(196,103,2)
(149,69,2)
(112,198,2)
(94,36,2)
(169,9,2)
(140,144,2)
(201,133,2)
(69,222,2)
(179,186,2)
(138,116,2)
(69,163,2)
(188,134,2)
(69,22,2)
(203,198,2)
(51,193,2)
(193,32,2)
(212,32,2)
(12,133,2)
(19,198,2)
(69,62,2)
(25,201,2)
(148,15,2)
(105,32,2)
(231,198,2)
(151,15,2)
(226,198,2)
(170,198,2)
(88,188,2)
(99,169,2)
(8,116,2)
(31,58,2)
(161,32,2)
(169,223,2)
(43,58,2)
(231,32,2)
(103,15,2)
(130,32,2)
(215,116,2)
(1,130,2)
(226,46,2)
(94,46,2)
(29,198,2)
(83,46,2)
(171,36,2)
(21,202,2)
(99,156,2)
(16,186,2)
(61,120,2)
(168,168,2)
(168,81,2)
(41,193,2)
(196,130,2)
(108,32,2)
(62,156,2)
(209,102,2)
(234,198,2)
(116,198,2)
(146,130,2)
(198,158,2)
(74,170,2)
(132,127,2)
(129,116,2)
(216,198,2)
(116,118,2)
(186,46,2)
(201,186,2)
(138,24,2)
(183,157,2)
(218,58,2)
(86,147,2)
(171,170,2)
(115,116,2)
(109,86,2)
(214,156,2)
(23,32,2)
(230,86,2)
(31,21,2)
(85,8,2)
(69,32,2)
(98,58,2)
(219,171,2)
(10,186,2)
(51,181,2)
(118,130,2)
(64,198,2)
(34,116,2)
(134,125,2)
(93,219,2)
(40,156,2)
(44,198,2)
(151,116,2)
(219,198,2)
(126,168,2)
(11,186,2)
(69,198,2)
(205,109,2)
(175,116,2)
(127,97,2)
(217,9,2)
(69,51,2)
(32,198,2)
(109,170,2)
(25,11,2)
(5,32,2)
(21,58,2)
(35,183,2)
(110,130,2)
(220,9,2)
(50,46,2)
(54,50,2)
(12,157,2)
(204,157,2)
(122,32,2)
(145,32,2)
(130,15,2)
(113,32,2)
(79,156,2)
(179,133,2)
(217,157,2)
(60,198,2)
(193,198,2)
(207,32,2)
(97,86,2)
(75,186,2)
(5,46,2)
(38,86,2)
(178,168,2)
(62,220,2)
(223,31,2)
(160,193,2)
(26,46,2)
(217,223,2)
(132,32,2)
(35,157,2)
(210,168,2)
(189,157,2)
(59,116,2)
(35,12,2)
(77,116,2)
(47,116,2)
(9,28,2)
(62,21,2)
(125,186,2)
(206,116,2)
(174,32,2)
(100,32,2)
(155,120,2)
(67,32,2)
(190,120,2)
(192,186,2)
(203,170,2)
(57,186,2)
(45,219,2)
(234,67,2)
(28,9,2)
(58,83,2)
(130,198,2)
(25,186,2)
(67,46,2)
(106,116,2)
(55,32,2)
(26,186,2)
(177,86,2)
(65,32,2)
(224,198,2)
(22,46,2)
(225,188,2)
(23,198,2)
(174,198,2)
(132,133,2)
(222,170,2)
(202,58,2)
(180,198,2)
(74,198,2)
(164,198,2)
(52,198,2)
(103,130,2)
(81,35,2)
(69,140,2)
(168,9,2)
(205,86,2)
(148,130,2)
(71,32,2)
(2,58,2)
(24,116,2)
(7,156,2)
(202,46,2)
(56,32,2)
(50,32,2)
(27,58,2)
(118,20,2)
(18,106,2)
(133,94,2)
(171,133,2)
(22,198,2)
(22,32,2)
(131,157,2)
(20,130,2)
(184,32,2)
(84,32,2)
(183,133,2)
(163,86,2)
(140,32,2)
(173,87,2)
(74,144,2)
(221,32,2)
(127,86,2)
(144,223,2)
(228,86,2)
(194,168,2)
(144,9,2)
(29,32,2)
(182,32,2)
(220,223,2)
(120,33,2)
(15,173,2)
(149,93,2)
(140,170,2)
(134,186,2)
(54,32,2)
(161,198,2)
(90,193,2)
(191,130,2)
(24,15,2)
(35,154,2)
(192,26,2)
(92,86,2)
(6,186,2)
(167,32,2)
(72,120,2)
(168,58,2)
(69,209,2)
(173,36,2)
(3,86,2)
(223,58,2)
(49,130,2)
(78,130,2)
(140,48,2)
(169,156,2)
(17,205,2)
(158,48,2)
(234,32,2)
(143,198,2)
(120,32,2)
(165,186,2)
(86,120,2)
(102,15,2)
(68,188,2)
(56,198,2)
(125,25,2)
(156,58,2)
(33,32,2)
(221,46,2)
(18,116,2)
(143,111,2)
(220,168,2)
(222,32,2)
(93,32,2)
(69,203,2)
(171,198,2)
(97,36,2)
(128,188,2)
(45,221,2)
(14,188,2)
(4,32,2)
(200,86,2)
(139,116,2)
(66,156,2)
(163,46,2)
(180,32,2)
(114,32,2)
(111,137,2)
(28,223,2)
(106,138,2)
(58,188,2)
(83,188,2)
(11,192,2)
(74,48,2)
(147,155,2)
(9,168,2)
(155,46,2)
(67,198,2)
-----------------------------------
(0,p)
(1,nr_ps_color_outputs)
(2,p)
(3,sel)
(4,sel)
(5,sel->current)
(6,key)
(7,next_variant)
(8,rctx->cb_misc_state.atom)
(9,c = c->next_variant)
(10,key)
(11,&sel->current->key)
(12,&key)
(13,shader)
(14,1)
(15,*rctx = (struct r600_context *)
(16,0)
(17,sel->nr_ps_max_color_exports = shader->shader.nr_ps_max_color_exports)
(18,rctx->cb_misc_state.nr_ps_color_outputs = rctx->ps_shader->current->nr_ps_color_outputs)
(19,sel)
(20,rctx->ps_shader->current->nr_ps_color_outputs)
(21,*p = sel->current)
(22,sel->current)
(23,sel)
(24,rctx->ps_shader)
(25,memcmp(&sel->current->key, &key, sizeof(key)
(26,sel->current)
(27,next_variant)
(28,c->next_variant)
(29,shader)
(30,key)
(31,p->next_variant)
(32,unlikely(r)
(33,sel->type)
(34,ps_shader)
(35,memcmp(&c->key, &key, sizeof(key)
(36,struct pipe_context *ctx)
(37,if (unlikely(!shader)
(38,sel)
(39,ctx)
(40,shader)
(41,*dirty = 1)
(42,sel)
(43,current)
(44,shader)
(45,R600_ERR("Failed to build shader variant (type=%u)
(46,struct r600_pipe_shader_selector* sel)
(47,nr_ps_color_outputs)
(48,* shader = NULL)
(49,ps_shader)
(50,sel->num_shaders)
(51,*dirty)
(52,shader)
(53,c)
(54,sel->num_shaders++)
(55,type)
(56,current)
(57,current)
(58,sel->num_shaders > 1)
(59,current)
(60,ctx)
(61,0)
(62,p->next_variant)
(63,cb_misc_state)
(64,next_variant)
(65,r)
(66,c)
(67,sel->current)
(68,shader)
(69,return 0;)
(70,if (unlikely(r)
(71,type)
(72,sel)
(73,rctx)
(74,sel->current = shader)
(75,key)
(76,if (sel->num_shaders > 1)
(77,rctx)
(78,nr_ps_color_outputs)
(79,next_variant)
(80,r)
(81,memcmp(&c->key, &key, sizeof(key)
(82,rctx)
(83,sel->num_shaders)
(84,current)
(85,rctx->cb_misc_state.atom.dirty)
(86,sel->type == PIPE_SHADER_FRAGMENT &&\n\\n\\t\\t\\t\\tsel->num_shaders == 0)
(87,struct r600_context *)
(88,sel)
(89,sel)
(90,dirty)
(91,ctx)
(92,shader)
(93,return r;)
(94,r600_shader_selector_key(ctx, sel)
(95,selector)
(96,current)
(97,r600_shader_selector_key(ctx, sel)
(98,p)
(99,p->next_variant = c->next_variant)
(100,key)
(101,)
(102,rctx->cb_misc_state)
(103,rctx->ps_shader)
(104,p)
(105,sel->current = NULL)
(106,rctx->ps_shader->current->nr_ps_color_outputs)
(107,atom)
(108,num_shaders)
(109,shader->shader)
(110,current)
(111,sizeof(struct r600_pipe_shader)
(112,sel)
(113,PIPE_SHADER_FRAGMENT)
(114,sel)
(115,dirty)
(116,rctx->ps_shader &&\n\\n\\t    rctx->cb_misc_state.nr_ps_color_outputs != rctx->ps_shader->current->nr_ps_color_outputs)
(117,key)
(118,rctx->cb_misc_state.nr_ps_color_outputs != rctx->ps_shader->current->nr_ps_color_outputs)
(119,if (dirty)
(120,sel->type == PIPE_SHADER_FRAGMENT)
(121,if (likely(sel->current && memcmp(&sel->current->key, &key, sizeof(key)
(122,key)
(123,)
(124,)
(125,memcmp(&sel->current->key, &key, sizeof(key)
(126,c)
(127,key = r600_shader_selector_key(ctx, sel)
(128,0)
(129,rctx)
(130,rctx->ps_shader)
(131,key)
(132,shader->key = key)
(133,key = r600_shader_selector_key(ctx, sel)
(134,sel->current && memcmp(&sel->current->key, &key, sizeof(key)
(135,if (rctx->ps_shader &&\n\\n\\t    rctx->cb_misc_state.nr_ps_color_outputs != rctx->ps_shader->current->nr_ps_color_outputs)
(136,1)
(137,struct r600_pipe_shader)
(138,rctx->ps_shader->current)
(139,rctx->cb_misc_state.atom.dirty = true)
(140,shader->next_variant)
(141,)
(142,while (c && memcmp(&c->key, &key, sizeof(key)
(143,CALLOC(1, sizeof(struct r600_pipe_shader)
(144,shader = c)
(145,NULL)
(146,cb_misc_state)
(147,sel->num_shaders == 0)
(148,rctx->cb_misc_state)
(149,RET)
(150,cb_misc_state)
(151,rctx->cb_misc_state)
(152,sel)
(153,if (sel->type == PIPE_SHADER_FRAGMENT &&\n\\n\\t\\t\\t\\tsel->num_shaders == 0)
(154,&c->key)
(155,sel->num_shaders)
(156,c)
(157,c)
(158,!shader)
(159,c)
(160,1)
(161,rctx)
(162,key)
(163,sel->nr_ps_max_color_exports)
(164,key)
(165,sel)
(166,c)
(167,sel)
(168,c && memcmp(&c->key, &key, sizeof(key)
(169,c->next_variant)
(170,shader = CALLOC(1, sizeof(struct r600_pipe_shader)
(171,r600_pipe_shader_create(ctx, shader, key)
(172,if (c)
(173,(struct r600_context *)
(174,0)
(175,nr_ps_color_outputs)
(176,)
(177,shader)
(178,c)
(179,&key)
(180,shader)
(181,unsigned *dirty)
(182,shader)
(183,sizeof(key)
(184,"Failed to build shader variant (type=%u)
(185,shader)
(186,sel->current)
(187,rctx)
(188,likely(sel->current && memcmp(&sel->current->key, &key, sizeof(key)
(189,0)
(190,num_shaders)
(191,rctx->cb_misc_state.nr_ps_color_outputs)
(192,sel->current->key)
(193,dirty)
(194,next_variant)
(195,rctx)
(196,rctx->ps_shader->current)
(197,)
(198,unlikely(!shader)
(199,)
(200,nr_ps_max_color_exports)
(201,sizeof(key)
(202,sel->current)
(203,shader->selector)
(204,key)
(205,shader->shader.nr_ps_max_color_exports)
(206,rctx)
(207,r)
(208,num_shaders)
(209,rctx->cb_misc_state.nr_ps_color_outputs)
(210,c)
(211,key)
(212,ps_shader)
(213,shader)
(214,p)
(215,true)
(216,r)
(217,c->key)
(218,c)
(219,r = r600_pipe_shader_create(ctx, shader, key)
(220,p = c)
(221,sel->type)
(222,shader->key)
(223,*c = p->next_variant)
(224,r)
(225,return 0;)
(226,shader->selector = sel)
(227,)
(228,ctx)
(229,NULL)
(230,nr_ps_max_color_exports)
(231,current)
(232,sel)
(233,)
(234,shader->next_variant = sel->current)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^