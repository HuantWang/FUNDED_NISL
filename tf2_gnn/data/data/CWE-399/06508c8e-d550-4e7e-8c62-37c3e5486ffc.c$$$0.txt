-----label-----
1
-----code-----
static int loop_thread(void *data)
{
	struct loop_device *lo = data;
	struct bio *bio;

	set_user_nice(current, MIN_NICE);

	while (!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)) {

		wait_event_interruptible(lo->lo_event,
				!bio_list_empty(&lo->lo_bio_list) ||
				kthread_should_stop());

		if (bio_list_empty(&lo->lo_bio_list))
			continue;
		spin_lock_irq(&lo->lo_lock);
		bio = loop_get_bio(lo);
		if (lo->lo_bio_count < lo->lo_queue->nr_congestion_off)
			wake_up(&lo->lo_req_wait);
		spin_unlock_irq(&lo->lo_lock);

		BUG_ON(!bio);
		loop_handle_bio(lo, bio);
	}

	return 0;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
7,9
10,11
10,12
10,13
10,14
10,15
11,12
12,13
12,14
13,14
15,16
15,17
15,18
18,19
19,20
21,22
22,23
22,24
23,24
25,26
25,27
28,29
29,30
29,31
29,32
30,31
32,33
34,35
36,37
36,38
37,38
37,39
38,39
39,40
40,41
42,43
43,44
43,45
44,45
46,47
47,48
47,49
48,49
51,52
51,53
51,54
51,55
51,56
51,57
51,58
51,59
52,53
53,54
53,55
53,56
54,55
56,57
56,58
57,58
60,61
60,62
61,62
62,63
62,64
63,64
65,66
66,67
66,68
67,68
70,71
71,72
73,74
73,75
74,75
74,76
75,76
77,78
78,79
78,80
79,80
83,84
84,85
84,86
85,86
87,88
88,89
88,90
89,90
92,93
93,94
93,95
94,95
96,97
96,98
97,98
99,100
101,102
101,103
102,103
102,104
103,104
103,105
104,105
107,108
107,109
108,109
108,110
109,110
113,114
114,115
114,116
115,116
117,118
118,119
118,120
119,120
122,123
123,124
123,125
124,125
126,127
127,128
127,129
128,129
131,132
132,133
132,134
133,134
135,136
136,137
138,139
139,140
139,141
139,142
140,141
142,143
144,145
146,147
-----nextToken-----
2,4,6,8,9,14,16,17,20,24,26,27,31,33,35,41,45,49,50,55,58,59,64,68,69,72,76,80,81,82,86,90,91,95,98,100,105,106,110,111,112,116,120,121,125,129,130,134,137,141,143,145,147
-----computeFrom-----
37,38
37,39
60,61
60,62
93,94
93,95
102,103
102,104
-----guardedBy-----
110,120
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;WhileStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ContinueStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
static int loop_thread(void *data){	struct loop_device *lo = data;	struct bio *bio;	set_user_nice(current, MIN_NICE);	while (!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)) {		wait_event_interruptible(lo->lo_event,				!bio_list_empty(&lo->lo_bio_list) ||				kthread_should_stop());		if (bio_list_empty(&lo->lo_bio_list))			continue;		spin_lock_irq(&lo->lo_lock);		bio = loop_get_bio(lo);		if (lo->lo_bio_count < lo->lo_queue->nr_congestion_off)			wake_up(&lo->lo_req_wait);		spin_unlock_irq(&lo->lo_lock);		BUG_ON(!bio);		loop_handle_bio(lo, bio);	}	return 0;}
static int
loop_thread(void *data)
loop_thread
void *data
void
*data
*
data
{	struct loop_device *lo = data;	struct bio *bio;	set_user_nice(current, MIN_NICE);	while (!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)) {		wait_event_interruptible(lo->lo_event,				!bio_list_empty(&lo->lo_bio_list) ||				kthread_should_stop());		if (bio_list_empty(&lo->lo_bio_list))			continue;		spin_lock_irq(&lo->lo_lock);		bio = loop_get_bio(lo);		if (lo->lo_bio_count < lo->lo_queue->nr_congestion_off)			wake_up(&lo->lo_req_wait);		spin_unlock_irq(&lo->lo_lock);		BUG_ON(!bio);		loop_handle_bio(lo, bio);	}	return 0;}
struct loop_device *lo = data;
struct loop_device *lo = data;
struct loop_device
loop_device
*lo = data
*
lo
= data
data
data
struct bio *bio;
struct bio *bio;
struct bio
bio
*bio
*
bio
set_user_nice(current, MIN_NICE);
set_user_nice(current, MIN_NICE)
set_user_nice
set_user_nice
current
current
MIN_NICE
MIN_NICE
while (!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)) {		wait_event_interruptible(lo->lo_event,				!bio_list_empty(&lo->lo_bio_list) ||				kthread_should_stop());		if (bio_list_empty(&lo->lo_bio_list))			continue;		spin_lock_irq(&lo->lo_lock);		bio = loop_get_bio(lo);		if (lo->lo_bio_count < lo->lo_queue->nr_congestion_off)			wake_up(&lo->lo_req_wait);		spin_unlock_irq(&lo->lo_lock);		BUG_ON(!bio);		loop_handle_bio(lo, bio);	}
!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)
!kthread_should_stop()
kthread_should_stop()
kthread_should_stop
kthread_should_stop
!bio_list_empty(&lo->lo_bio_list)
bio_list_empty(&lo->lo_bio_list)
bio_list_empty
bio_list_empty
&lo->lo_bio_list
lo->lo_bio_list
lo
lo
lo_bio_list
{		wait_event_interruptible(lo->lo_event,				!bio_list_empty(&lo->lo_bio_list) ||				kthread_should_stop());		if (bio_list_empty(&lo->lo_bio_list))			continue;		spin_lock_irq(&lo->lo_lock);		bio = loop_get_bio(lo);		if (lo->lo_bio_count < lo->lo_queue->nr_congestion_off)			wake_up(&lo->lo_req_wait);		spin_unlock_irq(&lo->lo_lock);		BUG_ON(!bio);		loop_handle_bio(lo, bio);	}
wait_event_interruptible(lo->lo_event,				!bio_list_empty(&lo->lo_bio_list) ||				kthread_should_stop());
wait_event_interruptible(lo->lo_event,				!bio_list_empty(&lo->lo_bio_list) ||				kthread_should_stop())
wait_event_interruptible
wait_event_interruptible
lo->lo_event
lo
lo
lo_event
!bio_list_empty(&lo->lo_bio_list) ||				kthread_should_stop()
!bio_list_empty(&lo->lo_bio_list)
bio_list_empty(&lo->lo_bio_list)
bio_list_empty
bio_list_empty
&lo->lo_bio_list
lo->lo_bio_list
lo
lo
lo_bio_list
kthread_should_stop()
kthread_should_stop
kthread_should_stop
if (bio_list_empty(&lo->lo_bio_list))			continue;
bio_list_empty(&lo->lo_bio_list)
bio_list_empty
bio_list_empty
&lo->lo_bio_list
lo->lo_bio_list
lo
lo
lo_bio_list
continue;
spin_lock_irq(&lo->lo_lock);
spin_lock_irq(&lo->lo_lock)
spin_lock_irq
spin_lock_irq
&lo->lo_lock
lo->lo_lock
lo
lo
lo_lock
bio = loop_get_bio(lo);
bio = loop_get_bio(lo)
bio
bio
loop_get_bio(lo)
loop_get_bio
loop_get_bio
lo
lo
if (lo->lo_bio_count < lo->lo_queue->nr_congestion_off)			wake_up(&lo->lo_req_wait);
lo->lo_bio_count < lo->lo_queue->nr_congestion_off
lo->lo_bio_count
lo
lo
lo_bio_count
lo->lo_queue->nr_congestion_off
lo->lo_queue
lo
lo
lo_queue
nr_congestion_off
wake_up(&lo->lo_req_wait);
wake_up(&lo->lo_req_wait)
wake_up
wake_up
&lo->lo_req_wait
lo->lo_req_wait
lo
lo
lo_req_wait
spin_unlock_irq(&lo->lo_lock);
spin_unlock_irq(&lo->lo_lock)
spin_unlock_irq
spin_unlock_irq
&lo->lo_lock
lo->lo_lock
lo
lo
lo_lock
BUG_ON(!bio);
BUG_ON(!bio)
BUG_ON
BUG_ON
!bio
bio
bio
loop_handle_bio(lo, bio);
loop_handle_bio(lo, bio)
loop_handle_bio
loop_handle_bio
lo
lo
bio
bio
return 0;
0
-----joern-----
(69,30,0)
(33,25,0)
(36,40,0)
(14,65,0)
(68,34,0)
(34,54,0)
(12,54,0)
(11,38,0)
(45,28,0)
(77,40,0)
(73,61,0)
(66,13,0)
(76,19,0)
(16,41,0)
(42,1,0)
(75,77,0)
(72,76,0)
(43,61,0)
(58,71,0)
(27,6,0)
(19,76,0)
(10,71,0)
(37,52,0)
(5,40,0)
(5,67,0)
(30,64,0)
(51,54,0)
(41,16,0)
(49,13,0)
(57,32,0)
(59,64,0)
(64,30,0)
(28,36,0)
(6,22,0)
(65,14,0)
(31,71,0)
(77,75,0)
(3,75,0)
(74,40,0)
(16,21,0)
(1,54,0)
(8,52,0)
(23,54,0)
(25,54,0)
(22,39,0)
(74,57,0)
(67,34,0)
(39,61,0)
(64,54,0)
(35,33,0)
(6,27,0)
(51,38,0)
(41,54,0)
(2,30,0)
(28,30,0)
(50,33,0)
(13,71,0)
(20,25,0)
(38,51,0)
(72,1,0)
(57,74,0)
(18,2,0)
(26,40,0)
(32,54,0)
(52,77,0)
(2,54,0)
(12,35,0)
(46,12,0)
(54,71,0)
(75,3,0)
(39,22,0)
(21,16,0)
(19,75,0)
(61,54,0)
(75,19,0)
(52,54,0)
(44,32,0)
(77,52,0)
(7,41,0)
(54,9,0)
(24,54,0)
(27,65,0)
(29,31,0)
(61,39,0)
(63,34,0)
(36,28,0)
(56,40,0)
(34,67,0)
(65,27,0)
(62,12,0)
(67,5,0)
(70,51,0)
(38,11,0)
(47,51,0)
(60,71,0)
(55,1,0)
(32,57,0)
(22,6,0)
(4,2,0)
(25,33,0)
(2,40,0)
(33,35,0)
(17,41,0)
(15,31,0)
(35,12,0)
(76,72,0)
(53,32,0)
(48,25,0)
(1,72,0)
(30,40,0)
(54,9,1)
(29,15,1)
(66,13,1)
(61,73,1)
(53,44,1)
(52,8,1)
(14,2,1)
(25,54,1)
(32,53,1)
(46,30,1)
(8,37,1)
(38,51,1)
(12,62,1)
(27,6,1)
(77,52,1)
(20,48,1)
(32,54,1)
(7,17,1)
(28,30,1)
(49,27,1)
(0,21,1)
(30,64,1)
(23,24,1)
(6,22,1)
(35,33,1)
(18,4,1)
(14,0,1)
(63,21,1)
(37,27,1)
(44,11,1)
(22,39,1)
(51,47,1)
(21,16,1)
(1,54,1)
(28,45,1)
(72,1,1)
(75,3,1)
(47,70,1)
(70,35,1)
(44,35,1)
(2,54,1)
(12,54,1)
(2,18,1)
(54,23,1)
(33,50,1)
(50,25,1)
(75,19,1)
(13,49,1)
(76,72,1)
(65,14,1)
(1,42,1)
(5,67,1)
(39,61,1)
(34,68,1)
(57,32,1)
(68,63,1)
(34,54,1)
(64,54,1)
(74,57,1)
(61,54,1)
(69,5,1)
(55,52,1)
(14,31,1)
(17,77,1)
(15,54,1)
(4,36,1)
(77,75,1)
(2,30,1)
(48,12,1)
(11,38,1)
(41,7,1)
(42,55,1)
(35,12,1)
(41,54,1)
(64,59,1)
(27,65,1)
(31,29,1)
(59,69,1)
(45,74,1)
(16,41,1)
(52,54,1)
(67,34,1)
(33,25,1)
(43,65,1)
(3,19,1)
(73,43,1)
(62,46,1)
(19,76,1)
(51,54,1)
(25,20,1)
(36,28,1)
(4,21,2)
(45,21,2)
(20,21,2)
(5,21,2)
(64,21,2)
(39,61,2)
(25,21,2)
(19,27,2)
(0,21,2)
(74,57,2)
(21,16,2)
(35,21,2)
(65,14,2)
(25,54,2)
(46,21,2)
(8,27,2)
(43,65,2)
(12,21,2)
(33,21,2)
(7,27,2)
(33,25,2)
(36,21,2)
(6,65,2)
(63,21,2)
(19,76,2)
(76,72,2)
(34,54,2)
(62,21,2)
(44,21,2)
(48,21,2)
(11,38,2)
(2,54,2)
(22,65,2)
(52,54,2)
(77,75,2)
(76,27,2)
(28,21,2)
(72,27,2)
(75,3,2)
(30,21,2)
(38,51,2)
(72,1,2)
(75,27,2)
(14,27,2)
(53,21,2)
(11,35,2)
(52,27,2)
(36,28,2)
(61,54,2)
(38,35,2)
(27,6,2)
(74,21,2)
(42,27,2)
(34,21,2)
(70,35,2)
(1,27,2)
(68,21,2)
(32,21,2)
(16,41,2)
(55,27,2)
(57,21,2)
(22,39,2)
(61,65,2)
(77,27,2)
(27,27,2)
(27,65,2)
(77,52,2)
(18,21,2)
(51,35,2)
(32,54,2)
(17,27,2)
(65,27,2)
(59,21,2)
(67,34,2)
(41,54,2)
(6,22,2)
(3,19,2)
(57,32,2)
(30,64,2)
(16,27,2)
(21,27,2)
(41,27,2)
(54,9,2)
(35,12,2)
(39,65,2)
(2,21,2)
(2,30,2)
(12,54,2)
(75,19,2)
(51,54,2)
(37,27,2)
(73,65,2)
(28,30,2)
(50,21,2)
(67,21,2)
(35,33,2)
(5,67,2)
(69,21,2)
(1,54,2)
(66,13,2)
(47,35,2)
(64,54,2)
-----------------------------------
(0,continue;)
(1,lo->lo_bio_list)
(2,loop_handle_bio(lo, bio)
(3,kthread_should_stop()
(4,lo)
(5,spin_lock_irq(&lo->lo_lock)
(6,!bio_list_empty(&lo->lo_bio_list)
(7,lo_bio_list)
(8,lo_event)
(9,void *data)
(10,bio)
(11,wake_up(&lo->lo_req_wait)
(12,lo->lo_bio_count)
(13,return 0;)
(14,kthread_should_stop()
(15,current)
(16,&lo->lo_bio_list)
(17,lo)
(18,bio)
(19,!bio_list_empty(&lo->lo_bio_list)
(20,lo_queue)
(21,bio_list_empty(&lo->lo_bio_list)
(22,bio_list_empty(&lo->lo_bio_list)
(23,data)
(24,lo)
(25,lo->lo_queue)
(26,if (bio_list_empty(&lo->lo_bio_list)
(27,!kthread_should_stop()
(28,!bio)
(29,MIN_NICE)
(30,bio = loop_get_bio(lo)
(31,set_user_nice(current, MIN_NICE)
(32,lo->lo_lock)
(33,lo->lo_queue->nr_congestion_off)
(34,lo->lo_lock)
(35,lo->lo_bio_count < lo->lo_queue->nr_congestion_off)
(36,BUG_ON(!bio)
(37,lo)
(38,&lo->lo_req_wait)
(39,&lo->lo_bio_list)
(40,)
(41,lo->lo_bio_list)
(42,lo_bio_list)
(43,lo)
(44,lo)
(45,bio)
(46,lo)
(47,lo_req_wait)
(48,lo)
(49,0)
(50,nr_congestion_off)
(51,lo->lo_req_wait)
(52,lo->lo_event)
(53,lo_lock)
(54,*lo = data)
(55,lo)
(56,if (lo->lo_bio_count < lo->lo_queue->nr_congestion_off)
(57,&lo->lo_lock)
(58,lo)
(59,lo)
(60,while (!kthread_should_stop()
(61,lo->lo_bio_list)
(62,lo_bio_count)
(63,lo)
(64,loop_get_bio(lo)
(65,!kthread_should_stop()
(66,RET)
(67,&lo->lo_lock)
(68,lo_lock)
(69,bio)
(70,lo)
(71,)
(72,&lo->lo_bio_list)
(73,lo_bio_list)
(74,spin_unlock_irq(&lo->lo_lock)
(75,!bio_list_empty(&lo->lo_bio_list)
(76,bio_list_empty(&lo->lo_bio_list)
(77,wait_event_interruptible(lo->lo_event,\n\\n\\t\\t\\t\\t!bio_list_empty(&lo->lo_bio_list)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^