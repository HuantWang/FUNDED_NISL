-----label-----
1
-----code-----
Res* getSessionVar(char *action,  char *varName,  ruleExecInfo_t *rei, Env *env, rError_t *errmsg, Region *r) {
  char *varMap;
  void *varValue = NULL;
  int i, vinx;
  varValue = NULL;

  /* Maps varName to the standard name and make varMap point to it. */
  /* It seems that for each pair of varName and standard name there is a list of actions that are supported. */
  /* vinx stores the index of the current pair so that we can start for the next pair if the current pair fails. */
  vinx = getVarMap(action,varName, &varMap, 0); /* reVariableMap.c */
  while (vinx >= 0) {
	/* Get the value of session variable referenced by varMap. */
      i = getVarValue(varMap, rei, (char **)&varValue); /* reVariableMap.c */
      /* convert to char * because getVarValue requires char * */
      if (i >= 0) {
            if (varValue != NULL) {
                Res *res = NULL;
                FunctionDesc *fd = (FunctionDesc *) lookupBucketFromHashTable(ruleEngineConfig.funcDescIndex, varMap);
                if (fd == NULL) {
                    /* default to string */
                    res = newStringRes(r, (char *) varValue);
                    free(varValue);
                } else {
                    ExprType *type = T_FUNC_RET_TYPE(fd->exprType); /* get var type from varMap */
                    switch (type->nodeType) {
                        case T_STRING:
                            res = newStringRes(r, (char *) varValue);
                            free(varValue);
                            break;
                        case T_INT:
                            res = newIntRes(r, *(int *) varValue);
                            free(varValue);
                            break;
                        case T_DOUBLE:
                            res = newDoubleRes(r, *(double *) varValue);
                            free(varValue);
                            break;
                        case T_IRODS:
                            res = newRes(r);
                            res->value.uninterpreted.inOutStruct = varValue;
                            res->value.uninterpreted.inOutBuffer = NULL;
                            res->exprType = type;
                            break;
                        default:
                            /* unsupported type error */
                            res = NULL;
                            addRErrorMsg(errmsg, -1, "error: unsupported session variable type");
                    }
                }
                free(varMap);
                return res;
            } else {
                return NULL;
            }
    } else if (i == NULL_VALUE_ERR) { /* Try next varMap, starting from vinx+1. */
      free(varMap);
      vinx = getVarMap(action,varName, &varMap, vinx+1);
    } else { /* On error, return 0. */
      free(varMap);
      if (varValue != NULL) free (varValue);
      return NULL;
    }
  }
  /* varMap not found, return 0. */
  if (varValue != NULL) free (varValue);
  return NULL;
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
4,8
4,9
4,10
4,11
4,12
7,8
7,9
9,10
9,11
12,13
12,14
14,15
14,16
17,18
17,19
18,19
20,21
20,22
23,24
23,25
24,25
26,27
26,28
29,30
29,31
30,31
32,33
32,34
35,36
35,37
36,37
38,39
38,40
41,42
41,43
41,44
41,45
41,46
41,47
41,48
41,49
42,43
43,44
43,45
45,46
45,47
48,49
49,50
49,51
51,52
51,53
51,54
54,55
55,56
57,58
58,59
58,60
58,61
60,61
62,63
64,65
65,66
65,67
66,67
68,69
70,71
71,72
71,73
72,73
74,75
74,76
74,77
74,78
74,79
75,76
77,78
79,80
81,82
82,83
85,86
85,87
86,87
86,88
87,88
90,91
90,92
91,92
92,93
92,94
93,94
95,96
95,97
95,98
95,99
96,97
98,99
100,101
102,103
102,104
103,104
103,105
105,106
105,107
108,109
109,110
111,112
111,113
111,114
112,113
112,114
113,114
116,117
117,118
117,119
117,120
118,119
118,120
119,120
121,122
123,124
123,125
123,126
123,127
123,128
124,125
125,126
125,127
126,127
128,129
128,130
128,131
131,132
132,133
134,135
135,136
135,137
136,137
138,139
138,140
138,141
141,142
142,143
142,144
143,144
143,145
144,145
146,147
148,149
148,150
148,151
149,150
151,152
151,153
152,153
155,156
157,158
157,159
157,160
158,159
158,160
159,160
161,162
163,164
163,165
164,165
165,166
165,167
166,167
168,169
168,170
168,171
169,170
171,172
173,174
173,175
174,175
174,176
176,177
178,179
180,181
181,182
181,183
182,183
184,185
186,187
186,188
187,188
188,189
188,190
189,190
191,192
191,193
191,194
194,195
195,196
195,197
196,197
198,199
198,200
199,200
202,203
202,204
203,204
203,205
204,205
207,208
207,209
207,210
207,211
207,212
207,213
207,214
207,215
207,216
207,217
207,218
207,219
207,220
207,221
207,222
207,223
207,224
207,225
207,226
207,227
207,228
208,209
209,210
211,212
212,213
212,214
213,214
215,216
215,217
215,218
216,217
218,219
220,221
220,222
221,222
221,223
223,224
225,226
227,228
228,229
228,230
229,230
231,232
234,235
235,236
237,238
238,239
238,240
239,240
241,242
241,243
241,244
242,243
244,245
246,247
247,248
247,249
248,249
248,250
250,251
252,253
254,255
255,256
255,257
256,257
258,259
261,262
262,263
264,265
265,266
265,267
266,267
268,269
268,270
268,271
269,270
271,272
273,274
274,275
274,276
275,276
275,277
277,278
279,280
281,282
282,283
282,284
283,284
285,286
288,289
289,290
291,292
292,293
292,294
293,294
295,296
295,297
296,297
298,299
300,301
301,302
301,303
302,303
302,304
303,304
303,305
304,305
304,306
305,306
310,311
312,313
313,314
313,315
314,315
314,316
315,316
315,317
316,317
316,318
317,318
322,323
324,325
325,326
325,327
326,327
326,328
327,328
330,331
334,335
335,336
335,337
336,337
338,339
340,341
341,342
341,343
341,344
341,345
342,343
344,345
346,347
349,350
350,351
350,352
351,352
353,354
355,356
356,357
358,359
359,360
360,361
362,363
362,364
362,365
363,364
363,365
364,365
366,367
368,369
368,370
369,370
370,371
370,372
371,372
373,374
375,376
376,377
376,378
377,378
379,380
379,381
379,382
379,383
379,384
380,381
382,383
384,385
386,387
387,388
389,390
389,391
390,391
393,394
393,395
393,396
394,395
395,396
395,397
396,397
398,399
400,401
400,402
401,402
401,403
402,403
404,405
406,407
407,408
407,409
408,409
410,411
412,413
413,414
415,416
415,417
416,417
416,418
417,418
419,420
421,422
422,423
422,424
423,424
425,426
427,428
428,429
-----nextToken-----
3,5,6,8,10,11,13,15,16,19,21,22,25,27,28,31,33,34,37,39,40,44,46,47,50,52,53,56,59,61,63,67,69,73,76,78,80,83,84,88,89,94,97,99,101,104,106,107,110,114,115,120,122,127,129,130,133,137,139,140,145,147,150,153,154,156,160,162,167,170,172,175,177,179,183,185,190,192,193,197,200,201,205,206,210,214,217,219,222,224,226,230,232,233,236,240,243,245,249,251,253,257,259,260,263,267,270,272,276,278,280,284,286,287,290,294,297,299,306,307,308,309,311,318,319,320,321,323,328,329,331,332,333,337,339,343,345,347,348,352,354,357,361,365,367,372,374,378,381,383,385,388,391,392,397,399,403,405,409,411,414,418,420,424,426,429
-----computeFrom-----
65,66
65,67
71,72
71,73
86,87
86,88
92,93
92,94
112,113
112,114
118,119
118,120
158,159
158,160
165,166
165,167
212,213
212,214
238,239
238,240
265,266
265,267
292,293
292,294
301,302
301,303
313,314
313,315
325,326
325,327
335,336
335,337
363,364
363,365
376,377
376,378
389,390
389,391
401,402
401,403
416,417
416,418
-----guardedBy-----
120,311
122,339
403,411
418,426
-----guardedByNegation-----
114,365
122,361
162,339
160,200
-----lastLexicalUse-----
122,361
-----jump-----
122,361
-----attribute-----
FunctionDefinition;NamedTypeSpecifier;Name;FunctionDeclarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;WhileStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;Pointer;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;DefaultStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;LiteralExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;CompoundStatement;ReturnStatement;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;
-----ast_node-----
Res* getSessionVar(char *action,  char *varName,  ruleExecInfo_t *rei, Env *env, rError_t *errmsg, Region *r) {  char *varMap;  void *varValue = NULL;  int i, vinx;  varValue = NULL;  /* Maps varName to the standard name and make varMap point to it. */  /* It seems that for each pair of varName and standard name there is a list of actions that are supported. */  /* vinx stores the index of the current pair so that we can start for the next pair if the current pair fails. */  vinx = getVarMap(action,varName, &varMap, 0); /* reVariableMap.c */  while (vinx >= 0) {	/* Get the value of session variable referenced by varMap. */      i = getVarValue(varMap, rei, (char **)&varValue); /* reVariableMap.c */      /* convert to char * because getVarValue requires char * */      if (i >= 0) {            if (varValue != NULL) {                Res *res = NULL;                FunctionDesc *fd = (FunctionDesc *) lookupBucketFromHashTable(ruleEngineConfig.funcDescIndex, varMap);                if (fd == NULL) {                    /* default to string */                    res = newStringRes(r, (char *) varValue);                    free(varValue);                } else {                    ExprType *type = T_FUNC_RET_TYPE(fd->exprType); /* get var type from varMap */                    switch (type->nodeType) {                        case T_STRING:                            res = newStringRes(r, (char *) varValue);                            free(varValue);                            break;                        case T_INT:                            res = newIntRes(r, *(int *) varValue);                            free(varValue);                            break;                        case T_DOUBLE:                            res = newDoubleRes(r, *(double *) varValue);                            free(varValue);                            break;                        case T_IRODS:                            res = newRes(r);                            res->value.uninterpreted.inOutStruct = varValue;                            res->value.uninterpreted.inOutBuffer = NULL;                            res->exprType = type;                            break;                        default:                            /* unsupported type error */                            res = NULL;                            addRErrorMsg(errmsg, -1, "error: unsupported session variable type");                    }                }                free(varMap);                return res;            } else {                return NULL;            }    } else if (i == NULL_VALUE_ERR) { /* Try next varMap, starting from vinx+1. */      free(varMap);      vinx = getVarMap(action,varName, &varMap, vinx+1);    } else { /* On error, return 0. */      free(varMap);      if (varValue != NULL) free (varValue);      return NULL;    }  }  /* varMap not found, return 0. */  if (varValue != NULL) free (varValue);  return NULL;}
Res
Res
* getSessionVar(char *action,  char *varName,  ruleExecInfo_t *rei, Env *env, rError_t *errmsg, Region *r)
*
getSessionVar
char *action
char
*action
*
action
char *varName
char
*varName
*
varName
ruleExecInfo_t *rei
ruleExecInfo_t
ruleExecInfo_t
*rei
*
rei
Env *env
Env
Env
*env
*
env
rError_t *errmsg
rError_t
rError_t
*errmsg
*
errmsg
Region *r
Region
Region
*r
*
r
{  char *varMap;  void *varValue = NULL;  int i, vinx;  varValue = NULL;  /* Maps varName to the standard name and make varMap point to it. */  /* It seems that for each pair of varName and standard name there is a list of actions that are supported. */  /* vinx stores the index of the current pair so that we can start for the next pair if the current pair fails. */  vinx = getVarMap(action,varName, &varMap, 0); /* reVariableMap.c */  while (vinx >= 0) {	/* Get the value of session variable referenced by varMap. */      i = getVarValue(varMap, rei, (char **)&varValue); /* reVariableMap.c */      /* convert to char * because getVarValue requires char * */      if (i >= 0) {            if (varValue != NULL) {                Res *res = NULL;                FunctionDesc *fd = (FunctionDesc *) lookupBucketFromHashTable(ruleEngineConfig.funcDescIndex, varMap);                if (fd == NULL) {                    /* default to string */                    res = newStringRes(r, (char *) varValue);                    free(varValue);                } else {                    ExprType *type = T_FUNC_RET_TYPE(fd->exprType); /* get var type from varMap */                    switch (type->nodeType) {                        case T_STRING:                            res = newStringRes(r, (char *) varValue);                            free(varValue);                            break;                        case T_INT:                            res = newIntRes(r, *(int *) varValue);                            free(varValue);                            break;                        case T_DOUBLE:                            res = newDoubleRes(r, *(double *) varValue);                            free(varValue);                            break;                        case T_IRODS:                            res = newRes(r);                            res->value.uninterpreted.inOutStruct = varValue;                            res->value.uninterpreted.inOutBuffer = NULL;                            res->exprType = type;                            break;                        default:                            /* unsupported type error */                            res = NULL;                            addRErrorMsg(errmsg, -1, "error: unsupported session variable type");                    }                }                free(varMap);                return res;            } else {                return NULL;            }    } else if (i == NULL_VALUE_ERR) { /* Try next varMap, starting from vinx+1. */      free(varMap);      vinx = getVarMap(action,varName, &varMap, vinx+1);    } else { /* On error, return 0. */      free(varMap);      if (varValue != NULL) free (varValue);      return NULL;    }  }  /* varMap not found, return 0. */  if (varValue != NULL) free (varValue);  return NULL;}
char *varMap;
char *varMap;
char
*varMap
*
varMap
void *varValue = NULL;
void *varValue = NULL;
void
*varValue = NULL
*
varValue
= NULL
NULL
NULL
int i, vinx;
int i, vinx;
int
i
i
vinx
vinx
varValue = NULL;
varValue = NULL
varValue
varValue
NULL
NULL
vinx = getVarMap(action,varName, &varMap, 0);
vinx = getVarMap(action,varName, &varMap, 0)
vinx
vinx
getVarMap(action,varName, &varMap, 0)
getVarMap
getVarMap
action
action
varName
varName
&varMap
varMap
varMap
0
while (vinx >= 0) {	/* Get the value of session variable referenced by varMap. */      i = getVarValue(varMap, rei, (char **)&varValue); /* reVariableMap.c */      /* convert to char * because getVarValue requires char * */      if (i >= 0) {            if (varValue != NULL) {                Res *res = NULL;                FunctionDesc *fd = (FunctionDesc *) lookupBucketFromHashTable(ruleEngineConfig.funcDescIndex, varMap);                if (fd == NULL) {                    /* default to string */                    res = newStringRes(r, (char *) varValue);                    free(varValue);                } else {                    ExprType *type = T_FUNC_RET_TYPE(fd->exprType); /* get var type from varMap */                    switch (type->nodeType) {                        case T_STRING:                            res = newStringRes(r, (char *) varValue);                            free(varValue);                            break;                        case T_INT:                            res = newIntRes(r, *(int *) varValue);                            free(varValue);                            break;                        case T_DOUBLE:                            res = newDoubleRes(r, *(double *) varValue);                            free(varValue);                            break;                        case T_IRODS:                            res = newRes(r);                            res->value.uninterpreted.inOutStruct = varValue;                            res->value.uninterpreted.inOutBuffer = NULL;                            res->exprType = type;                            break;                        default:                            /* unsupported type error */                            res = NULL;                            addRErrorMsg(errmsg, -1, "error: unsupported session variable type");                    }                }                free(varMap);                return res;            } else {                return NULL;            }    } else if (i == NULL_VALUE_ERR) { /* Try next varMap, starting from vinx+1. */      free(varMap);      vinx = getVarMap(action,varName, &varMap, vinx+1);    } else { /* On error, return 0. */      free(varMap);      if (varValue != NULL) free (varValue);      return NULL;    }  }
vinx >= 0
vinx
vinx
0
{	/* Get the value of session variable referenced by varMap. */      i = getVarValue(varMap, rei, (char **)&varValue); /* reVariableMap.c */      /* convert to char * because getVarValue requires char * */      if (i >= 0) {            if (varValue != NULL) {                Res *res = NULL;                FunctionDesc *fd = (FunctionDesc *) lookupBucketFromHashTable(ruleEngineConfig.funcDescIndex, varMap);                if (fd == NULL) {                    /* default to string */                    res = newStringRes(r, (char *) varValue);                    free(varValue);                } else {                    ExprType *type = T_FUNC_RET_TYPE(fd->exprType); /* get var type from varMap */                    switch (type->nodeType) {                        case T_STRING:                            res = newStringRes(r, (char *) varValue);                            free(varValue);                            break;                        case T_INT:                            res = newIntRes(r, *(int *) varValue);                            free(varValue);                            break;                        case T_DOUBLE:                            res = newDoubleRes(r, *(double *) varValue);                            free(varValue);                            break;                        case T_IRODS:                            res = newRes(r);                            res->value.uninterpreted.inOutStruct = varValue;                            res->value.uninterpreted.inOutBuffer = NULL;                            res->exprType = type;                            break;                        default:                            /* unsupported type error */                            res = NULL;                            addRErrorMsg(errmsg, -1, "error: unsupported session variable type");                    }                }                free(varMap);                return res;            } else {                return NULL;            }    } else if (i == NULL_VALUE_ERR) { /* Try next varMap, starting from vinx+1. */      free(varMap);      vinx = getVarMap(action,varName, &varMap, vinx+1);    } else { /* On error, return 0. */      free(varMap);      if (varValue != NULL) free (varValue);      return NULL;    }  }
i = getVarValue(varMap, rei, (char **)&varValue);
i = getVarValue(varMap, rei, (char **)&varValue)
i
i
getVarValue(varMap, rei, (char **)&varValue)
getVarValue
getVarValue
varMap
varMap
rei
rei
(char **)&varValue
char **
char
**
*
*
&varValue
varValue
varValue
if (i >= 0) {            if (varValue != NULL) {                Res *res = NULL;                FunctionDesc *fd = (FunctionDesc *) lookupBucketFromHashTable(ruleEngineConfig.funcDescIndex, varMap);                if (fd == NULL) {                    /* default to string */                    res = newStringRes(r, (char *) varValue);                    free(varValue);                } else {                    ExprType *type = T_FUNC_RET_TYPE(fd->exprType); /* get var type from varMap */                    switch (type->nodeType) {                        case T_STRING:                            res = newStringRes(r, (char *) varValue);                            free(varValue);                            break;                        case T_INT:                            res = newIntRes(r, *(int *) varValue);                            free(varValue);                            break;                        case T_DOUBLE:                            res = newDoubleRes(r, *(double *) varValue);                            free(varValue);                            break;                        case T_IRODS:                            res = newRes(r);                            res->value.uninterpreted.inOutStruct = varValue;                            res->value.uninterpreted.inOutBuffer = NULL;                            res->exprType = type;                            break;                        default:                            /* unsupported type error */                            res = NULL;                            addRErrorMsg(errmsg, -1, "error: unsupported session variable type");                    }                }                free(varMap);                return res;            } else {                return NULL;            }    } else if (i == NULL_VALUE_ERR) { /* Try next varMap, starting from vinx+1. */      free(varMap);      vinx = getVarMap(action,varName, &varMap, vinx+1);    } else { /* On error, return 0. */      free(varMap);      if (varValue != NULL) free (varValue);      return NULL;    }
i >= 0
i
i
0
{            if (varValue != NULL) {                Res *res = NULL;                FunctionDesc *fd = (FunctionDesc *) lookupBucketFromHashTable(ruleEngineConfig.funcDescIndex, varMap);                if (fd == NULL) {                    /* default to string */                    res = newStringRes(r, (char *) varValue);                    free(varValue);                } else {                    ExprType *type = T_FUNC_RET_TYPE(fd->exprType); /* get var type from varMap */                    switch (type->nodeType) {                        case T_STRING:                            res = newStringRes(r, (char *) varValue);                            free(varValue);                            break;                        case T_INT:                            res = newIntRes(r, *(int *) varValue);                            free(varValue);                            break;                        case T_DOUBLE:                            res = newDoubleRes(r, *(double *) varValue);                            free(varValue);                            break;                        case T_IRODS:                            res = newRes(r);                            res->value.uninterpreted.inOutStruct = varValue;                            res->value.uninterpreted.inOutBuffer = NULL;                            res->exprType = type;                            break;                        default:                            /* unsupported type error */                            res = NULL;                            addRErrorMsg(errmsg, -1, "error: unsupported session variable type");                    }                }                free(varMap);                return res;            } else {                return NULL;            }    }
if (varValue != NULL) {                Res *res = NULL;                FunctionDesc *fd = (FunctionDesc *) lookupBucketFromHashTable(ruleEngineConfig.funcDescIndex, varMap);                if (fd == NULL) {                    /* default to string */                    res = newStringRes(r, (char *) varValue);                    free(varValue);                } else {                    ExprType *type = T_FUNC_RET_TYPE(fd->exprType); /* get var type from varMap */                    switch (type->nodeType) {                        case T_STRING:                            res = newStringRes(r, (char *) varValue);                            free(varValue);                            break;                        case T_INT:                            res = newIntRes(r, *(int *) varValue);                            free(varValue);                            break;                        case T_DOUBLE:                            res = newDoubleRes(r, *(double *) varValue);                            free(varValue);                            break;                        case T_IRODS:                            res = newRes(r);                            res->value.uninterpreted.inOutStruct = varValue;                            res->value.uninterpreted.inOutBuffer = NULL;                            res->exprType = type;                            break;                        default:                            /* unsupported type error */                            res = NULL;                            addRErrorMsg(errmsg, -1, "error: unsupported session variable type");                    }                }                free(varMap);                return res;            } else {                return NULL;            }
varValue != NULL
varValue
varValue
NULL
NULL
{                Res *res = NULL;                FunctionDesc *fd = (FunctionDesc *) lookupBucketFromHashTable(ruleEngineConfig.funcDescIndex, varMap);                if (fd == NULL) {                    /* default to string */                    res = newStringRes(r, (char *) varValue);                    free(varValue);                } else {                    ExprType *type = T_FUNC_RET_TYPE(fd->exprType); /* get var type from varMap */                    switch (type->nodeType) {                        case T_STRING:                            res = newStringRes(r, (char *) varValue);                            free(varValue);                            break;                        case T_INT:                            res = newIntRes(r, *(int *) varValue);                            free(varValue);                            break;                        case T_DOUBLE:                            res = newDoubleRes(r, *(double *) varValue);                            free(varValue);                            break;                        case T_IRODS:                            res = newRes(r);                            res->value.uninterpreted.inOutStruct = varValue;                            res->value.uninterpreted.inOutBuffer = NULL;                            res->exprType = type;                            break;                        default:                            /* unsupported type error */                            res = NULL;                            addRErrorMsg(errmsg, -1, "error: unsupported session variable type");                    }                }                free(varMap);                return res;            }
Res *res = NULL;
Res *res = NULL;
Res
Res
*res = NULL
*
res
= NULL
NULL
NULL
FunctionDesc *fd = (FunctionDesc *) lookupBucketFromHashTable(ruleEngineConfig.funcDescIndex, varMap);
FunctionDesc *fd = (FunctionDesc *) lookupBucketFromHashTable(ruleEngineConfig.funcDescIndex, varMap);
FunctionDesc
FunctionDesc
*fd = (FunctionDesc *) lookupBucketFromHashTable(ruleEngineConfig.funcDescIndex, varMap)
*
fd
= (FunctionDesc *) lookupBucketFromHashTable(ruleEngineConfig.funcDescIndex, varMap)
(FunctionDesc *) lookupBucketFromHashTable(ruleEngineConfig.funcDescIndex, varMap)
FunctionDesc *
FunctionDesc
FunctionDesc
*
*
lookupBucketFromHashTable(ruleEngineConfig.funcDescIndex, varMap)
lookupBucketFromHashTable
lookupBucketFromHashTable
ruleEngineConfig.funcDescIndex
ruleEngineConfig
ruleEngineConfig
funcDescIndex
varMap
varMap
if (fd == NULL) {                    /* default to string */                    res = newStringRes(r, (char *) varValue);                    free(varValue);                } else {                    ExprType *type = T_FUNC_RET_TYPE(fd->exprType); /* get var type from varMap */                    switch (type->nodeType) {                        case T_STRING:                            res = newStringRes(r, (char *) varValue);                            free(varValue);                            break;                        case T_INT:                            res = newIntRes(r, *(int *) varValue);                            free(varValue);                            break;                        case T_DOUBLE:                            res = newDoubleRes(r, *(double *) varValue);                            free(varValue);                            break;                        case T_IRODS:                            res = newRes(r);                            res->value.uninterpreted.inOutStruct = varValue;                            res->value.uninterpreted.inOutBuffer = NULL;                            res->exprType = type;                            break;                        default:                            /* unsupported type error */                            res = NULL;                            addRErrorMsg(errmsg, -1, "error: unsupported session variable type");                    }                }
fd == NULL
fd
fd
NULL
NULL
{                    /* default to string */                    res = newStringRes(r, (char *) varValue);                    free(varValue);                }
res = newStringRes(r, (char *) varValue);
res = newStringRes(r, (char *) varValue)
res
res
newStringRes(r, (char *) varValue)
newStringRes
newStringRes
r
r
(char *) varValue
char *
char
*
*
varValue
varValue
free(varValue);
free(varValue)
free
free
varValue
varValue
{                    ExprType *type = T_FUNC_RET_TYPE(fd->exprType); /* get var type from varMap */                    switch (type->nodeType) {                        case T_STRING:                            res = newStringRes(r, (char *) varValue);                            free(varValue);                            break;                        case T_INT:                            res = newIntRes(r, *(int *) varValue);                            free(varValue);                            break;                        case T_DOUBLE:                            res = newDoubleRes(r, *(double *) varValue);                            free(varValue);                            break;                        case T_IRODS:                            res = newRes(r);                            res->value.uninterpreted.inOutStruct = varValue;                            res->value.uninterpreted.inOutBuffer = NULL;                            res->exprType = type;                            break;                        default:                            /* unsupported type error */                            res = NULL;                            addRErrorMsg(errmsg, -1, "error: unsupported session variable type");                    }                }
ExprType *type = T_FUNC_RET_TYPE(fd->exprType);
ExprType *type = T_FUNC_RET_TYPE(fd->exprType);
ExprType
ExprType
*type = T_FUNC_RET_TYPE(fd->exprType)
*
type
= T_FUNC_RET_TYPE(fd->exprType)
T_FUNC_RET_TYPE(fd->exprType)
T_FUNC_RET_TYPE
T_FUNC_RET_TYPE
fd->exprType
fd
fd
exprType
switch (type->nodeType) {                        case T_STRING:                            res = newStringRes(r, (char *) varValue);                            free(varValue);                            break;                        case T_INT:                            res = newIntRes(r, *(int *) varValue);                            free(varValue);                            break;                        case T_DOUBLE:                            res = newDoubleRes(r, *(double *) varValue);                            free(varValue);                            break;                        case T_IRODS:                            res = newRes(r);                            res->value.uninterpreted.inOutStruct = varValue;                            res->value.uninterpreted.inOutBuffer = NULL;                            res->exprType = type;                            break;                        default:                            /* unsupported type error */                            res = NULL;                            addRErrorMsg(errmsg, -1, "error: unsupported session variable type");                    }
type->nodeType
type
type
nodeType
{                        case T_STRING:                            res = newStringRes(r, (char *) varValue);                            free(varValue);                            break;                        case T_INT:                            res = newIntRes(r, *(int *) varValue);                            free(varValue);                            break;                        case T_DOUBLE:                            res = newDoubleRes(r, *(double *) varValue);                            free(varValue);                            break;                        case T_IRODS:                            res = newRes(r);                            res->value.uninterpreted.inOutStruct = varValue;                            res->value.uninterpreted.inOutBuffer = NULL;                            res->exprType = type;                            break;                        default:                            /* unsupported type error */                            res = NULL;                            addRErrorMsg(errmsg, -1, "error: unsupported session variable type");                    }
case T_STRING:
T_STRING
T_STRING
res = newStringRes(r, (char *) varValue);
res = newStringRes(r, (char *) varValue)
res
res
newStringRes(r, (char *) varValue)
newStringRes
newStringRes
r
r
(char *) varValue
char *
char
*
*
varValue
varValue
free(varValue);
free(varValue)
free
free
varValue
varValue
break;
case T_INT:
T_INT
T_INT
res = newIntRes(r, *(int *) varValue);
res = newIntRes(r, *(int *) varValue)
res
res
newIntRes(r, *(int *) varValue)
newIntRes
newIntRes
r
r
*(int *) varValue
(int *) varValue
int *
int
*
*
varValue
varValue
free(varValue);
free(varValue)
free
free
varValue
varValue
break;
case T_DOUBLE:
T_DOUBLE
T_DOUBLE
res = newDoubleRes(r, *(double *) varValue);
res = newDoubleRes(r, *(double *) varValue)
res
res
newDoubleRes(r, *(double *) varValue)
newDoubleRes
newDoubleRes
r
r
*(double *) varValue
(double *) varValue
double *
double
*
*
varValue
varValue
free(varValue);
free(varValue)
free
free
varValue
varValue
break;
case T_IRODS:
T_IRODS
T_IRODS
res = newRes(r);
res = newRes(r)
res
res
newRes(r)
newRes
newRes
r
r
res->value.uninterpreted.inOutStruct = varValue;
res->value.uninterpreted.inOutStruct = varValue
res->value.uninterpreted.inOutStruct
res->value.uninterpreted
res->value
res
res
value
uninterpreted
inOutStruct
varValue
varValue
res->value.uninterpreted.inOutBuffer = NULL;
res->value.uninterpreted.inOutBuffer = NULL
res->value.uninterpreted.inOutBuffer
res->value.uninterpreted
res->value
res
res
value
uninterpreted
inOutBuffer
NULL
NULL
res->exprType = type;
res->exprType = type
res->exprType
res
res
exprType
type
type
break;
default:
res = NULL;
res = NULL
res
res
NULL
NULL
addRErrorMsg(errmsg, -1, "error: unsupported session variable type");
addRErrorMsg(errmsg, -1, "error: unsupported session variable type")
addRErrorMsg
addRErrorMsg
errmsg
errmsg
-1
1
"error: unsupported session variable type"
free(varMap);
free(varMap)
free
free
varMap
varMap
return res;
res
res
{                return NULL;            }
return NULL;
NULL
NULL
if (i == NULL_VALUE_ERR) { /* Try next varMap, starting from vinx+1. */      free(varMap);      vinx = getVarMap(action,varName, &varMap, vinx+1);    } else { /* On error, return 0. */      free(varMap);      if (varValue != NULL) free (varValue);      return NULL;    }
i == NULL_VALUE_ERR
i
i
NULL_VALUE_ERR
NULL_VALUE_ERR
{ /* Try next varMap, starting from vinx+1. */      free(varMap);      vinx = getVarMap(action,varName, &varMap, vinx+1);    }
free(varMap);
free(varMap)
free
free
varMap
varMap
vinx = getVarMap(action,varName, &varMap, vinx+1);
vinx = getVarMap(action,varName, &varMap, vinx+1)
vinx
vinx
getVarMap(action,varName, &varMap, vinx+1)
getVarMap
getVarMap
action
action
varName
varName
&varMap
varMap
varMap
vinx+1
vinx
vinx
1
{ /* On error, return 0. */      free(varMap);      if (varValue != NULL) free (varValue);      return NULL;    }
free(varMap);
free(varMap)
free
free
varMap
varMap
if (varValue != NULL) free (varValue);
varValue != NULL
varValue
varValue
NULL
NULL
free (varValue);
free (varValue)
free
free
varValue
varValue
return NULL;
NULL
NULL
if (varValue != NULL) free (varValue);
varValue != NULL
varValue
varValue
NULL
NULL
free (varValue);
free (varValue)
free
free
varValue
varValue
return NULL;
NULL
NULL
-----joern-----
(42,51,0)
(171,7,0)
(33,67,0)
(81,123,0)
(5,136,0)
(80,118,0)
(19,193,0)
(123,95,0)
(140,132,0)
(139,86,0)
(160,171,0)
(147,89,0)
(14,149,0)
(195,134,0)
(178,90,0)
(170,177,0)
(12,112,0)
(38,177,0)
(91,6,0)
(60,102,0)
(100,184,0)
(171,23,0)
(129,61,0)
(47,128,0)
(131,186,0)
(137,174,0)
(138,135,0)
(58,67,0)
(87,7,0)
(150,88,0)
(107,97,0)
(93,88,0)
(191,67,0)
(103,174,0)
(156,89,0)
(200,99,0)
(189,127,0)
(132,39,0)
(81,66,0)
(108,85,0)
(48,190,0)
(84,171,0)
(99,95,0)
(194,95,0)
(175,156,0)
(68,102,0)
(41,52,0)
(75,88,0)
(128,103,0)
(59,74,0)
(31,88,0)
(9,67,0)
(42,22,0)
(34,105,0)
(22,42,0)
(21,188,0)
(159,202,0)
(179,97,0)
(118,22,0)
(187,155,0)
(106,65,0)
(102,158,0)
(81,51,0)
(190,51,0)
(76,44,0)
(102,116,0)
(51,67,0)
(8,42,0)
(168,96,0)
(202,51,0)
(43,184,0)
(192,67,0)
(152,103,0)
(42,8,0)
(40,39,0)
(61,45,0)
(71,163,0)
(164,102,0)
(32,128,0)
(156,13,0)
(97,149,0)
(156,203,0)
(109,173,0)
(120,2,0)
(30,42,0)
(90,193,0)
(174,51,0)
(39,40,0)
(176,153,0)
(136,86,0)
(114,65,0)
(197,134,0)
(101,202,0)
(86,67,0)
(99,52,0)
(121,190,0)
(123,34,0)
(156,135,0)
(141,146,0)
(183,58,0)
(53,112,0)
(190,126,0)
(110,2,0)
(1,167,0)
(39,63,0)
(147,112,0)
(18,51,0)
(45,195,0)
(38,126,0)
(94,140,0)
(132,196,0)
(162,18,0)
(49,31,0)
(63,39,0)
(117,11,0)
(156,34,0)
(134,195,0)
(148,146,0)
(85,51,0)
(157,132,0)
(96,13,0)
(90,89,0)
(86,102,0)
(151,40,0)
(132,140,0)
(186,51,0)
(173,59,0)
(27,67,0)
(64,68,0)
(154,36,0)
(136,74,0)
(77,51,0)
(204,100,0)
(128,47,0)
(142,47,0)
(161,94,0)
(193,45,0)
(156,130,0)
(153,149,0)
(126,190,0)
(134,96,0)
(26,88,0)
(2,13,0)
(163,67,0)
(188,51,0)
(65,140,0)
(59,173,0)
(182,88,0)
(203,88,0)
(11,13,0)
(24,123,0)
(143,140,0)
(177,38,0)
(169,45,0)
(7,171,0)
(119,186,0)
(82,147,0)
(203,118,0)
(40,51,0)
(39,132,0)
(6,105,0)
(0,132,0)
(127,74,0)
(52,41,0)
(29,53,0)
(194,89,0)
(201,124,0)
(89,88,0)
(59,158,0)
(107,156,0)
(107,16,0)
(115,16,0)
(174,88,0)
(102,86,0)
(180,168,0)
(124,201,0)
(37,130,0)
(89,194,0)
(78,100,0)
(111,88,0)
(127,86,0)
(125,51,0)
(130,99,0)
(99,130,0)
(118,203,0)
(66,81,0)
(181,88,0)
(38,95,0)
(185,135,0)
(133,47,0)
(104,127,0)
(73,59,0)
(92,203,0)
(122,136,0)
(17,61,0)
(59,116,0)
(177,88,0)
(46,81,0)
(146,51,0)
(70,67,0)
(113,89,0)
(130,88,0)
(57,34,0)
(112,147,0)
(112,53,0)
(83,96,0)
(74,59,0)
(165,59,0)
(123,81,0)
(188,88,0)
(124,184,0)
(50,94,0)
(166,44,0)
(184,100,0)
(126,38,0)
(96,124,0)
(36,88,0)
(102,68,0)
(98,102,0)
(47,89,0)
(45,44,0)
(31,51,0)
(22,118,0)
(25,38,0)
(62,13,0)
(53,36,0)
(69,52,0)
(20,88,0)
(103,128,0)
(184,124,0)
(16,55,0)
(34,123,0)
(72,88,0)
(195,45,0)
(118,95,0)
(59,136,0)
(74,167,0)
(190,48,0)
(198,74,0)
(56,13,0)
(28,194,0)
(171,88,0)
(15,90,0)
(79,1,0)
(199,168,0)
(136,59,0)
(193,88,0)
(20,51,0)
(52,51,0)
(10,134,0)
(107,58,0)
(4,163,0)
(3,54,0)
(135,88,0)
(124,96,0)
(172,88,0)
(35,20,0)
(145,147,0)
(156,177,0)
(144,13,0)
(52,99,0)
(140,155,0)
(6,51,0)
(0,157,1)
(99,52,1)
(195,134,1)
(103,152,1)
(136,86,1)
(85,51,1)
(89,194,1)
(61,45,1)
(65,114,1)
(156,89,1)
(99,95,1)
(92,61,1)
(193,19,1)
(38,126,1)
(106,140,1)
(186,51,1)
(47,133,1)
(81,46,1)
(123,95,1)
(146,141,1)
(179,202,1)
(6,91,1)
(65,140,1)
(2,120,1)
(171,84,1)
(138,185,1)
(107,58,1)
(171,23,1)
(57,168,1)
(202,159,1)
(97,179,1)
(141,148,1)
(103,128,1)
(90,178,1)
(112,147,1)
(125,163,1)
(147,89,1)
(73,198,1)
(98,60,1)
(34,123,1)
(117,93,1)
(10,169,1)
(108,186,1)
(94,161,1)
(80,92,1)
(143,127,1)
(77,125,1)
(185,61,1)
(117,6,1)
(6,51,1)
(175,11,1)
(165,73,1)
(159,101,1)
(174,137,1)
(124,184,1)
(43,100,1)
(78,83,1)
(136,122,1)
(102,158,1)
(109,165,1)
(169,168,1)
(1,79,1)
(107,156,1)
(47,89,1)
(102,116,1)
(117,150,1)
(130,99,1)
(51,77,1)
(129,17,1)
(21,130,1)
(194,95,1)
(186,131,1)
(157,143,1)
(29,112,1)
(39,63,1)
(161,50,1)
(86,102,1)
(115,146,1)
(53,29,1)
(81,66,1)
(7,87,1)
(145,174,1)
(61,129,1)
(59,116,1)
(53,112,1)
(127,189,1)
(18,51,1)
(42,30,1)
(49,203,1)
(156,177,1)
(203,118,1)
(46,24,1)
(154,53,1)
(189,104,1)
(71,4,1)
(139,51,1)
(134,197,1)
(156,135,1)
(122,5,1)
(127,86,1)
(52,51,1)
(136,74,1)
(194,28,1)
(102,164,1)
(42,51,1)
(37,61,1)
(170,61,1)
(35,177,1)
(153,176,1)
(174,51,1)
(184,43,1)
(179,18,1)
(112,12,1)
(133,142,1)
(176,94,1)
(156,34,1)
(156,203,1)
(68,64,1)
(83,2,1)
(38,95,1)
(59,158,1)
(190,48,1)
(96,124,1)
(140,132,1)
(132,39,1)
(118,95,1)
(124,201,1)
(121,25,1)
(148,65,1)
(42,8,1)
(152,128,1)
(15,36,1)
(135,138,1)
(114,106,1)
(132,196,1)
(52,69,1)
(198,1,1)
(102,68,1)
(107,16,1)
(184,100,1)
(110,146,1)
(79,94,1)
(162,202,1)
(36,154,1)
(25,170,1)
(156,175,1)
(45,195,1)
(59,173,1)
(188,21,1)
(12,147,1)
(40,51,1)
(142,89,1)
(188,51,1)
(5,173,1)
(160,135,1)
(118,22,1)
(81,51,1)
(18,162,1)
(200,37,1)
(11,117,1)
(120,110,1)
(197,10,1)
(82,145,1)
(202,51,1)
(113,61,1)
(180,96,1)
(137,103,1)
(40,151,1)
(128,47,1)
(24,57,1)
(147,82,1)
(94,140,1)
(146,51,1)
(151,0,1)
(64,98,1)
(126,190,1)
(90,89,1)
(183,85,1)
(128,32,1)
(104,74,1)
(93,20,1)
(101,153,1)
(134,96,1)
(74,59,1)
(31,51,1)
(171,7,1)
(20,35,1)
(164,68,1)
(107,97,1)
(22,42,1)
(19,90,1)
(84,7,1)
(127,74,1)
(131,119,1)
(28,113,1)
(123,81,1)
(163,71,1)
(181,31,1)
(85,108,1)
(117,181,1)
(168,96,1)
(173,109,1)
(156,130,1)
(117,111,1)
(30,80,1)
(50,65,1)
(104,86,1)
(32,47,1)
(87,160,1)
(117,171,1)
(91,34,1)
(58,183,1)
(183,186,1)
(177,38,1)
(111,188,1)
(199,180,1)
(168,199,1)
(178,15,1)
(60,139,1)
(204,78,1)
(52,41,1)
(69,200,1)
(39,40,1)
(20,51,1)
(190,51,1)
(190,121,1)
(31,49,1)
(100,204,1)
(59,136,1)
(16,115,1)
(17,45,1)
(193,45,1)
(119,127,1)
(150,193,1)
(59,173,2)
(170,61,2)
(85,186,2)
(18,51,2)
(34,123,2)
(122,94,2)
(107,16,2)
(28,61,2)
(22,61,2)
(38,126,2)
(147,61,2)
(115,146,2)
(160,61,2)
(81,168,2)
(142,61,2)
(0,127,2)
(59,158,2)
(89,194,2)
(197,168,2)
(132,127,2)
(186,51,2)
(96,146,2)
(79,94,2)
(198,94,2)
(200,61,2)
(11,146,2)
(38,95,2)
(39,40,2)
(110,146,2)
(156,130,2)
(195,168,2)
(31,51,2)
(17,168,2)
(29,61,2)
(83,146,2)
(165,94,2)
(178,61,2)
(20,51,2)
(132,196,2)
(112,147,2)
(145,61,2)
(127,86,2)
(156,203,2)
(111,61,2)
(100,146,2)
(25,61,2)
(176,94,2)
(92,61,2)
(147,89,2)
(39,127,2)
(12,61,2)
(81,51,2)
(190,48,2)
(103,61,2)
(108,186,2)
(106,127,2)
(20,61,2)
(69,61,2)
(59,136,2)
(123,168,2)
(42,51,2)
(37,61,2)
(141,65,2)
(78,146,2)
(124,146,2)
(174,61,2)
(42,61,2)
(49,61,2)
(175,146,2)
(150,61,2)
(124,201,2)
(40,127,2)
(40,51,2)
(194,61,2)
(188,61,2)
(113,61,2)
(102,158,2)
(179,94,2)
(74,94,2)
(99,95,2)
(97,94,2)
(65,140,2)
(45,168,2)
(1,94,2)
(156,146,2)
(120,146,2)
(117,146,2)
(99,61,2)
(135,61,2)
(2,146,2)
(30,61,2)
(52,41,2)
(84,61,2)
(174,51,2)
(114,127,2)
(119,127,2)
(156,89,2)
(188,51,2)
(118,22,2)
(5,94,2)
(102,68,2)
(181,61,2)
(50,65,2)
(61,45,2)
(109,94,2)
(59,116,2)
(157,127,2)
(42,8,2)
(151,127,2)
(140,127,2)
(45,195,2)
(136,74,2)
(61,168,2)
(81,66,2)
(203,61,2)
(136,94,2)
(85,51,2)
(128,47,2)
(73,94,2)
(153,94,2)
(126,190,2)
(154,61,2)
(186,127,2)
(146,51,2)
(35,61,2)
(169,168,2)
(133,61,2)
(123,81,2)
(15,61,2)
(57,168,2)
(156,34,2)
(103,128,2)
(202,94,2)
(121,61,2)
(156,177,2)
(96,124,2)
(199,146,2)
(129,168,2)
(46,168,2)
(195,134,2)
(91,168,2)
(7,61,2)
(87,61,2)
(118,95,2)
(185,61,2)
(184,100,2)
(34,168,2)
(159,94,2)
(127,94,2)
(177,38,2)
(138,61,2)
(107,156,2)
(143,127,2)
(190,61,2)
(94,140,2)
(93,61,2)
(123,95,2)
(118,61,2)
(59,94,2)
(31,61,2)
(162,202,2)
(152,61,2)
(183,127,2)
(90,89,2)
(6,51,2)
(156,135,2)
(134,96,2)
(148,65,2)
(136,86,2)
(140,132,2)
(89,61,2)
(32,61,2)
(58,127,2)
(127,74,2)
(161,65,2)
(177,61,2)
(82,61,2)
(189,94,2)
(53,61,2)
(74,59,2)
(38,61,2)
(184,146,2)
(190,51,2)
(128,61,2)
(171,61,2)
(80,61,2)
(130,61,2)
(43,146,2)
(202,51,2)
(52,51,2)
(137,61,2)
(10,168,2)
(171,23,2)
(203,118,2)
(107,97,2)
(146,65,2)
(134,168,2)
(16,146,2)
(99,52,2)
(204,146,2)
(104,94,2)
(102,116,2)
(126,61,2)
(168,146,2)
(65,127,2)
(112,61,2)
(6,168,2)
(39,63,2)
(18,202,2)
(173,94,2)
(168,96,2)
(193,45,2)
(171,7,2)
(130,99,2)
(132,39,2)
(86,102,2)
(94,65,2)
(36,61,2)
(193,61,2)
(19,61,2)
(194,95,2)
(180,146,2)
(24,168,2)
(53,112,2)
(124,184,2)
(90,61,2)
(47,61,2)
(21,61,2)
(131,127,2)
(22,42,2)
(107,58,2)
(101,94,2)
(47,89,2)
(52,61,2)
-----------------------------------
(0,rei)
(1,free(varMap)
(2,*res = NULL)
(3,if (varValue != NULL)
(4,varValue)
(5,vinx)
(6,free(varValue)
(7,-1)
(8,double *)
(9,i)
(10,fd)
(11,free(varMap)
(12,uninterpreted)
(13,)
(14,if (varValue != NULL)
(15,res)
(16,return NULL;)
(17,type)
(18,free (varValue)
(19,type)
(20,free(varValue)
(21,varValue)
(22,*(double *)
(23,rError_t *errmsg)
(24,r)
(25,r)
(26,default:)
(27,vinx)
(28,r)
(29,inOutBuffer)
(30,varValue)
(31,free(varValue)
(32,uninterpreted)
(33,while (vinx >= 0)
(34,res = newStringRes(r, (char *)
(35,varValue)
(36,res->value.uninterpreted.inOutBuffer = NULL)
(37,res)
(38,newIntRes(r, *(int *)
(39,(char **)
(40,&varValue)
(41,char *)
(42,(double *)
(43,varMap)
(44,)
(45,*type = T_FUNC_RET_TYPE(fd->exprType)
(46,varValue)
(47,res->value)
(48,int *)
(49,varValue)
(50,i)
(51,varValue = NULL)
(52,(char *)
(53,res->value.uninterpreted.inOutBuffer)
(54,)
(55,)
(56,if (fd == NULL)
(57,res)
(58,return NULL;)
(59,getVarMap(action,varName, &varMap, vinx+1)
(60,action)
(61,type->nodeType)
(62,res)
(63,char **)
(64,varMap)
(65,i >= 0)
(66,char *)
(67,)
(68,&varMap)
(69,varValue)
(70,if (varValue != NULL)
(71,NULL)
(72,case T_DOUBLE:)
(73,action)
(74,vinx = getVarMap(action,varName, &varMap, vinx+1)
(75,case T_INT:)
(76,type)
(77,NULL)
(78,ruleEngineConfig)
(79,varMap)
(80,r)
(81,(char *)
(82,value)
(83,fd)
(84,"error: unsupported session variable type")
(85,free (varValue)
(86,vinx = getVarMap(action,varName, &varMap, 0)
(87,1)
(88,)
(89,res = newRes(r)
(90,res->exprType)
(91,varValue)
(92,res)
(93,break;)
(94,i == NULL_VALUE_ERR)
(95,Region *r)
(96,*fd = (FunctionDesc *)
(97,return NULL;)
(98,varName)
(99,newStringRes(r, (char *)
(100,ruleEngineConfig.funcDescIndex)
(101,varValue)
(102,getVarMap(action,varName, &varMap, 0)
(103,res->value.uninterpreted.inOutStruct)
(104,vinx)
(105,)
(106,i)
(107,RET)
(108,varValue)
(109,varMap)
(110,res)
(111,break;)
(112,res->value.uninterpreted)
(113,res)
(114,0)
(115,NULL)
(116,char *varName)
(117,varMap)
(118,newDoubleRes(r, *(double *)
(119,varValue)
(120,NULL)
(121,varValue)
(122,1)
(123,newStringRes(r, (char *)
(124,(FunctionDesc *)
(125,varValue)
(126,*(int *)
(127,vinx >= 0)
(128,res->value.uninterpreted)
(129,nodeType)
(130,res = newStringRes(r, (char *)
(131,NULL)
(132,getVarValue(varMap, rei, (char **)
(133,value)
(134,fd->exprType)
(135,res = NULL)
(136,vinx+1)
(137,varValue)
(138,NULL)
(139,vinx)
(140,i = getVarValue(varMap, rei, (char **)
(141,NULL)
(142,res)
(143,i)
(144,fd)
(145,res)
(146,varValue != NULL)
(147,res->value)
(148,varValue)
(149,)
(150,break;)
(151,varValue)
(152,inOutStruct)
(153,free(varMap)
(154,NULL)
(155,)
(156,return res;)
(157,varMap)
(158,char *action)
(159,NULL)
(160,errmsg)
(161,NULL_VALUE_ERR)
(162,varValue)
(163,*varValue = NULL)
(164,0)
(165,varName)
(166,switch (type->nodeType)
(167,)
(168,fd == NULL)
(169,type)
(170,res)
(171,addRErrorMsg(errmsg, -1, "error: unsupported session variable type")
(172,case T_STRING:)
(173,&varMap)
(174,res->value.uninterpreted.inOutStruct = varValue)
(175,res)
(176,varMap)
(177,res = newIntRes(r, *(int *)
(178,exprType)
(179,NULL)
(180,fd)
(181,break;)
(182,case T_IRODS:)
(183,NULL)
(184,lookupBucketFromHashTable(ruleEngineConfig.funcDescIndex, varMap)
(185,res)
(186,varValue != NULL)
(187,if (i >= 0)
(188,free(varValue)
(189,0)
(190,(int *)
(191,varMap)
(192,varValue)
(193,res->exprType = type)
(194,newRes(r)
(195,T_FUNC_RET_TYPE(fd->exprType)
(196,ruleExecInfo_t *rei)
(197,exprType)
(198,vinx)
(199,NULL)
(200,r)
(201,FunctionDesc *)
(202,varValue != NULL)
(203,res = newDoubleRes(r, *(double *)
(204,funcDescIndex)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^