-----label-----
1
-----code-----
category_allocation_t category_next_label(struct hash_table *categories, const char *category, category_allocation_t current_label, int resource_overflow) {

	if(resource_overflow) {
		if(current_label == CATEGORY_ALLOCATION_USER || current_label == CATEGORY_ALLOCATION_UNLABELED || current_label == CATEGORY_ALLOCATION_AUTO_MAX) {
			return CATEGORY_ALLOCATION_ERROR;
		} else {
			return CATEGORY_ALLOCATION_AUTO_MAX;
		}
	}

	/* If user specified resources manually, respect the label. */
	if(current_label == CATEGORY_ALLOCATION_USER) {
			return CATEGORY_ALLOCATION_USER;
	}

	struct category *c = category_lookup_or_create(categories, category);
	/* If category is not labeling, and user is not labeling, return unlabeled. */
	if(!c->max_allocation) {
		return CATEGORY_ALLOCATION_UNLABELED;
	}

	/* Never downgrade max allocation */
	if(current_label == CATEGORY_ALLOCATION_AUTO_MAX) {
		return CATEGORY_ALLOCATION_AUTO_MAX;
	}

	if(c->first_allocation) {
		/* Use first allocation when it is available. */
		return CATEGORY_ALLOCATION_AUTO_FIRST;
	} else {
		/* Use default when no enough information is available. */
		return CATEGORY_ALLOCATION_AUTO_ZERO;
	}
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
4,8
4,9
6,7
6,8
7,8
9,10
9,11
12,13
12,14
14,15
14,16
17,18
17,19
18,19
20,21
22,23
22,24
24,25
26,27
26,28
26,29
26,30
26,31
26,32
27,28
27,29
28,29
30,31
31,32
31,33
31,34
32,33
32,34
33,34
33,35
34,35
34,36
35,36
37,38
39,40
39,41
40,41
42,43
44,45
44,46
45,46
47,48
49,50
50,51
51,52
53,54
54,55
55,56
57,58
57,59
58,59
58,60
59,60
61,62
63,64
64,65
65,66
67,68
68,69
68,70
69,70
71,72
71,73
71,74
74,75
75,76
75,77
75,78
76,77
78,79
80,81
82,83
82,84
83,84
84,85
84,86
85,86
88,89
89,90
90,91
92,93
92,94
93,94
93,95
94,95
96,97
98,99
99,100
100,101
102,103
102,104
102,105
103,104
103,105
104,105
107,108
108,109
109,110
111,112
112,113
113,114
-----nextToken-----
3,5,8,10,11,13,15,16,19,21,23,25,29,36,38,41,43,46,48,52,56,60,62,66,70,72,73,77,79,81,86,87,91,95,97,101,105,106,110,114
-----computeFrom-----
32,33
32,34
33,34
33,35
34,35
34,36
39,40
39,41
44,45
44,46
58,59
58,60
93,94
93,95
-----guardedBy-----
62,66
97,101
-----guardedByNegation-----
48,56
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;NamedTypeSpecifier;Name;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ReturnStatement;IdExpression;Name;CompoundStatement;ReturnStatement;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ReturnStatement;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ReturnStatement;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ReturnStatement;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ReturnStatement;IdExpression;Name;CompoundStatement;ReturnStatement;IdExpression;Name;
-----ast_node-----
category_allocation_t category_next_label(struct hash_table *categories, const char *category, category_allocation_t current_label, int resource_overflow) {	if(resource_overflow) {		if(current_label == CATEGORY_ALLOCATION_USER || current_label == CATEGORY_ALLOCATION_UNLABELED || current_label == CATEGORY_ALLOCATION_AUTO_MAX) {			return CATEGORY_ALLOCATION_ERROR;		} else {			return CATEGORY_ALLOCATION_AUTO_MAX;		}	}	/* If user specified resources manually, respect the label. */	if(current_label == CATEGORY_ALLOCATION_USER) {			return CATEGORY_ALLOCATION_USER;	}	struct category *c = category_lookup_or_create(categories, category);	/* If category is not labeling, and user is not labeling, return unlabeled. */	if(!c->max_allocation) {		return CATEGORY_ALLOCATION_UNLABELED;	}	/* Never downgrade max allocation */	if(current_label == CATEGORY_ALLOCATION_AUTO_MAX) {		return CATEGORY_ALLOCATION_AUTO_MAX;	}	if(c->first_allocation) {		/* Use first allocation when it is available. */		return CATEGORY_ALLOCATION_AUTO_FIRST;	} else {		/* Use default when no enough information is available. */		return CATEGORY_ALLOCATION_AUTO_ZERO;	}}
category_allocation_t
category_allocation_t
category_next_label(struct hash_table *categories, const char *category, category_allocation_t current_label, int resource_overflow)
category_next_label
struct hash_table *categories
struct hash_table
hash_table
*categories
*
categories
const char *category
const char
*category
*
category
category_allocation_t current_label
category_allocation_t
category_allocation_t
current_label
current_label
int resource_overflow
int
resource_overflow
resource_overflow
{	if(resource_overflow) {		if(current_label == CATEGORY_ALLOCATION_USER || current_label == CATEGORY_ALLOCATION_UNLABELED || current_label == CATEGORY_ALLOCATION_AUTO_MAX) {			return CATEGORY_ALLOCATION_ERROR;		} else {			return CATEGORY_ALLOCATION_AUTO_MAX;		}	}	/* If user specified resources manually, respect the label. */	if(current_label == CATEGORY_ALLOCATION_USER) {			return CATEGORY_ALLOCATION_USER;	}	struct category *c = category_lookup_or_create(categories, category);	/* If category is not labeling, and user is not labeling, return unlabeled. */	if(!c->max_allocation) {		return CATEGORY_ALLOCATION_UNLABELED;	}	/* Never downgrade max allocation */	if(current_label == CATEGORY_ALLOCATION_AUTO_MAX) {		return CATEGORY_ALLOCATION_AUTO_MAX;	}	if(c->first_allocation) {		/* Use first allocation when it is available. */		return CATEGORY_ALLOCATION_AUTO_FIRST;	} else {		/* Use default when no enough information is available. */		return CATEGORY_ALLOCATION_AUTO_ZERO;	}}
if(resource_overflow) {		if(current_label == CATEGORY_ALLOCATION_USER || current_label == CATEGORY_ALLOCATION_UNLABELED || current_label == CATEGORY_ALLOCATION_AUTO_MAX) {			return CATEGORY_ALLOCATION_ERROR;		} else {			return CATEGORY_ALLOCATION_AUTO_MAX;		}	}
resource_overflow
resource_overflow
{		if(current_label == CATEGORY_ALLOCATION_USER || current_label == CATEGORY_ALLOCATION_UNLABELED || current_label == CATEGORY_ALLOCATION_AUTO_MAX) {			return CATEGORY_ALLOCATION_ERROR;		} else {			return CATEGORY_ALLOCATION_AUTO_MAX;		}	}
if(current_label == CATEGORY_ALLOCATION_USER || current_label == CATEGORY_ALLOCATION_UNLABELED || current_label == CATEGORY_ALLOCATION_AUTO_MAX) {			return CATEGORY_ALLOCATION_ERROR;		} else {			return CATEGORY_ALLOCATION_AUTO_MAX;		}
current_label == CATEGORY_ALLOCATION_USER || current_label == CATEGORY_ALLOCATION_UNLABELED || current_label == CATEGORY_ALLOCATION_AUTO_MAX
current_label == CATEGORY_ALLOCATION_USER || current_label == CATEGORY_ALLOCATION_UNLABELED
current_label == CATEGORY_ALLOCATION_USER
current_label
current_label
CATEGORY_ALLOCATION_USER
CATEGORY_ALLOCATION_USER
current_label == CATEGORY_ALLOCATION_UNLABELED
current_label
current_label
CATEGORY_ALLOCATION_UNLABELED
CATEGORY_ALLOCATION_UNLABELED
current_label == CATEGORY_ALLOCATION_AUTO_MAX
current_label
current_label
CATEGORY_ALLOCATION_AUTO_MAX
CATEGORY_ALLOCATION_AUTO_MAX
{			return CATEGORY_ALLOCATION_ERROR;		}
return CATEGORY_ALLOCATION_ERROR;
CATEGORY_ALLOCATION_ERROR
CATEGORY_ALLOCATION_ERROR
{			return CATEGORY_ALLOCATION_AUTO_MAX;		}
return CATEGORY_ALLOCATION_AUTO_MAX;
CATEGORY_ALLOCATION_AUTO_MAX
CATEGORY_ALLOCATION_AUTO_MAX
if(current_label == CATEGORY_ALLOCATION_USER) {			return CATEGORY_ALLOCATION_USER;	}
current_label == CATEGORY_ALLOCATION_USER
current_label
current_label
CATEGORY_ALLOCATION_USER
CATEGORY_ALLOCATION_USER
{			return CATEGORY_ALLOCATION_USER;	}
return CATEGORY_ALLOCATION_USER;
CATEGORY_ALLOCATION_USER
CATEGORY_ALLOCATION_USER
struct category *c = category_lookup_or_create(categories, category);
struct category *c = category_lookup_or_create(categories, category);
struct category
category
*c = category_lookup_or_create(categories, category)
*
c
= category_lookup_or_create(categories, category)
category_lookup_or_create(categories, category)
category_lookup_or_create
category_lookup_or_create
categories
categories
category
category
if(!c->max_allocation) {		return CATEGORY_ALLOCATION_UNLABELED;	}
!c->max_allocation
c->max_allocation
c
c
max_allocation
{		return CATEGORY_ALLOCATION_UNLABELED;	}
return CATEGORY_ALLOCATION_UNLABELED;
CATEGORY_ALLOCATION_UNLABELED
CATEGORY_ALLOCATION_UNLABELED
if(current_label == CATEGORY_ALLOCATION_AUTO_MAX) {		return CATEGORY_ALLOCATION_AUTO_MAX;	}
current_label == CATEGORY_ALLOCATION_AUTO_MAX
current_label
current_label
CATEGORY_ALLOCATION_AUTO_MAX
CATEGORY_ALLOCATION_AUTO_MAX
{		return CATEGORY_ALLOCATION_AUTO_MAX;	}
return CATEGORY_ALLOCATION_AUTO_MAX;
CATEGORY_ALLOCATION_AUTO_MAX
CATEGORY_ALLOCATION_AUTO_MAX
if(c->first_allocation) {		/* Use first allocation when it is available. */		return CATEGORY_ALLOCATION_AUTO_FIRST;	} else {		/* Use default when no enough information is available. */		return CATEGORY_ALLOCATION_AUTO_ZERO;	}
c->first_allocation
c
c
first_allocation
{		/* Use first allocation when it is available. */		return CATEGORY_ALLOCATION_AUTO_FIRST;	}
return CATEGORY_ALLOCATION_AUTO_FIRST;
CATEGORY_ALLOCATION_AUTO_FIRST
CATEGORY_ALLOCATION_AUTO_FIRST
{		/* Use default when no enough information is available. */		return CATEGORY_ALLOCATION_AUTO_ZERO;	}
return CATEGORY_ALLOCATION_AUTO_ZERO;
CATEGORY_ALLOCATION_AUTO_ZERO
CATEGORY_ALLOCATION_AUTO_ZERO
-----joern-----
(13,39,0)
(58,25,0)
(45,32,0)
(40,25,0)
(9,62,0)
(12,53,0)
(20,56,0)
(53,55,0)
(18,7,0)
(44,15,0)
(23,3,0)
(15,35,0)
(4,34,0)
(30,34,0)
(8,56,0)
(39,19,0)
(5,3,0)
(63,25,0)
(22,60,0)
(30,19,0)
(32,11,0)
(39,34,0)
(2,9,0)
(58,9,0)
(7,34,0)
(14,22,0)
(17,52,0)
(9,29,0)
(20,1,0)
(59,58,0)
(41,30,0)
(38,58,0)
(19,39,0)
(48,38,0)
(31,4,0)
(19,30,0)
(61,17,0)
(20,32,0)
(3,34,0)
(21,25,0)
(4,51,0)
(16,42,0)
(20,17,0)
(51,4,0)
(20,15,0)
(0,25,0)
(56,57,0)
(50,4,0)
(6,26,0)
(46,30,0)
(43,7,0)
(9,58,0)
(28,38,0)
(51,19,0)
(36,16,0)
(54,39,0)
(53,58,0)
(55,53,0)
(24,1,0)
(19,51,0)
(10,9,0)
(20,16,0)
(37,53,0)
(1,49,0)
(20,22,0)
(47,25,0)
(33,25,0)
(41,4,1)
(31,50,1)
(8,51,1)
(19,30,1)
(53,58,1)
(10,2,1)
(32,45,1)
(24,55,1)
(37,58,1)
(38,58,1)
(9,29,1)
(20,15,1)
(19,39,1)
(14,38,1)
(39,13,1)
(7,34,1)
(51,19,1)
(20,16,1)
(20,17,1)
(16,36,1)
(20,1,1)
(18,43,1)
(54,30,1)
(9,62,1)
(53,12,1)
(1,24,1)
(59,3,1)
(20,22,1)
(44,7,1)
(3,34,1)
(2,59,1)
(20,32,1)
(4,31,1)
(46,41,1)
(51,4,1)
(9,10,1)
(13,54,1)
(43,55,1)
(3,23,1)
(30,46,1)
(15,44,1)
(4,34,1)
(45,3,1)
(36,38,1)
(7,18,1)
(30,34,1)
(17,61,1)
(48,28,1)
(5,27,1)
(22,14,1)
(56,8,1)
(39,34,1)
(12,37,1)
(28,7,1)
(50,27,1)
(38,48,1)
(61,51,1)
(20,56,1)
(55,53,1)
(23,5,1)
(58,9,1)
(53,58,2)
(3,27,2)
(37,3,2)
(20,32,2)
(9,29,2)
(39,30,2)
(14,38,2)
(19,39,2)
(1,55,2)
(51,19,2)
(19,30,2)
(54,30,2)
(51,27,2)
(38,7,2)
(39,34,2)
(55,53,2)
(38,58,2)
(2,3,2)
(43,55,2)
(20,1,2)
(45,3,2)
(4,27,2)
(58,9,2)
(32,3,2)
(8,51,2)
(28,7,2)
(10,3,2)
(55,3,2)
(7,55,2)
(19,4,2)
(22,38,2)
(61,51,2)
(48,7,2)
(12,3,2)
(3,34,2)
(20,56,2)
(16,38,2)
(7,34,2)
(20,17,2)
(41,4,2)
(24,55,2)
(20,22,2)
(20,16,2)
(31,27,2)
(20,15,2)
(30,4,2)
(36,38,2)
(13,30,2)
(46,4,2)
(30,34,2)
(51,4,2)
(58,3,2)
(4,34,2)
(5,27,2)
(59,3,2)
(50,27,2)
(9,3,2)
(15,7,2)
(18,55,2)
(44,7,2)
(17,51,2)
(23,27,2)
(56,51,2)
(9,62,2)
(53,3,2)
-----------------------------------
(0,if(c->first_allocation)
(1,return CATEGORY_ALLOCATION_UNLABELED;)
(2,categories)
(3,current_label == CATEGORY_ALLOCATION_USER)
(4,current_label == CATEGORY_ALLOCATION_USER)
(5,current_label)
(6,if(current_label == CATEGORY_ALLOCATION_USER || current_label == CATEGORY_ALLOCATION_UNLABELED || current_label == CATEGORY_ALLOCATION_AUTO_MAX)
(7,current_label == CATEGORY_ALLOCATION_AUTO_MAX)
(8,CATEGORY_ALLOCATION_AUTO_MAX)
(9,category_lookup_or_create(categories, category)
(10,category)
(11,)
(12,max_allocation)
(13,CATEGORY_ALLOCATION_AUTO_MAX)
(14,CATEGORY_ALLOCATION_AUTO_ZERO)
(15,return CATEGORY_ALLOCATION_AUTO_MAX;)
(16,return CATEGORY_ALLOCATION_AUTO_FIRST;)
(17,return CATEGORY_ALLOCATION_ERROR;)
(18,CATEGORY_ALLOCATION_AUTO_MAX)
(19,current_label == CATEGORY_ALLOCATION_UNLABELED || current_label == CATEGORY_ALLOCATION_AUTO_MAX)
(20,RET)
(21,c)
(22,return CATEGORY_ALLOCATION_AUTO_ZERO;)
(23,CATEGORY_ALLOCATION_USER)
(24,CATEGORY_ALLOCATION_UNLABELED)
(25,)
(26,)
(27,resource_overflow)
(28,c)
(29,const char *category)
(30,current_label == CATEGORY_ALLOCATION_UNLABELED)
(31,CATEGORY_ALLOCATION_USER)
(32,return CATEGORY_ALLOCATION_USER;)
(33,if(current_label == CATEGORY_ALLOCATION_AUTO_MAX)
(34,category_allocation_t current_label)
(35,)
(36,CATEGORY_ALLOCATION_AUTO_FIRST)
(37,c)
(38,c->first_allocation)
(39,current_label == CATEGORY_ALLOCATION_AUTO_MAX)
(40,if(!c->max_allocation)
(41,current_label)
(42,)
(43,current_label)
(44,CATEGORY_ALLOCATION_AUTO_MAX)
(45,CATEGORY_ALLOCATION_USER)
(46,CATEGORY_ALLOCATION_UNLABELED)
(47,if(current_label == CATEGORY_ALLOCATION_USER)
(48,first_allocation)
(49,)
(50,current_label)
(51,current_label == CATEGORY_ALLOCATION_USER || current_label == CATEGORY_ALLOCATION_UNLABELED || current_label == CATEGORY_ALLOCATION_AUTO_MAX)
(52,)
(53,c->max_allocation)
(54,current_label)
(55,!c->max_allocation)
(56,return CATEGORY_ALLOCATION_AUTO_MAX;)
(57,)
(58,*c = category_lookup_or_create(categories, category)
(59,c)
(60,)
(61,CATEGORY_ALLOCATION_ERROR)
(62,struct hash_table *categories)
(63,if(resource_overflow)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^