-----label-----
1
-----code-----
static void *start_propstat(void *userdata, void *response)
{
    ne_prop_result_set *set = response;
    ne_propfind_handler *hdl = userdata;
    struct propstat *pstat;
    int n;

    if (++hdl->current->counter == MAX_PROP_COUNTER) {
        ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"));
        return NULL;
    }

    n = set->numpstats;
    set->pstats = ne_realloc(set->pstats, sizeof(struct propstat) * (n+1));
    set->numpstats = n+1;

    pstat = &set->pstats[n];
    memset(pstat, 0, sizeof(*pstat));

    /* And return this as the new pstat. */
    return &set->pstats[n];
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
6,7
6,8
8,9
8,10
11,12
11,13
13,14
13,15
16,17
16,18
16,19
16,20
16,21
16,22
16,23
16,24
16,25
16,26
16,27
17,18
18,19
18,20
19,20
21,22
21,23
21,24
24,25
25,26
27,28
28,29
28,30
29,30
31,32
31,33
31,34
34,35
35,36
37,38
38,39
38,40
39,40
41,42
41,43
44,45
45,46
45,47
47,48
49,50
49,51
50,51
50,52
51,52
52,53
52,54
53,54
53,55
54,55
58,59
60,61
60,62
61,62
62,63
62,64
62,65
63,64
65,66
65,67
66,67
69,70
69,71
70,71
73,74
74,75
76,77
77,78
77,79
78,79
80,81
80,82
81,82
84,85
85,86
85,87
86,87
86,88
87,88
90,91
90,92
90,93
91,92
93,94
93,95
94,95
97,98
97,99
98,99
99,100
99,101
100,101
103,104
104,105
104,106
105,106
108,109
109,110
109,111
110,111
110,112
111,112
114,115
114,116
115,116
118,119
119,120
119,121
120,121
122,123
123,124
123,125
124,125
124,126
125,126
128,129
130,131
131,132
131,133
131,134
131,135
132,133
134,135
137,138
138,139
139,140
140,141
142,143
143,144
144,145
144,146
145,146
145,147
146,147
149,150
-----nextToken-----
2,4,5,7,9,10,12,14,15,20,22,23,26,30,32,33,36,40,42,43,46,48,55,56,57,59,64,67,68,71,72,75,79,82,83,88,89,92,95,96,101,102,106,107,112,113,116,117,121,126,127,129,133,135,136,141,147,148,150
-----computeFrom-----
50,51
50,52
77,78
77,79
85,86
85,87
97,98
97,99
104,105
104,106
109,110
109,111
114,115
114,116
119,120
119,121
-----guardedBy-----
55,67
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;IfStatement;BinaryExpression;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;UnaryExpression;UnaryExpression;IdExpression;Name;ReturnStatement;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;
-----ast_node-----
static void *start_propstat(void *userdata, void *response){    ne_prop_result_set *set = response;    ne_propfind_handler *hdl = userdata;    struct propstat *pstat;    int n;    if (++hdl->current->counter == MAX_PROP_COUNTER) {        ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"));        return NULL;    }    n = set->numpstats;    set->pstats = ne_realloc(set->pstats, sizeof(struct propstat) * (n+1));    set->numpstats = n+1;    pstat = &set->pstats[n];    memset(pstat, 0, sizeof(*pstat));    /* And return this as the new pstat. */    return &set->pstats[n];}
static void
*start_propstat(void *userdata, void *response)
*
start_propstat
void *userdata
void
*userdata
*
userdata
void *response
void
*response
*
response
{    ne_prop_result_set *set = response;    ne_propfind_handler *hdl = userdata;    struct propstat *pstat;    int n;    if (++hdl->current->counter == MAX_PROP_COUNTER) {        ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"));        return NULL;    }    n = set->numpstats;    set->pstats = ne_realloc(set->pstats, sizeof(struct propstat) * (n+1));    set->numpstats = n+1;    pstat = &set->pstats[n];    memset(pstat, 0, sizeof(*pstat));    /* And return this as the new pstat. */    return &set->pstats[n];}
ne_prop_result_set *set = response;
ne_prop_result_set *set = response;
ne_prop_result_set
ne_prop_result_set
*set = response
*
set
= response
response
response
ne_propfind_handler *hdl = userdata;
ne_propfind_handler *hdl = userdata;
ne_propfind_handler
ne_propfind_handler
*hdl = userdata
*
hdl
= userdata
userdata
userdata
struct propstat *pstat;
struct propstat *pstat;
struct propstat
propstat
*pstat
*
pstat
int n;
int n;
int
n
n
if (++hdl->current->counter == MAX_PROP_COUNTER) {        ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"));        return NULL;    }
++hdl->current->counter == MAX_PROP_COUNTER
++hdl->current->counter
hdl->current->counter
hdl->current
hdl
hdl
current
counter
MAX_PROP_COUNTER
MAX_PROP_COUNTER
{        ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"));        return NULL;    }
ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"));
ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"))
ne_xml_set_error
ne_xml_set_error
hdl->parser
hdl
hdl
parser
_("Response exceeds maximum property count")
_
_
"Response exceeds maximum property count"
return NULL;
NULL
NULL
n = set->numpstats;
n = set->numpstats
n
n
set->numpstats
set
set
numpstats
set->pstats = ne_realloc(set->pstats, sizeof(struct propstat) * (n+1));
set->pstats = ne_realloc(set->pstats, sizeof(struct propstat) * (n+1))
set->pstats
set
set
pstats
ne_realloc(set->pstats, sizeof(struct propstat) * (n+1))
ne_realloc
ne_realloc
set->pstats
set
set
pstats
sizeof(struct propstat) * (n+1)
sizeof(struct propstat)
struct propstat
struct propstat
propstat

(n+1)
n+1
n
n
1
set->numpstats = n+1;
set->numpstats = n+1
set->numpstats
set
set
numpstats
n+1
n
n
1
pstat = &set->pstats[n];
pstat = &set->pstats[n]
pstat
pstat
&set->pstats[n]
set->pstats[n]
set->pstats
set
set
pstats
n
n
memset(pstat, 0, sizeof(*pstat));
memset(pstat, 0, sizeof(*pstat))
memset
memset
pstat
pstat
0
sizeof(*pstat)
(*pstat)
*pstat
pstat
pstat
return &set->pstats[n];
&set->pstats[n]
set->pstats[n]
set->pstats
set
set
pstats
n
n
-----joern-----
(51,14,0)
(39,5,0)
(4,33,0)
(0,50,0)
(59,50,0)
(23,51,0)
(53,23,0)
(37,67,0)
(75,12,0)
(48,36,0)
(37,10,0)
(52,55,0)
(47,73,0)
(67,14,0)
(38,49,0)
(23,36,0)
(66,51,0)
(27,68,0)
(55,36,0)
(67,73,0)
(67,37,0)
(49,70,0)
(3,41,0)
(44,50,0)
(45,14,0)
(19,5,0)
(12,75,0)
(4,52,0)
(1,75,0)
(5,39,0)
(74,67,0)
(37,76,0)
(33,4,0)
(13,14,0)
(56,47,0)
(70,49,0)
(51,59,0)
(12,27,0)
(17,34,0)
(21,70,0)
(14,43,0)
(22,52,0)
(63,70,0)
(5,76,0)
(49,28,0)
(35,12,0)
(69,33,0)
(5,19,0)
(3,48,0)
(78,13,0)
(30,24,0)
(9,37,0)
(58,24,0)
(12,35,0)
(47,14,0)
(53,62,0)
(16,62,0)
(13,76,0)
(40,36,0)
(29,36,0)
(7,42,0)
(70,55,0)
(68,27,0)
(35,73,0)
(55,60,0)
(4,6,0)
(26,3,0)
(62,6,0)
(32,14,0)
(34,41,0)
(50,76,0)
(14,36,0)
(35,24,0)
(31,51,0)
(57,55,0)
(15,48,0)
(18,55,0)
(73,35,0)
(65,34,0)
(10,37,0)
(48,19,0)
(24,35,0)
(2,47,0)
(50,59,0)
(10,23,0)
(64,75,0)
(28,49,0)
(34,48,0)
(61,36,0)
(77,36,0)
(25,76,0)
(46,39,0)
(52,4,0)
(28,42,0)
(71,5,0)
(27,12,0)
(72,39,0)
(76,36,0)
(54,13,0)
(24,14,0)
(75,76,0)
(8,67,0)
(34,36,0)
(76,13,0)
(39,73,0)
(20,52,0)
(39,14,0)
(23,47,0)
(41,3,0)
(19,48,0)
(73,36,0)
(59,36,0)
(42,28,0)
(11,36,0)
(41,34,0)
(70,55,1)
(33,69,1)
(2,76,1)
(26,17,1)
(50,76,1)
(13,54,1)
(44,0,1)
(35,12,1)
(74,34,1)
(48,19,1)
(46,15,1)
(31,73,1)
(54,78,1)
(75,1,1)
(22,20,1)
(55,60,1)
(34,48,1)
(27,24,1)
(5,76,1)
(14,43,1)
(34,41,1)
(20,42,1)
(4,52,1)
(25,42,1)
(57,14,1)
(52,55,1)
(78,25,1)
(17,65,1)
(1,64,1)
(14,32,1)
(76,13,1)
(72,46,1)
(50,44,1)
(5,71,1)
(12,27,1)
(10,37,1)
(18,57,1)
(38,70,1)
(67,73,1)
(42,7,1)
(42,28,1)
(47,14,1)
(9,67,1)
(12,75,1)
(66,31,1)
(27,68,1)
(23,10,1)
(0,51,1)
(64,27,1)
(39,73,1)
(58,47,1)
(3,48,1)
(63,55,1)
(71,39,1)
(24,14,1)
(59,50,1)
(21,63,1)
(73,35,1)
(67,14,1)
(51,66,1)
(67,8,1)
(8,74,1)
(32,45,1)
(51,14,1)
(37,9,1)
(39,14,1)
(30,58,1)
(24,30,1)
(69,52,1)
(3,26,1)
(7,28,1)
(41,3,1)
(39,72,1)
(47,56,1)
(5,39,1)
(37,76,1)
(53,62,1)
(37,67,1)
(23,51,1)
(15,59,1)
(65,48,1)
(16,4,1)
(49,38,1)
(56,2,1)
(70,21,1)
(28,49,1)
(49,70,1)
(55,18,1)
(75,76,1)
(4,33,1)
(13,14,1)
(19,5,1)
(23,47,1)
(62,16,1)
(35,24,1)
(52,22,1)
(53,23,1)
(23,42,2)
(37,42,2)
(64,42,2)
(8,42,2)
(54,42,2)
(34,42,2)
(3,48,2)
(13,14,2)
(27,42,2)
(34,41,2)
(23,47,2)
(53,23,2)
(70,55,2)
(39,73,2)
(4,52,2)
(23,51,2)
(25,42,2)
(5,39,2)
(35,42,2)
(12,42,2)
(71,42,2)
(35,12,2)
(51,14,2)
(51,42,2)
(9,42,2)
(52,55,2)
(12,75,2)
(14,43,2)
(33,42,2)
(50,42,2)
(20,42,2)
(28,49,2)
(16,42,2)
(67,42,2)
(66,42,2)
(46,42,2)
(12,27,2)
(10,42,2)
(47,42,2)
(69,42,2)
(41,42,2)
(48,42,2)
(4,33,2)
(15,42,2)
(26,42,2)
(24,14,2)
(35,24,2)
(73,42,2)
(65,42,2)
(3,42,2)
(73,35,2)
(30,42,2)
(75,42,2)
(1,42,2)
(62,42,2)
(17,42,2)
(37,76,2)
(13,42,2)
(2,42,2)
(4,42,2)
(76,13,2)
(53,62,2)
(49,70,2)
(31,42,2)
(34,48,2)
(19,42,2)
(59,42,2)
(47,14,2)
(59,50,2)
(72,42,2)
(55,60,2)
(50,76,2)
(0,42,2)
(74,42,2)
(5,42,2)
(56,42,2)
(39,14,2)
(67,14,2)
(67,73,2)
(27,68,2)
(24,42,2)
(41,3,2)
(19,5,2)
(58,42,2)
(76,42,2)
(5,76,2)
(22,42,2)
(10,37,2)
(39,42,2)
(78,42,2)
(37,67,2)
(42,28,2)
(52,42,2)
(48,19,2)
(75,76,2)
(44,42,2)
-----------------------------------
(0,n)
(1,1)
(2,set)
(3,*pstat)
(4,ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count")
(5,set->pstats[n])
(6,)
(7,MAX_PROP_COUNTER)
(8,pstats)
(9,n)
(10,&set->pstats[n])
(11,pstat)
(12,sizeof(struct propstat)
(13,set->numpstats)
(14,*set = response)
(15,pstat)
(16,NULL)
(17,0)
(18,userdata)
(19,&set->pstats[n])
(20,hdl)
(21,current)
(22,parser)
(23,return &set->pstats[n];)
(24,set->pstats)
(25,n)
(26,pstat)
(27,sizeof(struct propstat)
(28,++hdl->current->counter)
(29,if (++hdl->current->counter == MAX_PROP_COUNTER)
(30,pstats)
(31,set)
(32,response)
(33,_("Response exceeds maximum property count")
(34,memset(pstat, 0, sizeof(*pstat)
(35,ne_realloc(set->pstats, sizeof(struct propstat)
(36,)
(37,set->pstats[n])
(38,counter)
(39,set->pstats)
(40,n)
(41,sizeof(*pstat)
(42,++hdl->current->counter == MAX_PROP_COUNTER)
(43,void *response)
(44,1)
(45,set)
(46,set)
(47,set->pstats)
(48,pstat = &set->pstats[n])
(49,hdl->current->counter)
(50,n+1)
(51,set->numpstats)
(52,hdl->parser)
(53,RET)
(54,numpstats)
(55,*hdl = userdata)
(56,pstats)
(57,hdl)
(58,set)
(59,set->numpstats = n+1)
(60,void *userdata)
(61,hdl)
(62,return NULL;)
(63,hdl)
(64,n)
(65,pstat)
(66,numpstats)
(67,set->pstats)
(68,struct propstat)
(69,"Response exceeds maximum property count")
(70,hdl->current)
(71,n)
(72,pstats)
(73,set->pstats = ne_realloc(set->pstats, sizeof(struct propstat)
(74,set)
(75,n+1)
(76,n = set->numpstats)
(77,set)
(78,set)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^