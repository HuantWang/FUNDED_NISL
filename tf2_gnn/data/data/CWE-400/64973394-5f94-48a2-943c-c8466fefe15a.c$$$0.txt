-----label-----
0
-----code-----
static int startelm(void *userdata, int parent,
                    const char *nspace, const char *name, const char **atts)
{
    ne_propfind_handler *hdl = userdata;
    struct propstat *pstat = ne_207_get_current_propstat(hdl->parser207);
    struct prop *prop;
    int n;
    const char *lang;

    /* Just handle all children of propstat and their descendants. */
    if ((parent != NE_207_STATE_PROP && parent != ELM_flatprop) 
        || pstat == NULL)
        return NE_XML_DECLINE;

    if (parent == ELM_flatprop) {
        /* collecting the flatprop value. */
        hdl->depth++;
        if (hdl->value->used < MAX_FLATPROP_LEN)
            ne_buffer_concat(hdl->value, "<", name, ">", NULL);
        return ELM_flatprop;
    }        

    /* Enforce maximum number of properties per resource to prevent a
     * memory exhaustion attack by a hostile server. */
    if (++hdl->current->counter == MAX_PROP_COUNTER) {
        ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"));
        return NE_XML_ABORT;
    }

    /* Add a property to this propstat */
    n = pstat->numprops;

    pstat->props = ne_realloc(pstat->props, sizeof(struct prop) * (n + 1));
    pstat->numprops = n+1;

    /* Fill in the new property. */
    prop = &pstat->props[n];

    prop->pname.name = prop->name = ne_strdup(name);
    if (nspace[0] == '\0') {
	prop->pname.nspace = prop->nspace = NULL;
    } else {
	prop->pname.nspace = prop->nspace = ne_strdup(nspace);
    }
    prop->value = NULL;

    NE_DEBUG(NE_DBG_XML, "Got property #%d: {%s}%s.\n", n, 
	     NSPACE(prop->nspace), prop->name);

    /* This is under discussion at time of writing (April '01), and it
     * looks like we need to retrieve the xml:lang property from any
     * element here or above.
     *
     * Also, I think we might need attribute namespace handling here.  */
    lang = ne_xml_get_attr(hdl->parser, atts, NULL, "xml:lang");
    if (lang != NULL) {
	prop->lang = ne_strdup(lang);
	NE_DEBUG(NE_DBG_XML, "Property language is %s\n", prop->lang);
    } else {
	prop->lang = NULL;
    }

    hdl->depth = 0;

    return ELM_flatprop;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
3,9
5,6
5,7
7,8
7,9
10,11
10,12
12,13
14,15
14,16
16,17
16,18
19,20
19,21
21,22
21,23
24,25
24,26
26,27
26,28
26,29
30,31
30,32
30,33
30,34
30,35
30,36
30,37
30,38
30,39
30,40
30,41
30,42
30,43
30,44
30,45
30,46
30,47
30,48
30,49
30,50
31,32
32,33
32,34
33,34
35,36
35,37
35,38
38,39
39,40
41,42
42,43
42,44
43,44
45,46
45,47
45,48
48,49
49,50
49,51
50,51
52,53
52,54
53,54
56,57
57,58
57,59
58,59
60,61
60,62
63,64
64,65
64,66
66,67
68,69
69,70
69,71
71,72
71,73
74,75
74,76
75,76
75,77
76,77
77,78
77,79
78,79
78,80
79,80
81,82
83,84
83,85
84,85
86,87
88,89
88,90
89,90
91,92
93,94
94,95
96,97
96,98
97,98
97,99
98,99
100,101
102,103
102,104
102,105
103,104
104,105
105,106
105,107
106,107
109,110
109,111
110,111
110,112
111,112
111,113
112,113
112,114
113,114
117,118
119,120
120,121
120,122
120,123
120,124
120,125
120,126
121,122
123,124
123,125
124,125
128,129
131,132
133,134
134,135
136,137
136,138
137,138
137,139
138,139
139,140
139,141
140,141
140,142
141,142
145,146
147,148
147,149
148,149
149,150
149,151
149,152
150,151
152,153
152,154
153,154
156,157
156,158
157,158
160,161
161,162
163,164
164,165
164,166
165,166
167,168
167,169
168,169
171,172
172,173
172,174
173,174
173,175
174,175
177,178
177,179
177,180
178,179
180,181
180,182
181,182
184,185
184,186
185,186
186,187
186,188
187,188
190,191
191,192
191,193
192,193
195,196
196,197
196,198
197,198
197,199
198,199
201,202
201,203
202,203
205,206
206,207
206,208
207,208
209,210
210,211
210,212
211,212
211,213
212,213
215,216
217,218
218,219
218,220
219,220
219,221
220,221
220,222
221,222
225,226
225,227
226,227
226,228
227,228
230,231
230,232
231,232
233,234
235,236
235,237
235,238
236,237
236,238
237,238
237,239
238,239
242,243
243,244
244,245
244,246
245,246
245,247
246,247
246,248
247,248
251,252
251,253
252,253
252,254
253,254
256,257
258,259
259,260
260,261
260,262
261,262
261,263
262,263
262,264
263,264
267,268
267,269
268,269
268,270
269,270
272,273
272,274
273,274
275,276
277,278
278,279
278,280
279,280
279,281
280,281
283,284
285,286
286,287
286,288
286,289
286,290
286,291
286,292
287,288
289,290
292,293
294,295
294,296
295,296
297,298
297,299
298,299
301,302
301,303
302,303
305,306
306,307
306,308
307,308
309,310
309,311
309,312
309,313
309,314
310,311
312,313
312,314
313,314
316,317
318,319
321,322
321,323
321,324
322,323
322,324
323,324
325,326
327,328
327,329
328,329
329,330
329,331
330,331
330,332
331,332
334,335
334,336
335,336
337,338
339,340
340,341
340,342
340,343
340,344
341,342
343,344
346,347
346,348
347,348
350,351
351,352
352,353
352,354
353,354
353,355
354,355
357,358
359,360
360,361
360,362
361,362
361,363
362,363
366,367
367,368
-----nextToken-----
2,4,6,8,9,11,13,15,17,18,20,22,23,25,27,28,29,34,36,37,40,44,46,47,51,54,55,59,61,62,65,67,70,72,73,80,82,85,87,90,92,95,99,101,107,108,114,115,116,118,122,125,126,127,129,130,132,135,142,143,144,146,151,154,155,158,159,162,166,169,170,175,176,179,182,183,188,189,193,194,199,200,203,204,208,213,214,216,222,223,224,228,229,232,234,239,240,241,248,249,250,254,255,257,264,265,266,270,271,274,276,281,282,284,288,290,291,293,296,299,300,303,304,308,311,314,315,317,319,320,324,326,332,333,336,338,342,344,345,348,349,355,356,358,363,364,365,368
-----computeFrom-----
75,76
75,77
77,78
77,79
78,79
78,80
83,84
83,85
88,89
88,90
97,98
97,99
110,111
110,112
137,138
137,139
164,165
164,166
172,173
172,174
184,185
184,186
191,192
191,193
196,197
196,198
201,202
201,203
206,207
206,208
218,219
218,220
225,226
225,227
236,237
236,238
244,245
244,246
251,252
251,253
260,261
260,262
267,268
267,269
278,279
278,280
306,307
306,308
322,323
322,324
329,330
329,331
352,353
352,354
360,361
360,362
-----guardedBy-----
101,135
114,125
115,126
142,154
239,255
324,349
-----guardedByNegation-----
239,276
326,358
324,356
-----lastLexicalUse-----
239,276
324,356
-----jump-----
239,276
324,356
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;IfStatement;BinaryExpression;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ReturnStatement;IdExpression;Name;IfStatement;BinaryExpression;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;ReturnStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ReturnStatement;IdExpression;Name;
-----ast_node-----
static int startelm(void *userdata, int parent,                    const char *nspace, const char *name, const char **atts){    ne_propfind_handler *hdl = userdata;    struct propstat *pstat = ne_207_get_current_propstat(hdl->parser207);    struct prop *prop;    int n;    const char *lang;    /* Just handle all children of propstat and their descendants. */    if ((parent != NE_207_STATE_PROP && parent != ELM_flatprop)         || pstat == NULL)        return NE_XML_DECLINE;    if (parent == ELM_flatprop) {        /* collecting the flatprop value. */        hdl->depth++;        if (hdl->value->used < MAX_FLATPROP_LEN)            ne_buffer_concat(hdl->value, "<", name, ">", NULL);        return ELM_flatprop;    }            /* Enforce maximum number of properties per resource to prevent a     * memory exhaustion attack by a hostile server. */    if (++hdl->current->counter == MAX_PROP_COUNTER) {        ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"));        return NE_XML_ABORT;    }    /* Add a property to this propstat */    n = pstat->numprops;    pstat->props = ne_realloc(pstat->props, sizeof(struct prop) * (n + 1));    pstat->numprops = n+1;    /* Fill in the new property. */    prop = &pstat->props[n];    prop->pname.name = prop->name = ne_strdup(name);    if (nspace[0] == '\0') {	prop->pname.nspace = prop->nspace = NULL;    } else {	prop->pname.nspace = prop->nspace = ne_strdup(nspace);    }    prop->value = NULL;    NE_DEBUG(NE_DBG_XML, "Got property #%d: {%s}%s.\n", n, 	     NSPACE(prop->nspace), prop->name);    /* This is under discussion at time of writing (April '01), and it     * looks like we need to retrieve the xml:lang property from any     * element here or above.     *     * Also, I think we might need attribute namespace handling here.  */    lang = ne_xml_get_attr(hdl->parser, atts, NULL, "xml:lang");    if (lang != NULL) {	prop->lang = ne_strdup(lang);	NE_DEBUG(NE_DBG_XML, "Property language is %s\n", prop->lang);    } else {	prop->lang = NULL;    }    hdl->depth = 0;    return ELM_flatprop;}
static int
startelm(void *userdata, int parent,                    const char *nspace, const char *name, const char **atts)
startelm
void *userdata
void
*userdata
*
userdata
int parent
int
parent
parent
const char *nspace
const char
*nspace
*
nspace
const char *name
const char
*name
*
name
const char **atts
const char
**atts
*
*
atts
{    ne_propfind_handler *hdl = userdata;    struct propstat *pstat = ne_207_get_current_propstat(hdl->parser207);    struct prop *prop;    int n;    const char *lang;    /* Just handle all children of propstat and their descendants. */    if ((parent != NE_207_STATE_PROP && parent != ELM_flatprop)         || pstat == NULL)        return NE_XML_DECLINE;    if (parent == ELM_flatprop) {        /* collecting the flatprop value. */        hdl->depth++;        if (hdl->value->used < MAX_FLATPROP_LEN)            ne_buffer_concat(hdl->value, "<", name, ">", NULL);        return ELM_flatprop;    }            /* Enforce maximum number of properties per resource to prevent a     * memory exhaustion attack by a hostile server. */    if (++hdl->current->counter == MAX_PROP_COUNTER) {        ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"));        return NE_XML_ABORT;    }    /* Add a property to this propstat */    n = pstat->numprops;    pstat->props = ne_realloc(pstat->props, sizeof(struct prop) * (n + 1));    pstat->numprops = n+1;    /* Fill in the new property. */    prop = &pstat->props[n];    prop->pname.name = prop->name = ne_strdup(name);    if (nspace[0] == '\0') {	prop->pname.nspace = prop->nspace = NULL;    } else {	prop->pname.nspace = prop->nspace = ne_strdup(nspace);    }    prop->value = NULL;    NE_DEBUG(NE_DBG_XML, "Got property #%d: {%s}%s.\n", n, 	     NSPACE(prop->nspace), prop->name);    /* This is under discussion at time of writing (April '01), and it     * looks like we need to retrieve the xml:lang property from any     * element here or above.     *     * Also, I think we might need attribute namespace handling here.  */    lang = ne_xml_get_attr(hdl->parser, atts, NULL, "xml:lang");    if (lang != NULL) {	prop->lang = ne_strdup(lang);	NE_DEBUG(NE_DBG_XML, "Property language is %s\n", prop->lang);    } else {	prop->lang = NULL;    }    hdl->depth = 0;    return ELM_flatprop;}
ne_propfind_handler *hdl = userdata;
ne_propfind_handler *hdl = userdata;
ne_propfind_handler
ne_propfind_handler
*hdl = userdata
*
hdl
= userdata
userdata
userdata
struct propstat *pstat = ne_207_get_current_propstat(hdl->parser207);
struct propstat *pstat = ne_207_get_current_propstat(hdl->parser207);
struct propstat
propstat
*pstat = ne_207_get_current_propstat(hdl->parser207)
*
pstat
= ne_207_get_current_propstat(hdl->parser207)
ne_207_get_current_propstat(hdl->parser207)
ne_207_get_current_propstat
ne_207_get_current_propstat
hdl->parser207
hdl
hdl
parser207
struct prop *prop;
struct prop *prop;
struct prop
prop
*prop
*
prop
int n;
int n;
int
n
n
const char *lang;
const char *lang;
const char
*lang
*
lang
if ((parent != NE_207_STATE_PROP && parent != ELM_flatprop)         || pstat == NULL)        return NE_XML_DECLINE;
(parent != NE_207_STATE_PROP && parent != ELM_flatprop)         || pstat == NULL
(parent != NE_207_STATE_PROP && parent != ELM_flatprop)
parent != NE_207_STATE_PROP && parent != ELM_flatprop
parent != NE_207_STATE_PROP
parent
parent
NE_207_STATE_PROP
NE_207_STATE_PROP
parent != ELM_flatprop
parent
parent
ELM_flatprop
ELM_flatprop
pstat == NULL
pstat
pstat
NULL
NULL
return NE_XML_DECLINE;
NE_XML_DECLINE
NE_XML_DECLINE
if (parent == ELM_flatprop) {        /* collecting the flatprop value. */        hdl->depth++;        if (hdl->value->used < MAX_FLATPROP_LEN)            ne_buffer_concat(hdl->value, "<", name, ">", NULL);        return ELM_flatprop;    }
parent == ELM_flatprop
parent
parent
ELM_flatprop
ELM_flatprop
{        /* collecting the flatprop value. */        hdl->depth++;        if (hdl->value->used < MAX_FLATPROP_LEN)            ne_buffer_concat(hdl->value, "<", name, ">", NULL);        return ELM_flatprop;    }
hdl->depth++;
hdl->depth++
hdl->depth
hdl
hdl
depth
if (hdl->value->used < MAX_FLATPROP_LEN)            ne_buffer_concat(hdl->value, "<", name, ">", NULL);
hdl->value->used < MAX_FLATPROP_LEN
hdl->value->used
hdl->value
hdl
hdl
value
used
MAX_FLATPROP_LEN
MAX_FLATPROP_LEN
ne_buffer_concat(hdl->value, "<", name, ">", NULL);
ne_buffer_concat(hdl->value, "<", name, ">", NULL)
ne_buffer_concat
ne_buffer_concat
hdl->value
hdl
hdl
value
"<"
name
name
">"
NULL
NULL
return ELM_flatprop;
ELM_flatprop
ELM_flatprop
if (++hdl->current->counter == MAX_PROP_COUNTER) {        ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"));        return NE_XML_ABORT;    }
++hdl->current->counter == MAX_PROP_COUNTER
++hdl->current->counter
hdl->current->counter
hdl->current
hdl
hdl
current
counter
MAX_PROP_COUNTER
MAX_PROP_COUNTER
{        ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"));        return NE_XML_ABORT;    }
ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"));
ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count"))
ne_xml_set_error
ne_xml_set_error
hdl->parser
hdl
hdl
parser
_("Response exceeds maximum property count")
_
_
"Response exceeds maximum property count"
return NE_XML_ABORT;
NE_XML_ABORT
NE_XML_ABORT
n = pstat->numprops;
n = pstat->numprops
n
n
pstat->numprops
pstat
pstat
numprops
pstat->props = ne_realloc(pstat->props, sizeof(struct prop) * (n + 1));
pstat->props = ne_realloc(pstat->props, sizeof(struct prop) * (n + 1))
pstat->props
pstat
pstat
props
ne_realloc(pstat->props, sizeof(struct prop) * (n + 1))
ne_realloc
ne_realloc
pstat->props
pstat
pstat
props
sizeof(struct prop) * (n + 1)
sizeof(struct prop)
struct prop
struct prop
prop

(n + 1)
n + 1
n
n
1
pstat->numprops = n+1;
pstat->numprops = n+1
pstat->numprops
pstat
pstat
numprops
n+1
n
n
1
prop = &pstat->props[n];
prop = &pstat->props[n]
prop
prop
&pstat->props[n]
pstat->props[n]
pstat->props
pstat
pstat
props
n
n
prop->pname.name = prop->name = ne_strdup(name);
prop->pname.name = prop->name = ne_strdup(name)
prop->pname.name
prop->pname
prop
prop
pname
name
prop->name = ne_strdup(name)
prop->name
prop
prop
name
ne_strdup(name)
ne_strdup
ne_strdup
name
name
if (nspace[0] == '\0') {	prop->pname.nspace = prop->nspace = NULL;    } else {	prop->pname.nspace = prop->nspace = ne_strdup(nspace);    }
nspace[0] == '\0'
nspace[0]
nspace
nspace
0
'\0'
{	prop->pname.nspace = prop->nspace = NULL;    }
prop->pname.nspace = prop->nspace = NULL;
prop->pname.nspace = prop->nspace = NULL
prop->pname.nspace
prop->pname
prop
prop
pname
nspace
prop->nspace = NULL
prop->nspace
prop
prop
nspace
NULL
NULL
{	prop->pname.nspace = prop->nspace = ne_strdup(nspace);    }
prop->pname.nspace = prop->nspace = ne_strdup(nspace);
prop->pname.nspace = prop->nspace = ne_strdup(nspace)
prop->pname.nspace
prop->pname
prop
prop
pname
nspace
prop->nspace = ne_strdup(nspace)
prop->nspace
prop
prop
nspace
ne_strdup(nspace)
ne_strdup
ne_strdup
nspace
nspace
prop->value = NULL;
prop->value = NULL
prop->value
prop
prop
value
NULL
NULL
NE_DEBUG(NE_DBG_XML, "Got property #%d: {%s}%s.\n", n, 	     NSPACE(prop->nspace), prop->name);
NE_DEBUG(NE_DBG_XML, "Got property #%d: {%s}%s.\n", n, 	     NSPACE(prop->nspace), prop->name)
NE_DEBUG
NE_DEBUG
NE_DBG_XML
NE_DBG_XML
"Got property #%d: {%s}%s.\n"
n
n
NSPACE(prop->nspace)
NSPACE
NSPACE
prop->nspace
prop
prop
nspace
prop->name
prop
prop
name
lang = ne_xml_get_attr(hdl->parser, atts, NULL, "xml:lang");
lang = ne_xml_get_attr(hdl->parser, atts, NULL, "xml:lang")
lang
lang
ne_xml_get_attr(hdl->parser, atts, NULL, "xml:lang")
ne_xml_get_attr
ne_xml_get_attr
hdl->parser
hdl
hdl
parser
atts
atts
NULL
NULL
"xml:lang"
if (lang != NULL) {	prop->lang = ne_strdup(lang);	NE_DEBUG(NE_DBG_XML, "Property language is %s\n", prop->lang);    } else {	prop->lang = NULL;    }
lang != NULL
lang
lang
NULL
NULL
{	prop->lang = ne_strdup(lang);	NE_DEBUG(NE_DBG_XML, "Property language is %s\n", prop->lang);    }
prop->lang = ne_strdup(lang);
prop->lang = ne_strdup(lang)
prop->lang
prop
prop
lang
ne_strdup(lang)
ne_strdup
ne_strdup
lang
lang
NE_DEBUG(NE_DBG_XML, "Property language is %s\n", prop->lang);
NE_DEBUG(NE_DBG_XML, "Property language is %s\n", prop->lang)
NE_DEBUG
NE_DEBUG
NE_DBG_XML
NE_DBG_XML
"Property language is %s\n"
prop->lang
prop
prop
lang
{	prop->lang = NULL;    }
prop->lang = NULL;
prop->lang = NULL
prop->lang
prop
prop
lang
NULL
NULL
hdl->depth = 0;
hdl->depth = 0
hdl->depth
hdl
hdl
depth
0
return ELM_flatprop;
ELM_flatprop
ELM_flatprop
-----joern-----
(84,79,0)
(51,108,0)
(116,162,0)
(188,140,0)
(172,78,0)
(187,85,0)
(150,33,0)
(178,79,0)
(44,120,0)
(188,120,0)
(178,81,0)
(48,117,0)
(118,208,0)
(24,196,0)
(197,126,0)
(54,51,0)
(185,19,0)
(165,85,0)
(21,196,0)
(102,205,0)
(57,211,0)
(138,132,0)
(161,81,0)
(26,178,0)
(208,118,0)
(18,131,0)
(28,53,0)
(24,197,0)
(24,17,0)
(90,38,0)
(162,79,0)
(197,19,0)
(147,130,0)
(57,23,0)
(126,172,0)
(107,55,0)
(66,140,0)
(68,114,0)
(197,163,0)
(19,42,0)
(110,79,0)
(35,165,0)
(100,87,0)
(105,164,0)
(208,190,0)
(141,107,0)
(211,57,0)
(94,74,0)
(37,175,0)
(148,178,0)
(16,51,0)
(197,79,0)
(135,202,0)
(179,144,0)
(70,6,0)
(5,125,0)
(201,202,0)
(175,13,0)
(209,107,0)
(130,188,0)
(197,175,0)
(182,53,0)
(40,53,0)
(199,113,0)
(67,1,0)
(197,92,0)
(126,180,0)
(175,53,0)
(64,38,0)
(169,209,0)
(99,125,0)
(121,90,0)
(36,38,0)
(9,92,0)
(99,53,0)
(205,53,0)
(127,47,0)
(131,115,0)
(76,130,0)
(20,88,0)
(174,162,0)
(181,197,0)
(111,189,0)
(20,162,0)
(153,40,0)
(55,107,0)
(75,44,0)
(51,6,0)
(42,10,0)
(152,87,0)
(115,131,0)
(209,125,0)
(193,40,0)
(14,86,0)
(152,47,0)
(97,79,0)
(6,162,0)
(94,84,0)
(42,79,0)
(58,123,0)
(38,90,0)
(167,44,0)
(19,107,0)
(137,176,0)
(39,53,0)
(183,137,0)
(86,105,0)
(117,114,0)
(180,126,0)
(196,164,0)
(74,148,0)
(137,183,0)
(129,180,0)
(30,1,0)
(197,123,0)
(23,63,0)
(13,186,0)
(31,132,0)
(41,165,0)
(122,158,0)
(143,117,0)
(140,188,0)
(119,115,0)
(39,163,0)
(84,94,0)
(96,20,0)
(4,33,0)
(210,15,0)
(86,162,0)
(157,33,0)
(155,117,0)
(91,53,0)
(10,42,0)
(60,182,0)
(198,79,0)
(182,57,0)
(190,208,0)
(78,65,0)
(2,183,0)
(107,79,0)
(40,132,0)
(34,121,0)
(134,95,0)
(3,19,0)
(186,13,0)
(90,121,0)
(15,149,0)
(29,92,0)
(140,114,0)
(202,162,0)
(78,172,0)
(130,53,0)
(162,168,0)
(132,79,0)
(125,178,0)
(10,178,0)
(85,23,0)
(158,105,0)
(195,101,0)
(60,132,0)
(106,39,0)
(25,107,0)
(182,60,0)
(146,81,0)
(103,115,0)
(33,157,0)
(25,84,0)
(197,130,0)
(88,79,0)
(121,77,0)
(40,78,0)
(203,25,0)
(53,99,0)
(125,209,0)
(92,53,0)
(65,78,0)
(72,132,0)
(53,79,0)
(194,170,0)
(81,178,0)
(44,205,0)
(23,57,0)
(115,191,0)
(92,15,0)
(71,180,0)
(94,113,0)
(74,94,0)
(163,186,0)
(200,51,0)
(105,86,0)
(45,65,0)
(12,98,0)
(1,53,0)
(207,86,0)
(142,10,0)
(82,182,0)
(133,208,0)
(47,152,0)
(128,182,0)
(170,114,0)
(98,162,0)
(114,117,0)
(65,108,0)
(173,79,0)
(50,175,0)
(204,176,0)
(123,53,0)
(113,94,0)
(101,162,0)
(113,107,0)
(125,99,0)
(11,118,0)
(132,60,0)
(55,98,0)
(105,158,0)
(24,189,0)
(32,101,0)
(73,183,0)
(132,178,0)
(171,28,0)
(47,101,0)
(87,152,0)
(205,188,0)
(160,98,0)
(74,177,0)
(197,85,0)
(62,121,0)
(189,176,0)
(33,107,0)
(163,39,0)
(148,74,0)
(182,13,0)
(7,6,0)
(177,154,0)
(56,95,0)
(132,40,0)
(89,10,0)
(144,79,0)
(90,157,0)
(6,51,0)
(46,211,0)
(205,44,0)
(112,13,0)
(145,17,0)
(190,162,0)
(124,39,0)
(192,51,0)
(0,190,0)
(80,25,0)
(43,205,0)
(180,53,0)
(93,148,0)
(166,88,0)
(49,113,0)
(186,59,0)
(172,79,0)
(83,126,0)
(211,191,0)
(1,78,0)
(52,20,0)
(139,190,0)
(69,79,0)
(27,79,0)
(157,90,0)
(209,84,0)
(22,170,0)
(136,123,0)
(101,47,0)
(197,20,0)
(109,209,0)
(8,79,0)
(177,74,0)
(183,162,0)
(98,55,0)
(95,77,0)
(123,57,0)
(117,202,0)
(184,79,0)
(202,117,0)
(85,165,0)
(81,107,0)
(114,79,0)
(197,1,0)
(206,28,0)
(151,148,0)
(165,53,0)
(104,163,0)
(117,61,0)
(38,77,0)
(159,79,0)
(28,144,0)
(197,28,0)
(154,177,0)
(197,25,0)
(156,79,0)
(172,78,1)
(197,25,1)
(140,66,1)
(180,129,1)
(86,162,1)
(131,18,1)
(11,208,1)
(124,106,1)
(40,153,1)
(6,70,1)
(51,108,1)
(20,96,1)
(121,77,1)
(157,33,1)
(162,116,1)
(116,174,1)
(29,170,1)
(197,1,1)
(196,21,1)
(21,105,1)
(23,57,1)
(197,19,1)
(147,76,1)
(186,13,1)
(85,187,1)
(0,137,1)
(113,199,1)
(205,188,1)
(197,20,1)
(93,151,1)
(167,188,1)
(22,194,1)
(209,84,1)
(100,152,1)
(182,82,1)
(209,107,1)
(143,202,1)
(10,142,1)
(33,107,1)
(208,133,1)
(47,127,1)
(130,147,1)
(183,2,1)
(202,135,1)
(125,178,1)
(87,152,1)
(188,140,1)
(60,182,1)
(9,29,1)
(17,145,1)
(197,181,1)
(207,87,1)
(123,53,1)
(142,89,1)
(86,14,1)
(98,12,1)
(166,20,1)
(145,157,1)
(113,107,1)
(206,186,1)
(105,86,1)
(109,91,1)
(117,155,1)
(160,141,1)
(112,175,1)
(175,53,1)
(19,3,1)
(115,119,1)
(38,36,1)
(155,48,1)
(133,190,1)
(92,53,1)
(30,126,1)
(119,103,1)
(178,81,1)
(55,98,1)
(45,1,1)
(3,185,1)
(64,121,1)
(195,95,1)
(187,165,1)
(140,114,1)
(25,107,1)
(118,11,1)
(99,125,1)
(136,58,1)
(197,123,1)
(84,94,1)
(68,132,1)
(132,60,1)
(57,211,1)
(197,130,1)
(40,78,1)
(34,62,1)
(10,178,1)
(101,162,1)
(18,115,1)
(26,87,1)
(183,162,1)
(73,95,1)
(152,47,1)
(182,57,1)
(104,39,1)
(75,167,1)
(94,113,1)
(194,114,1)
(54,192,1)
(148,178,1)
(83,180,1)
(205,53,1)
(39,124,1)
(87,100,1)
(67,30,1)
(206,23,1)
(94,74,1)
(115,191,1)
(49,25,1)
(177,154,1)
(101,32,1)
(1,53,1)
(80,203,1)
(130,53,1)
(62,107,1)
(111,118,1)
(211,191,1)
(163,39,1)
(40,53,1)
(5,209,1)
(89,19,1)
(197,92,1)
(96,52,1)
(128,138,1)
(148,93,1)
(144,179,1)
(72,31,1)
(192,6,1)
(150,4,1)
(106,131,1)
(71,53,1)
(65,45,1)
(15,210,1)
(122,86,1)
(81,146,1)
(127,101,1)
(6,162,1)
(209,169,1)
(105,158,1)
(74,177,1)
(19,107,1)
(74,148,1)
(126,83,1)
(24,196,1)
(182,13,1)
(165,35,1)
(16,200,1)
(126,180,1)
(121,34,1)
(158,122,1)
(200,54,1)
(52,15,1)
(179,28,1)
(13,112,1)
(114,117,1)
(51,16,1)
(50,163,1)
(78,65,1)
(35,41,1)
(36,64,1)
(32,195,1)
(98,162,1)
(43,102,1)
(51,6,1)
(42,10,1)
(170,22,1)
(117,61,1)
(201,68,1)
(44,205,1)
(28,53,1)
(180,53,1)
(170,114,1)
(70,7,1)
(28,171,1)
(48,143,1)
(95,77,1)
(205,43,1)
(24,197,1)
(153,193,1)
(151,177,1)
(211,46,1)
(165,53,1)
(135,201,1)
(123,136,1)
(12,160,1)
(56,134,1)
(118,208,1)
(193,60,1)
(7,118,1)
(138,72,1)
(66,130,1)
(53,99,1)
(146,161,1)
(47,101,1)
(107,55,1)
(132,178,1)
(199,49,1)
(161,26,1)
(197,163,1)
(85,165,1)
(90,38,1)
(197,175,1)
(162,168,1)
(202,162,1)
(189,111,1)
(182,53,1)
(185,84,1)
(65,108,1)
(210,92,1)
(125,209,1)
(141,162,1)
(190,139,1)
(177,113,1)
(134,157,1)
(137,183,1)
(25,80,1)
(88,166,1)
(190,162,1)
(31,144,1)
(91,42,1)
(102,75,1)
(33,150,1)
(82,128,1)
(197,28,1)
(24,17,1)
(76,170,1)
(171,206,1)
(132,40,1)
(175,37,1)
(92,9,1)
(203,178,1)
(163,104,1)
(103,172,1)
(111,51,1)
(197,126,1)
(4,90,1)
(39,53,1)
(58,85,1)
(38,77,1)
(197,85,1)
(37,50,1)
(41,131,1)
(208,190,1)
(95,56,1)
(139,0,1)
(24,189,1)
(14,207,1)
(52,44,1)
(129,71,1)
(2,73,1)
(90,121,1)
(131,115,1)
(181,88,1)
(20,162,1)
(169,109,1)
(46,123,1)
(125,5,1)
(1,67,1)
(117,202,1)
(157,90,1)
(81,107,1)
(153,87,2)
(9,170,2)
(211,191,2)
(17,157,2)
(130,170,2)
(123,53,2)
(23,57,2)
(197,92,2)
(145,157,2)
(113,87,2)
(186,13,2)
(106,131,2)
(28,53,2)
(186,131,2)
(57,211,2)
(207,87,2)
(183,162,2)
(180,53,2)
(197,25,2)
(182,53,2)
(183,95,2)
(39,53,2)
(19,107,2)
(177,87,2)
(64,121,2)
(24,196,2)
(20,87,2)
(87,95,2)
(40,87,2)
(56,157,2)
(197,85,2)
(171,87,2)
(137,95,2)
(47,101,2)
(114,117,2)
(24,197,2)
(0,95,2)
(140,170,2)
(103,87,2)
(206,87,2)
(78,65,2)
(189,95,2)
(49,87,2)
(208,190,2)
(24,189,2)
(211,131,2)
(31,87,2)
(1,87,2)
(6,118,2)
(2,95,2)
(138,87,2)
(144,87,2)
(84,94,2)
(210,170,2)
(172,78,2)
(60,182,2)
(95,157,2)
(40,78,2)
(78,87,2)
(48,87,2)
(140,114,2)
(95,77,2)
(5,87,2)
(136,131,2)
(119,87,2)
(197,163,2)
(197,20,2)
(92,53,2)
(182,87,2)
(177,154,2)
(22,87,2)
(150,90,2)
(42,87,2)
(92,170,2)
(90,38,2)
(185,87,2)
(28,87,2)
(132,87,2)
(73,95,2)
(181,87,2)
(70,118,2)
(40,53,2)
(74,148,2)
(124,131,2)
(4,90,2)
(165,53,2)
(107,55,2)
(100,95,2)
(24,17,2)
(167,170,2)
(131,87,2)
(188,170,2)
(109,87,2)
(58,131,2)
(147,170,2)
(37,131,2)
(148,178,2)
(19,87,2)
(175,53,2)
(125,87,2)
(137,183,2)
(205,53,2)
(93,87,2)
(175,131,2)
(83,87,2)
(192,118,2)
(190,95,2)
(195,95,2)
(74,177,2)
(128,87,2)
(91,87,2)
(165,131,2)
(203,87,2)
(131,115,2)
(33,107,2)
(193,87,2)
(208,95,2)
(99,125,2)
(132,60,2)
(209,87,2)
(11,95,2)
(143,87,2)
(199,87,2)
(197,126,2)
(133,95,2)
(65,108,2)
(197,1,2)
(67,87,2)
(170,87,2)
(123,131,2)
(7,118,2)
(14,87,2)
(42,10,2)
(25,107,2)
(197,123,2)
(44,205,2)
(200,118,2)
(75,170,2)
(130,53,2)
(202,162,2)
(163,39,2)
(84,87,2)
(121,77,2)
(115,87,2)
(209,84,2)
(155,87,2)
(197,28,2)
(86,162,2)
(132,40,2)
(85,165,2)
(41,131,2)
(151,87,2)
(35,131,2)
(81,107,2)
(161,87,2)
(39,131,2)
(46,131,2)
(209,107,2)
(111,95,2)
(36,121,2)
(126,180,2)
(38,121,2)
(30,87,2)
(94,87,2)
(182,57,2)
(113,107,2)
(205,188,2)
(146,87,2)
(114,87,2)
(72,87,2)
(196,87,2)
(178,81,2)
(179,87,2)
(94,113,2)
(134,157,2)
(53,99,2)
(157,90,2)
(194,87,2)
(166,87,2)
(118,95,2)
(85,131,2)
(68,87,2)
(158,87,2)
(88,87,2)
(112,131,2)
(13,131,2)
(81,87,2)
(20,162,2)
(129,87,2)
(32,95,2)
(60,87,2)
(74,87,2)
(47,95,2)
(96,87,2)
(50,131,2)
(201,87,2)
(33,90,2)
(10,87,2)
(197,175,2)
(51,108,2)
(65,87,2)
(170,114,2)
(53,87,2)
(45,87,2)
(18,87,2)
(99,87,2)
(80,87,2)
(163,131,2)
(26,87,2)
(25,87,2)
(132,178,2)
(29,170,2)
(118,208,2)
(44,170,2)
(104,131,2)
(55,98,2)
(197,130,2)
(105,87,2)
(71,87,2)
(169,87,2)
(157,33,2)
(57,131,2)
(162,168,2)
(190,162,2)
(89,87,2)
(125,209,2)
(180,87,2)
(10,178,2)
(148,87,2)
(152,47,2)
(105,86,2)
(117,87,2)
(52,87,2)
(43,170,2)
(1,53,2)
(127,95,2)
(102,170,2)
(82,87,2)
(117,61,2)
(51,118,2)
(125,178,2)
(87,152,2)
(202,87,2)
(115,191,2)
(76,170,2)
(188,140,2)
(142,87,2)
(152,95,2)
(94,74,2)
(197,87,2)
(139,95,2)
(15,170,2)
(205,170,2)
(3,87,2)
(122,87,2)
(66,170,2)
(101,95,2)
(16,118,2)
(172,87,2)
(90,121,2)
(98,162,2)
(6,162,2)
(105,158,2)
(54,118,2)
(126,87,2)
(197,19,2)
(187,131,2)
(21,87,2)
(23,131,2)
(86,87,2)
(51,6,2)
(101,162,2)
(38,77,2)
(182,13,2)
(117,202,2)
(178,87,2)
(135,87,2)
-----------------------------------
(0,hdl)
(1,prop->name)
(2,depth)
(3,numprops)
(4,pstat)
(5,n)
(6,hdl->value)
(7,hdl)
(8,if (++hdl->current->counter == MAX_PROP_COUNTER)
(9,lang)
(10,n+1)
(11,MAX_FLATPROP_LEN)
(12,parser207)
(13,prop->nspace = NULL)
(14,parser)
(15,prop->lang = NULL)
(16,NULL)
(17,return NE_XML_DECLINE;)
(18,\'\\0\')
(19,pstat->numprops)
(20,hdl->depth)
(21,NE_XML_ABORT)
(22,NULL)
(23,prop->pname.nspace = prop->nspace = ne_strdup(nspace)
(24,RET)
(25,pstat->props)
(26,n)
(27,if ((parent != NE_207_STATE_PROP && parent != ELM_flatprop)
(28,prop->value)
(29,prop)
(30,prop)
(31,NE_DBG_XML)
(32,current)
(33,pstat == NULL)
(34,NE_207_STATE_PROP)
(35,pname)
(36,ELM_flatprop)
(37,nspace)
(38,parent != ELM_flatprop)
(39,prop->pname)
(40,prop->name)
(41,prop)
(42,pstat->numprops = n+1)
(43,lang)
(44,NE_DEBUG(NE_DBG_XML, "Property language is %s\\n", prop->lang)
(45,name)
(46,nspace)
(47,hdl->current->counter)
(48,NULL)
(49,pstat)
(50,prop)
(51,ne_buffer_concat(hdl->value, "<", name, ">", NULL)
(52,hdl)
(53,prop = &pstat->props[n])
(54,name)
(55,ne_207_get_current_propstat(hdl->parser207)
(56,ELM_flatprop)
(57,prop->nspace = ne_strdup(nspace)
(58,prop)
(59,)
(60,NSPACE(prop->nspace)
(61,const char **atts)
(62,parent)
(63,)
(64,parent)
(65,ne_strdup(name)
(66,lang)
(67,name)
(68,lang)
(69,hdl)
(70,value)
(71,prop)
(72,"Got property #%d: {%s}%s.\\n")
(73,hdl)
(74,sizeof(struct prop)
(75,"Property language is %s\\n")
(76,prop)
(77,int parent)
(78,prop->name = ne_strdup(name)
(79,)
(80,props)
(81,pstat->numprops)
(82,nspace)
(83,name)
(84,pstat->props = ne_realloc(pstat->props, sizeof(struct prop)
(85,prop->pname.nspace)
(86,hdl->parser)
(87,++hdl->current->counter == MAX_PROP_COUNTER)
(88,hdl->depth = 0)
(89,n)
(90,parent != NE_207_STATE_PROP && parent != ELM_flatprop)
(91,prop)
(92,prop->lang)
(93,1)
(94,ne_realloc(pstat->props, sizeof(struct prop)
(95,parent == ELM_flatprop)
(96,depth)
(97,pstat)
(98,hdl->parser207)
(99,&pstat->props[n])
(100,MAX_PROP_COUNTER)
(101,hdl->current)
(102,prop)
(103,nspace)
(104,nspace)
(105,ne_xml_set_error(hdl->parser, _("Response exceeds maximum property count")
(106,prop)
(107,*pstat = ne_207_get_current_propstat(hdl->parser207)
(108,const char *name)
(109,pstat)
(110,prop)
(111,ELM_flatprop)
(112,NULL)
(113,pstat->props)
(114,lang = ne_xml_get_attr(hdl->parser, atts, NULL, "xml:lang")
(115,nspace[0])
(116,userdata)
(117,ne_xml_get_attr(hdl->parser, atts, NULL, "xml:lang")
(118,hdl->value->used < MAX_FLATPROP_LEN)
(119,0)
(120,)
(121,parent != NE_207_STATE_PROP)
(122,"Response exceeds maximum property count")
(123,prop->nspace)
(124,pname)
(125,pstat->props[n])
(126,prop->pname.name)
(127,counter)
(128,prop)
(129,pname)
(130,prop->lang)
(131,nspace[0] == \'\\0\')
(132,NE_DEBUG(NE_DBG_XML, "Got property #%d: {%s}%s.\\n", n, \n\\n\\t     NSPACE(prop->nspace)
(133,used)
(134,parent)
(135,parser)
(136,nspace)
(137,hdl->depth++)
(138,n)
(139,value)
(140,ne_strdup(lang)
(141,pstat)
(142,1)
(143,atts)
(144,prop->value = NULL)
(145,NE_XML_DECLINE)
(146,numprops)
(147,lang)
(148,n + 1)
(149,)
(150,NULL)
(151,n)
(152,++hdl->current->counter)
(153,name)
(154,struct prop)
(155,"xml:lang")
(156,lang)
(157,(parent != NE_207_STATE_PROP && parent != ELM_flatprop)
(158,_("Response exceeds maximum property count")
(159,if (lang != NULL)
(160,hdl)
(161,pstat)
(162,*hdl = userdata)
(163,prop->pname.nspace)
(164,)
(165,prop->pname)
(166,0)
(167,NE_DBG_XML)
(168,void *userdata)
(169,props)
(170,lang != NULL)
(171,value)
(172,prop->pname.name = prop->name = ne_strdup(name)
(173,n)
(174,hdl)
(175,prop->nspace)
(176,)
(177,sizeof(struct prop)
(178,n = pstat->numprops)
(179,NULL)
(180,prop->pname)
(181,ELM_flatprop)
(182,prop->nspace)
(183,hdl->depth)
(184,if (nspace[0] == \'\\0\')
(185,pstat)
(186,prop->pname.nspace = prop->nspace = NULL)
(187,nspace)
(188,prop->lang = ne_strdup(lang)
(189,return ELM_flatprop;)
(190,hdl->value)
(191,const char *nspace)
(192,"<")
(193,prop)
(194,lang)
(195,hdl)
(196,return NE_XML_ABORT;)
(197,return ELM_flatprop;)
(198,if (parent == ELM_flatprop)
(199,props)
(200,">")
(201,hdl)
(202,hdl->parser)
(203,pstat)
(204,if (hdl->value->used < MAX_FLATPROP_LEN)
(205,prop->lang)
(206,prop)
(207,hdl)
(208,hdl->value->used)
(209,pstat->props)
(210,NULL)
(211,ne_strdup(nspace)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^