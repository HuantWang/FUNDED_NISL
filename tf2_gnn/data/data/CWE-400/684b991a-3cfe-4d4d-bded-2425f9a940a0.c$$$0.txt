-----label-----
1
-----code-----
void
thread_lock_got_swap(const void *lock, enum thread_lock_kind kind,
	const char *file, unsigned line, const void *plock, const void *element)
{
	struct thread_element *te = deconstify_pointer(element);
	struct thread_lock_stack *tls;
	struct thread_lock *l, *pl;

	/*
	 * This starts as thread_lock_got() would...
	 */

	if (NULL == te) {
		te = thread_find(&te);
	} else {
		thread_element_check(te);
	}

	if G_UNLIKELY(NULL == te) {
		/*
		 * Cheaply check whether we are in the main thread, whilst it is
		 * being created.
		 */

		if G_UNLIKELY(NULL == threads[0]) {
			te = thread_get_main_if_first();
			if (te != NULL)
				goto found;
		}
		return;
	}

found:
	THREAD_STATS_INCX(locks_tracked);

	tls = &te->locks;

	if G_UNLIKELY(tls->capacity == tls->count) {
		if (tls->overflow)
			return;				/* Already signaled, we're crashing */
		tls->overflow = TRUE;
		s_rawwarn("%s overflowing its lock stack", thread_element_name(te));
		thread_lock_dump(te);
		if (atomic_int_get(&thread_locks_disabled))
			return;			/* Crashing or exiting already */
		s_error("too many locks grabbed simultaneously");
	}

	/*
	 * No thread suspension is possible here contrary to thread_lock_got()
	 * since we are already holding another lock.
	 */

	g_assert_log(tls->count != 0,
		"%s(): expected at least 1 lock to be already held", G_STRFUNC);

	pl = &tls->arena[tls->count - 1];

	g_assert_log(plock == pl->lock,
		"%s(): expected topmost lock to be %p, found %s %p",
		G_STRFUNC, plock, thread_lock_kind_to_string(pl->kind), pl->lock);

	/*
	 * Record new lock before the previous lock so that the previous lock
	 * can now be released without triggering any assertion failure.
	 */

	l = &tls->arena[tls->count++];
	l->lock = pl->lock;			/* Previous lock becomes topmost lock */
	l->file = pl->file;
	l->line = pl->line;
	l->kind = pl->kind;
	pl->lock = lock;			/* New lock registered in place of previous */
	pl->file = file;
	pl->line = line;
	pl->kind = kind;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
3,9
3,10
5,6
5,7
7,8
7,9
10,11
10,12
11,12
13,14
15,16
15,17
17,18
17,19
20,21
20,22
22,23
24,25
24,26
26,27
26,28
29,30
29,31
31,32
31,33
34,35
34,36
34,37
34,38
34,39
34,40
34,41
34,42
34,43
34,44
34,45
34,46
34,47
34,48
34,49
34,50
34,51
34,52
34,53
34,54
35,36
36,37
36,38
37,38
39,40
39,41
39,42
42,43
43,44
43,45
44,45
46,47
48,49
49,50
49,51
50,51
52,53
52,54
55,56
56,57
56,58
56,59
57,58
59,60
59,61
62,63
62,64
65,66
65,67
65,68
66,67
66,68
67,68
69,70
71,72
72,73
73,74
73,75
74,75
76,77
76,78
77,78
79,80
80,81
82,83
83,84
84,85
84,86
85,86
87,88
89,90
90,91
90,92
92,93
93,94
93,95
94,95
96,97
97,98
99,100
100,101
100,102
101,102
103,104
104,105
104,106
105,106
108,109
109,110
110,111
110,112
110,113
110,114
111,112
113,114
113,115
114,115
114,116
115,116
120,121
122,123
123,124
123,125
124,125
126,127
127,128
127,129
128,129
128,130
129,130
132,133
132,134
133,134
133,135
134,135
138,139
139,140
139,141
139,142
139,143
139,144
139,145
139,146
140,141
142,143
142,144
143,144
145,146
145,147
146,147
150,151
152,153
154,155
154,156
155,156
157,158
157,159
158,159
161,162
161,163
162,163
165,166
166,167
166,168
167,168
169,170
170,171
170,172
171,172
171,173
172,173
175,176
176,177
176,178
177,178
180,181
181,182
181,183
182,183
182,184
183,184
186,187
186,188
187,188
190,191
191,192
191,193
192,193
192,194
193,194
196,197
196,198
197,198
200,201
201,202
201,203
202,203
202,204
203,204
206,207
206,208
207,208
210,211
211,212
211,213
212,213
212,214
213,214
216,217
216,218
217,218
220,221
221,222
221,223
222,223
222,224
223,224
226,227
228,229
229,230
229,231
230,231
230,232
231,232
234,235
236,237
237,238
237,239
238,239
238,240
239,240
242,243
244,245
245,246
245,247
246,247
246,248
247,248
250,251
-----nextToken-----
2,4,6,8,9,12,14,16,18,19,21,23,25,27,28,30,32,33,38,40,41,45,47,51,53,54,58,60,61,63,64,68,70,75,78,81,86,88,91,95,98,102,106,107,112,116,117,118,119,121,125,130,131,135,136,137,141,144,147,148,149,151,153,156,159,160,163,164,168,173,174,178,179,184,185,188,189,194,195,198,199,204,205,208,209,214,215,218,219,224,225,227,232,233,235,240,241,243,248,249,251
-----computeFrom-----
66,67
66,68
73,74
73,75
100,101
100,102
113,114
113,115
123,124
123,125
132,133
132,134
142,143
142,144
166,167
166,168
181,182
181,183
191,192
191,193
201,202
201,203
211,212
211,213
221,222
221,223
229,230
229,231
237,238
237,239
245,246
245,247
-----guardedBy-----
70,81
-----guardedByNegation-----
70,88
-----lastLexicalUse-----
70,88
-----jump-----
70,88
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ProblemStatement;LabelStatement;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;
-----ast_node-----
voidthread_lock_got_swap(const void *lock, enum thread_lock_kind kind,	const char *file, unsigned line, const void *plock, const void *element){	struct thread_element *te = deconstify_pointer(element);	struct thread_lock_stack *tls;	struct thread_lock *l, *pl;	/*	 * This starts as thread_lock_got() would...	 */	if (NULL == te) {		te = thread_find(&te);	} else {		thread_element_check(te);	}	if G_UNLIKELY(NULL == te) {		/*		 * Cheaply check whether we are in the main thread, whilst it is		 * being created.		 */		if G_UNLIKELY(NULL == threads[0]) {			te = thread_get_main_if_first();			if (te != NULL)				goto found;		}		return;	}found:	THREAD_STATS_INCX(locks_tracked);	tls = &te->locks;	if G_UNLIKELY(tls->capacity == tls->count) {		if (tls->overflow)			return;				/* Already signaled, we're crashing */		tls->overflow = TRUE;		s_rawwarn("%s overflowing its lock stack", thread_element_name(te));		thread_lock_dump(te);		if (atomic_int_get(&thread_locks_disabled))			return;			/* Crashing or exiting already */		s_error("too many locks grabbed simultaneously");	}	/*	 * No thread suspension is possible here contrary to thread_lock_got()	 * since we are already holding another lock.	 */	g_assert_log(tls->count != 0,		"%s(): expected at least 1 lock to be already held", G_STRFUNC);	pl = &tls->arena[tls->count - 1];	g_assert_log(plock == pl->lock,		"%s(): expected topmost lock to be %p, found %s %p",		G_STRFUNC, plock, thread_lock_kind_to_string(pl->kind), pl->lock);	/*	 * Record new lock before the previous lock so that the previous lock	 * can now be released without triggering any assertion failure.	 */	l = &tls->arena[tls->count++];	l->lock = pl->lock;			/* Previous lock becomes topmost lock */	l->file = pl->file;	l->line = pl->line;	l->kind = pl->kind;	pl->lock = lock;			/* New lock registered in place of previous */	pl->file = file;	pl->line = line;	pl->kind = kind;}
void
thread_lock_got_swap(const void *lock, enum thread_lock_kind kind,	const char *file, unsigned line, const void *plock, const void *element)
thread_lock_got_swap
const void *lock
const void
*lock
*
lock
enum thread_lock_kind kind
enum thread_lock_kind
thread_lock_kind
kind
kind
const char *file
const char
*file
*
file
unsigned line
unsigned
line
line
const void *plock
const void
*plock
*
plock
const void *element
const void
*element
*
element
{	struct thread_element *te = deconstify_pointer(element);	struct thread_lock_stack *tls;	struct thread_lock *l, *pl;	/*	 * This starts as thread_lock_got() would...	 */	if (NULL == te) {		te = thread_find(&te);	} else {		thread_element_check(te);	}	if G_UNLIKELY(NULL == te) {		/*		 * Cheaply check whether we are in the main thread, whilst it is		 * being created.		 */		if G_UNLIKELY(NULL == threads[0]) {			te = thread_get_main_if_first();			if (te != NULL)				goto found;		}		return;	}found:	THREAD_STATS_INCX(locks_tracked);	tls = &te->locks;	if G_UNLIKELY(tls->capacity == tls->count) {		if (tls->overflow)			return;				/* Already signaled, we're crashing */		tls->overflow = TRUE;		s_rawwarn("%s overflowing its lock stack", thread_element_name(te));		thread_lock_dump(te);		if (atomic_int_get(&thread_locks_disabled))			return;			/* Crashing or exiting already */		s_error("too many locks grabbed simultaneously");	}	/*	 * No thread suspension is possible here contrary to thread_lock_got()	 * since we are already holding another lock.	 */	g_assert_log(tls->count != 0,		"%s(): expected at least 1 lock to be already held", G_STRFUNC);	pl = &tls->arena[tls->count - 1];	g_assert_log(plock == pl->lock,		"%s(): expected topmost lock to be %p, found %s %p",		G_STRFUNC, plock, thread_lock_kind_to_string(pl->kind), pl->lock);	/*	 * Record new lock before the previous lock so that the previous lock	 * can now be released without triggering any assertion failure.	 */	l = &tls->arena[tls->count++];	l->lock = pl->lock;			/* Previous lock becomes topmost lock */	l->file = pl->file;	l->line = pl->line;	l->kind = pl->kind;	pl->lock = lock;			/* New lock registered in place of previous */	pl->file = file;	pl->line = line;	pl->kind = kind;}
struct thread_element *te = deconstify_pointer(element);
struct thread_element *te = deconstify_pointer(element);
struct thread_element
thread_element
*te = deconstify_pointer(element)
*
te
= deconstify_pointer(element)
deconstify_pointer(element)
deconstify_pointer
deconstify_pointer
element
element
struct thread_lock_stack *tls;
struct thread_lock_stack *tls;
struct thread_lock_stack
thread_lock_stack
*tls
*
tls
struct thread_lock *l, *pl;
struct thread_lock *l, *pl;
struct thread_lock
thread_lock
*l
*
l
*pl
*
pl
if (NULL == te) {		te = thread_find(&te);	} else {		thread_element_check(te);	}
NULL == te
NULL
NULL
te
te
{		te = thread_find(&te);	}
te = thread_find(&te);
te = thread_find(&te)
te
te
thread_find(&te)
thread_find
thread_find
&te
te
te
{		thread_element_check(te);	}
thread_element_check(te);
thread_element_check(te)
thread_element_check
thread_element_check
te
te
if G_UNLIKELY(NULL == te) {		/*		 * Cheaply check whether we are in the main thread, whilst it is		 * being created.		 */		if G_UNLIKELY(NULL == threads[0]) {			te = thread_get_main_if_first();			if (te != NULL)				goto found;		}		return;	}
found:	THREAD_STATS_INCX(locks_tracked);
found
THREAD_STATS_INCX(locks_tracked);
THREAD_STATS_INCX(locks_tracked);
THREAD_STATS_INCX
THREAD_STATS_INCX
(locks_tracked)
locks_tracked
locks_tracked
tls = &te->locks;
tls = &te->locks
tls
tls
&te->locks
te->locks
te
te
locks
if G_UNLIKELY(tls->capacity == tls->count) {		if (tls->overflow)			return;				/* Already signaled, we're crashing */		tls->overflow = TRUE;		s_rawwarn("%s overflowing its lock stack", thread_element_name(te));		thread_lock_dump(te);		if (atomic_int_get(&thread_locks_disabled))			return;			/* Crashing or exiting already */		s_error("too many locks grabbed simultaneously");	}
g_assert_log(tls->count != 0,		"%s(): expected at least 1 lock to be already held", G_STRFUNC);
g_assert_log(tls->count != 0,		"%s(): expected at least 1 lock to be already held", G_STRFUNC)
g_assert_log
g_assert_log
tls->count != 0
tls->count
tls
tls
count
0
"%s(): expected at least 1 lock to be already held"
G_STRFUNC
G_STRFUNC
pl = &tls->arena[tls->count - 1];
pl = &tls->arena[tls->count - 1]
pl
pl
&tls->arena[tls->count - 1]
tls->arena[tls->count - 1]
tls->arena
tls
tls
arena
tls->count - 1
tls->count
tls
tls
count
1
g_assert_log(plock == pl->lock,		"%s(): expected topmost lock to be %p, found %s %p",		G_STRFUNC, plock, thread_lock_kind_to_string(pl->kind), pl->lock);
g_assert_log(plock == pl->lock,		"%s(): expected topmost lock to be %p, found %s %p",		G_STRFUNC, plock, thread_lock_kind_to_string(pl->kind), pl->lock)
g_assert_log
g_assert_log
plock == pl->lock
plock
plock
pl->lock
pl
pl
lock
"%s(): expected topmost lock to be %p, found %s %p"
G_STRFUNC
G_STRFUNC
plock
plock
thread_lock_kind_to_string(pl->kind)
thread_lock_kind_to_string
thread_lock_kind_to_string
pl->kind
pl
pl
kind
pl->lock
pl
pl
lock
l = &tls->arena[tls->count++];
l = &tls->arena[tls->count++]
l
l
&tls->arena[tls->count++]
tls->arena[tls->count++]
tls->arena
tls
tls
arena
tls->count++
tls->count
tls
tls
count
l->lock = pl->lock;
l->lock = pl->lock
l->lock
l
l
lock
pl->lock
pl
pl
lock
l->file = pl->file;
l->file = pl->file
l->file
l
l
file
pl->file
pl
pl
file
l->line = pl->line;
l->line = pl->line
l->line
l
l
line
pl->line
pl
pl
line
l->kind = pl->kind;
l->kind = pl->kind
l->kind
l
l
kind
pl->kind
pl
pl
kind
pl->lock = lock;
pl->lock = lock
pl->lock
pl
pl
lock
lock
lock
pl->file = file;
pl->file = file
pl->file
pl
pl
file
file
file
pl->line = line;
pl->line = line
pl->line
pl
pl
line
line
line
pl->kind = kind;
pl->kind = kind
pl->kind
pl
pl
kind
kind
kind
-----joern-----
(21,10,0)
(137,133,0)
(87,112,0)
(45,59,0)
(59,163,0)
(74,14,0)
(147,37,0)
(62,133,0)
(118,133,0)
(165,107,0)
(81,133,0)
(28,76,0)
(30,126,0)
(14,133,0)
(75,28,0)
(164,49,0)
(125,56,0)
(34,112,0)
(33,25,0)
(165,25,0)
(112,34,0)
(160,55,0)
(123,59,0)
(74,105,0)
(78,83,0)
(121,65,0)
(159,133,0)
(107,59,0)
(60,45,0)
(53,123,0)
(57,81,0)
(158,15,0)
(89,25,0)
(58,79,0)
(50,14,0)
(123,161,0)
(155,0,0)
(15,76,0)
(49,95,0)
(163,59,0)
(59,133,0)
(149,133,0)
(6,40,0)
(76,133,0)
(83,92,0)
(136,55,0)
(40,167,0)
(113,74,0)
(43,57,0)
(8,160,0)
(86,81,0)
(101,14,0)
(161,133,0)
(117,95,0)
(56,149,0)
(24,112,0)
(1,10,0)
(92,75,0)
(22,30,0)
(42,70,0)
(162,50,0)
(104,134,0)
(80,25,0)
(24,136,0)
(88,144,0)
(161,141,0)
(65,23,0)
(134,133,0)
(29,165,0)
(66,99,0)
(20,4,0)
(159,11,0)
(35,40,0)
(102,117,0)
(56,59,0)
(28,75,0)
(85,55,0)
(151,133,0)
(95,49,0)
(119,38,0)
(160,112,0)
(14,37,0)
(149,56,0)
(166,58,0)
(36,26,0)
(79,133,0)
(4,159,0)
(15,149,0)
(10,132,0)
(95,117,0)
(103,136,0)
(81,135,0)
(163,95,0)
(153,5,0)
(128,104,0)
(138,75,0)
(131,107,0)
(106,58,0)
(129,89,0)
(96,97,0)
(119,100,0)
(25,165,0)
(4,59,0)
(73,76,0)
(63,24,0)
(69,70,0)
(3,56,0)
(75,92,0)
(139,126,0)
(13,45,0)
(2,71,0)
(51,90,0)
(25,133,0)
(107,165,0)
(144,133,0)
(89,59,0)
(146,133,0)
(110,59,0)
(92,83,0)
(104,76,0)
(5,112,0)
(27,76,0)
(156,27,0)
(16,5,0)
(122,133,0)
(126,30,0)
(116,57,0)
(90,31,0)
(134,45,0)
(136,24,0)
(98,151,0)
(118,97,0)
(70,79,0)
(41,98,0)
(165,127,0)
(110,151,0)
(25,167,0)
(23,55,0)
(25,89,0)
(55,133,0)
(98,76,0)
(79,154,0)
(52,65,0)
(30,70,0)
(82,110,0)
(119,91,0)
(47,49,0)
(109,15,0)
(76,28,0)
(50,51,0)
(112,26,0)
(97,59,0)
(95,163,0)
(68,104,0)
(54,133,0)
(45,134,0)
(72,161,0)
(37,14,0)
(154,79,0)
(71,115,0)
(142,126,0)
(167,40,0)
(19,98,0)
(124,79,0)
(154,0,0)
(7,0,0)
(157,55,0)
(75,138,0)
(126,133,0)
(18,101,0)
(145,101,0)
(10,59,0)
(151,110,0)
(44,159,0)
(100,137,0)
(150,132,0)
(148,4,0)
(90,51,0)
(94,97,0)
(64,123,0)
(132,133,0)
(49,47,0)
(67,117,0)
(108,110,0)
(65,79,0)
(132,17,0)
(111,47,0)
(84,14,0)
(51,50,0)
(0,112,0)
(115,71,0)
(167,25,0)
(97,118,0)
(0,154,0)
(117,79,0)
(138,79,0)
(27,118,0)
(25,127,0)
(83,79,0)
(46,23,0)
(12,133,0)
(143,59,0)
(77,83,0)
(39,25,0)
(152,47,0)
(93,133,0)
(47,79,0)
(9,89,0)
(99,55,0)
(130,138,0)
(140,90,0)
(70,30,0)
(57,59,0)
(26,137,0)
(120,107,0)
(114,27,0)
(32,138,0)
(37,61,0)
(40,59,0)
(142,139,1)
(114,156,1)
(112,34,1)
(159,44,1)
(2,160,1)
(109,118,1)
(48,5,1)
(23,46,1)
(66,115,1)
(156,151,1)
(110,108,1)
(5,153,1)
(70,42,1)
(35,33,1)
(8,136,1)
(29,59,1)
(56,3,1)
(123,53,1)
(126,30,1)
(38,58,1)
(10,21,1)
(51,50,1)
(68,128,1)
(147,84,1)
(41,19,1)
(40,59,1)
(37,147,1)
(13,104,1)
(164,47,1)
(15,76,1)
(117,67,1)
(81,86,1)
(98,76,1)
(150,10,1)
(74,14,1)
(16,112,1)
(46,65,1)
(44,4,1)
(89,9,1)
(78,77,1)
(30,22,1)
(58,79,1)
(25,167,1)
(21,1,1)
(67,102,1)
(50,14,1)
(161,141,1)
(24,112,1)
(101,18,1)
(49,164,1)
(70,79,1)
(81,135,1)
(143,126,1)
(57,59,1)
(77,138,1)
(103,23,1)
(160,112,1)
(27,114,1)
(45,59,1)
(69,99,1)
(24,63,1)
(119,38,1)
(102,143,1)
(0,155,1)
(9,129,1)
(111,152,1)
(166,106,1)
(74,113,1)
(119,91,1)
(165,107,1)
(75,138,1)
(106,79,1)
(107,120,1)
(119,161,1)
(19,76,1)
(159,11,1)
(5,112,1)
(117,79,1)
(123,59,1)
(49,47,1)
(144,88,1)
(76,28,1)
(148,81,1)
(25,127,1)
(97,59,1)
(125,15,1)
(58,166,1)
(56,59,1)
(18,145,1)
(40,6,1)
(115,71,1)
(14,37,1)
(167,40,1)
(96,27,1)
(153,16,1)
(129,167,1)
(30,70,1)
(119,100,1)
(139,30,1)
(59,163,1)
(87,74,1)
(34,87,1)
(47,111,1)
(63,103,1)
(6,35,1)
(104,68,1)
(104,76,1)
(60,13,1)
(88,48,1)
(37,61,1)
(10,59,1)
(20,148,1)
(95,49,1)
(87,90,1)
(107,59,1)
(95,117,1)
(92,83,1)
(162,140,1)
(75,92,1)
(124,144,1)
(134,45,1)
(47,79,1)
(1,134,1)
(121,58,1)
(72,123,1)
(27,76,1)
(118,97,1)
(116,43,1)
(79,154,1)
(94,96,1)
(140,101,1)
(45,60,1)
(53,64,1)
(32,73,1)
(149,56,1)
(42,69,1)
(83,78,1)
(151,110,1)
(39,165,1)
(154,0,1)
(86,57,1)
(120,131,1)
(126,142,1)
(89,59,1)
(25,89,1)
(132,17,1)
(100,5,1)
(99,66,1)
(4,59,1)
(22,70,1)
(145,14,1)
(128,149,1)
(110,59,1)
(64,159,1)
(155,7,1)
(50,162,1)
(138,79,1)
(7,124,1)
(108,82,1)
(163,95,1)
(83,79,1)
(0,112,1)
(91,115,1)
(43,132,1)
(90,51,1)
(161,72,1)
(4,20,1)
(3,125,1)
(98,41,1)
(52,121,1)
(165,127,1)
(136,24,1)
(158,109,1)
(28,75,1)
(101,14,1)
(33,80,1)
(65,52,1)
(25,165,1)
(160,8,1)
(132,150,1)
(138,130,1)
(15,158,1)
(65,79,1)
(130,32,1)
(152,117,1)
(80,39,1)
(73,25,1)
(82,98,1)
(57,116,1)
(97,94,1)
(131,29,1)
(71,2,1)
(113,101,1)
(149,56,2)
(72,115,2)
(123,115,2)
(40,59,2)
(43,115,2)
(47,115,2)
(138,79,2)
(89,115,2)
(75,138,2)
(41,115,2)
(161,141,2)
(37,61,2)
(102,115,2)
(159,115,2)
(120,115,2)
(164,115,2)
(90,101,2)
(74,101,2)
(74,14,2)
(159,11,2)
(163,95,2)
(77,115,2)
(158,115,2)
(95,115,2)
(45,115,2)
(44,115,2)
(64,115,2)
(167,40,2)
(30,115,2)
(6,115,2)
(140,101,2)
(132,17,2)
(160,112,2)
(88,5,2)
(56,115,2)
(98,115,2)
(13,115,2)
(130,115,2)
(52,58,2)
(79,154,2)
(79,5,2)
(139,115,2)
(15,76,2)
(144,5,2)
(32,115,2)
(97,115,2)
(46,58,2)
(60,115,2)
(25,89,2)
(117,115,2)
(30,70,2)
(111,115,2)
(65,58,2)
(63,58,2)
(131,115,2)
(9,115,2)
(101,14,2)
(163,115,2)
(126,115,2)
(123,59,2)
(138,115,2)
(82,115,2)
(45,59,2)
(151,110,2)
(40,115,2)
(115,58,2)
(57,115,2)
(95,49,2)
(117,79,2)
(165,107,2)
(134,45,2)
(116,115,2)
(27,76,2)
(28,75,2)
(59,115,2)
(76,28,2)
(14,37,2)
(132,115,2)
(126,30,2)
(143,115,2)
(115,71,2)
(68,115,2)
(167,115,2)
(95,117,2)
(5,112,2)
(75,115,2)
(33,115,2)
(49,47,2)
(109,115,2)
(1,115,2)
(165,127,2)
(104,115,2)
(50,101,2)
(113,101,2)
(149,115,2)
(39,115,2)
(19,115,2)
(65,79,2)
(107,59,2)
(156,115,2)
(97,59,2)
(160,58,2)
(15,115,2)
(0,5,2)
(70,79,2)
(23,58,2)
(59,163,2)
(108,115,2)
(51,101,2)
(10,115,2)
(119,100,2)
(166,5,2)
(3,115,2)
(150,115,2)
(161,115,2)
(73,115,2)
(83,115,2)
(0,112,2)
(119,91,2)
(48,5,2)
(94,115,2)
(20,115,2)
(7,5,2)
(114,115,2)
(104,76,2)
(118,115,2)
(42,115,2)
(25,127,2)
(71,58,2)
(124,5,2)
(49,115,2)
(56,59,2)
(81,115,2)
(69,115,2)
(152,115,2)
(50,14,2)
(119,38,2)
(136,58,2)
(136,24,2)
(100,5,2)
(142,115,2)
(66,115,2)
(92,115,2)
(24,112,2)
(128,115,2)
(81,135,2)
(2,58,2)
(25,115,2)
(99,115,2)
(86,115,2)
(67,115,2)
(38,58,2)
(24,58,2)
(103,58,2)
(151,115,2)
(110,115,2)
(25,165,2)
(28,115,2)
(80,115,2)
(89,59,2)
(118,97,2)
(155,5,2)
(58,79,2)
(21,115,2)
(91,115,2)
(107,115,2)
(98,76,2)
(125,115,2)
(29,115,2)
(83,79,2)
(106,5,2)
(57,59,2)
(25,167,2)
(10,59,2)
(165,115,2)
(22,115,2)
(121,58,2)
(148,115,2)
(27,115,2)
(51,50,2)
(90,51,2)
(154,0,2)
(154,5,2)
(76,115,2)
(4,59,2)
(58,5,2)
(8,58,2)
(129,115,2)
(47,79,2)
(4,115,2)
(134,115,2)
(75,92,2)
(53,115,2)
(110,59,2)
(35,115,2)
(78,115,2)
(162,101,2)
(96,115,2)
(70,115,2)
(92,83,2)
(112,34,2)
-----------------------------------
(0,te->locks)
(1,pl)
(2,thread_locks_disabled)
(3,line)
(4,pl->line)
(5,te != NULL)
(6,kind)
(7,te)
(8,te)
(9,lock)
(10,pl->lock)
(11,unsigned line)
(12,l)
(13,pl)
(14,*te = deconstify_pointer(element)
(15,l->line)
(16,te)
(17,const void *lock)
(18,te)
(19,l)
(20,line)
(21,lock)
(22,0)
(23,tls->overflow = TRUE)
(24,thread_element_name(te)
(25,g_assert_log(plock == pl->lock,\n\\n\\t\\t"%s()
(26,)
(27,l->file)
(28,&tls->arena[tls->count++])
(29,plock)
(30,tls->count != 0)
(31,)
(32,tls)
(33,plock)
(34,thread_get_main_if_first()
(35,pl)
(36,if (te != NULL)
(37,deconstify_pointer(element)
(38,return;)
(39,"%s()
(40,pl->kind)
(41,lock)
(42,count)
(43,pl)
(44,line)
(45,pl->kind)
(46,TRUE)
(47,tls->count)
(48,goto found;)
(49,tls->count - 1)
(50,&te)
(51,thread_find(&te)
(52,overflow)
(53,kind)
(54,pl)
(55,)
(56,pl->line)
(57,pl->file)
(58,tls->overflow)
(59,pl = &tls->arena[tls->count - 1])
(60,kind)
(61,const void *element)
(62,tls)
(63,te)
(64,pl)
(65,tls->overflow)
(66,"too many locks grabbed simultaneously")
(67,arena)
(68,kind)
(69,tls)
(70,tls->count)
(71,&thread_locks_disabled)
(72,kind)
(73,l)
(74,thread_element_check(te)
(75,tls->arena[tls->count++])
(76,l = &tls->arena[tls->count++])
(77,tls)
(78,count)
(79,tls = &te->locks)
(80,G_STRFUNC)
(81,pl->file = file)
(82,pl)
(83,tls->count)
(84,te)
(85,if (atomic_int_get(&thread_locks_disabled)
(86,file)
(87,te)
(88,locks_tracked)
(89,pl->lock)
(90,te = thread_find(&te)
(91,return;)
(92,tls->count++)
(93,te)
(94,file)
(95,tls->arena[tls->count - 1])
(96,pl)
(97,pl->file)
(98,l->lock)
(99,s_error("too many locks grabbed simultaneously")
(100,return;)
(101,NULL == te)
(102,tls)
(103,"%s overflowing its lock stack")
(104,l->kind)
(105,)
(106,tls)
(107,pl->lock)
(108,lock)
(109,l)
(110,pl->lock)
(111,count)
(112,te = thread_get_main_if_first()
(113,te)
(114,file)
(115,atomic_int_get(&thread_locks_disabled)
(116,file)
(117,tls->arena)
(118,l->file = pl->file)
(119,RET)
(120,lock)
(121,tls)
(122,found:)
(123,pl->kind)
(124,tls)
(125,pl)
(126,g_assert_log(tls->count != 0,\n\\n\\t\\t"%s()
(127,const void *plock)
(128,l)
(129,pl)
(130,arena)
(131,pl)
(132,pl->lock = lock)
(133,)
(134,l->kind = pl->kind)
(135,const char *file)
(136,s_rawwarn("%s overflowing its lock stack", thread_element_name(te)
(137,)
(138,tls->arena)
(139,"%s()
(140,te)
(141,enum thread_lock_kind kind)
(142,G_STRFUNC)
(143,pl)
(144,THREAD_STATS_INCX(locks_tracked)
(145,NULL)
(146,if (NULL == te)
(147,element)
(148,pl)
(149,l->line = pl->line)
(150,lock)
(151,l->lock = pl->lock)
(152,tls)
(153,NULL)
(154,&te->locks)
(155,locks)
(156,l)
(157,if (tls->overflow)
(158,line)
(159,pl->line = line)
(160,thread_lock_dump(te)
(161,pl->kind = kind)
(162,te)
(163,&tls->arena[tls->count - 1])
(164,1)
(165,plock == pl->lock)
(166,overflow)
(167,thread_lock_kind_to_string(pl->kind)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^