-----label-----
0
-----code-----
static struct rack_sendmap *
rack_alloc_limit(struct tcp_rack *rack, uint8_t limit_type)
{
	struct rack_sendmap *rsm;

	if (limit_type) {
		/* currently there is only one limit type */
		if (rack_map_split_limit > 0 &&
		    rack->r_ctl.rc_num_split_allocs >= rack_map_split_limit) {
			counter_u64_add(rack_split_limited, 1);
			if (!rack->alloc_limit_reported) {
				rack->alloc_limit_reported = 1;
				counter_u64_add(rack_alloc_limited_conns, 1);
			}
			return (NULL);
		}
	}

	/* allocate and mark in the limit type, if set */
	rsm = rack_alloc(rack);
	if (rsm != NULL && limit_type) {
		rsm->r_limit_type = limit_type;
		rack->r_ctl.rc_num_split_allocs++;
	}
	return (rsm);
}
-----children-----
1,2
1,3
1,4
2,3
4,5
4,6
4,7
4,8
7,8
7,9
8,9
10,11
10,12
13,14
13,15
14,15
16,17
18,19
18,20
18,21
18,22
18,23
19,20
20,21
20,22
21,22
23,24
23,25
26,27
26,28
27,28
29,30
30,31
30,32
31,32
31,33
32,33
32,34
33,34
36,37
36,38
37,38
37,39
38,39
38,40
39,40
43,44
45,46
45,47
45,48
46,47
47,48
47,49
47,50
48,49
50,51
53,54
53,55
54,55
55,56
55,57
56,57
59,60
59,61
60,61
61,62
61,63
62,63
62,64
63,64
67,68
68,69
68,70
68,71
69,70
71,72
74,75
75,76
76,77
78,79
79,80
79,81
80,81
82,83
82,84
83,84
85,86
87,88
87,89
88,89
88,90
89,90
89,91
90,91
92,93
94,95
96,97
96,98
97,98
98,99
98,100
99,100
99,101
100,101
103,104
105,106
106,107
107,108
107,109
108,109
108,110
109,110
113,114
114,115
115,116
-----nextToken-----
3,5,6,9,11,12,15,17,22,24,25,28,34,35,40,41,42,44,49,51,52,57,58,64,65,66,70,72,73,77,81,84,86,91,93,95,101,102,104,110,111,112,116
-----computeFrom-----
31,32
31,33
32,33
32,34
36,37
36,38
61,62
61,63
79,80
79,81
88,89
88,90
89,90
89,91
98,99
98,100
-----guardedBy-----
40,64
95,104
91,101
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;ElaboratedTypeSpecifier;Name;FunctionDeclarator;Pointer;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ReturnStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ReturnStatement;UnaryExpression;IdExpression;Name;
-----ast_node-----
static struct rack_sendmap *rack_alloc_limit(struct tcp_rack *rack, uint8_t limit_type){	struct rack_sendmap *rsm;	if (limit_type) {		/* currently there is only one limit type */		if (rack_map_split_limit > 0 &&		    rack->r_ctl.rc_num_split_allocs >= rack_map_split_limit) {			counter_u64_add(rack_split_limited, 1);			if (!rack->alloc_limit_reported) {				rack->alloc_limit_reported = 1;				counter_u64_add(rack_alloc_limited_conns, 1);			}			return (NULL);		}	}	/* allocate and mark in the limit type, if set */	rsm = rack_alloc(rack);	if (rsm != NULL && limit_type) {		rsm->r_limit_type = limit_type;		rack->r_ctl.rc_num_split_allocs++;	}	return (rsm);}
static struct rack_sendmap
rack_sendmap
*rack_alloc_limit(struct tcp_rack *rack, uint8_t limit_type)
*
rack_alloc_limit
struct tcp_rack *rack
struct tcp_rack
tcp_rack
*rack
*
rack
uint8_t limit_type
uint8_t
uint8_t
limit_type
limit_type
{	struct rack_sendmap *rsm;	if (limit_type) {		/* currently there is only one limit type */		if (rack_map_split_limit > 0 &&		    rack->r_ctl.rc_num_split_allocs >= rack_map_split_limit) {			counter_u64_add(rack_split_limited, 1);			if (!rack->alloc_limit_reported) {				rack->alloc_limit_reported = 1;				counter_u64_add(rack_alloc_limited_conns, 1);			}			return (NULL);		}	}	/* allocate and mark in the limit type, if set */	rsm = rack_alloc(rack);	if (rsm != NULL && limit_type) {		rsm->r_limit_type = limit_type;		rack->r_ctl.rc_num_split_allocs++;	}	return (rsm);}
struct rack_sendmap *rsm;
struct rack_sendmap *rsm;
struct rack_sendmap
rack_sendmap
*rsm
*
rsm
if (limit_type) {		/* currently there is only one limit type */		if (rack_map_split_limit > 0 &&		    rack->r_ctl.rc_num_split_allocs >= rack_map_split_limit) {			counter_u64_add(rack_split_limited, 1);			if (!rack->alloc_limit_reported) {				rack->alloc_limit_reported = 1;				counter_u64_add(rack_alloc_limited_conns, 1);			}			return (NULL);		}	}
limit_type
limit_type
{		/* currently there is only one limit type */		if (rack_map_split_limit > 0 &&		    rack->r_ctl.rc_num_split_allocs >= rack_map_split_limit) {			counter_u64_add(rack_split_limited, 1);			if (!rack->alloc_limit_reported) {				rack->alloc_limit_reported = 1;				counter_u64_add(rack_alloc_limited_conns, 1);			}			return (NULL);		}	}
if (rack_map_split_limit > 0 &&		    rack->r_ctl.rc_num_split_allocs >= rack_map_split_limit) {			counter_u64_add(rack_split_limited, 1);			if (!rack->alloc_limit_reported) {				rack->alloc_limit_reported = 1;				counter_u64_add(rack_alloc_limited_conns, 1);			}			return (NULL);		}
rack_map_split_limit > 0 &&		    rack->r_ctl.rc_num_split_allocs >= rack_map_split_limit
rack_map_split_limit > 0
rack_map_split_limit
rack_map_split_limit
0
rack->r_ctl.rc_num_split_allocs >= rack_map_split_limit
rack->r_ctl.rc_num_split_allocs
rack->r_ctl
rack
rack
r_ctl
rc_num_split_allocs
rack_map_split_limit
rack_map_split_limit
{			counter_u64_add(rack_split_limited, 1);			if (!rack->alloc_limit_reported) {				rack->alloc_limit_reported = 1;				counter_u64_add(rack_alloc_limited_conns, 1);			}			return (NULL);		}
counter_u64_add(rack_split_limited, 1);
counter_u64_add(rack_split_limited, 1)
counter_u64_add
counter_u64_add
rack_split_limited
rack_split_limited
1
if (!rack->alloc_limit_reported) {				rack->alloc_limit_reported = 1;				counter_u64_add(rack_alloc_limited_conns, 1);			}
!rack->alloc_limit_reported
rack->alloc_limit_reported
rack
rack
alloc_limit_reported
{				rack->alloc_limit_reported = 1;				counter_u64_add(rack_alloc_limited_conns, 1);			}
rack->alloc_limit_reported = 1;
rack->alloc_limit_reported = 1
rack->alloc_limit_reported
rack
rack
alloc_limit_reported
1
counter_u64_add(rack_alloc_limited_conns, 1);
counter_u64_add(rack_alloc_limited_conns, 1)
counter_u64_add
counter_u64_add
rack_alloc_limited_conns
rack_alloc_limited_conns
1
return (NULL);
(NULL)
NULL
NULL
rsm = rack_alloc(rack);
rsm = rack_alloc(rack)
rsm
rsm
rack_alloc(rack)
rack_alloc
rack_alloc
rack
rack
if (rsm != NULL && limit_type) {		rsm->r_limit_type = limit_type;		rack->r_ctl.rc_num_split_allocs++;	}
rsm != NULL && limit_type
rsm != NULL
rsm
rsm
NULL
NULL
limit_type
limit_type
{		rsm->r_limit_type = limit_type;		rack->r_ctl.rc_num_split_allocs++;	}
rsm->r_limit_type = limit_type;
rsm->r_limit_type = limit_type
rsm->r_limit_type
rsm
rsm
r_limit_type
limit_type
limit_type
rack->r_ctl.rc_num_split_allocs++;
rack->r_ctl.rc_num_split_allocs++
rack->r_ctl.rc_num_split_allocs
rack->r_ctl
rack
rack
r_ctl
rc_num_split_allocs
return (rsm);
(rsm)
rsm
rsm
-----joern-----
(42,46,0)
(25,51,0)
(50,45,0)
(58,59,0)
(30,11,0)
(14,59,0)
(62,60,0)
(6,37,0)
(54,5,0)
(31,40,0)
(4,5,0)
(37,6,0)
(47,8,0)
(24,58,0)
(45,19,0)
(2,38,0)
(48,23,0)
(61,38,0)
(38,58,0)
(49,46,0)
(12,10,0)
(21,14,0)
(3,31,0)
(46,60,0)
(43,40,0)
(27,14,0)
(22,33,0)
(45,44,0)
(13,51,0)
(34,50,0)
(35,56,0)
(51,11,0)
(8,14,0)
(17,50,0)
(55,31,0)
(18,48,0)
(8,40,0)
(53,8,0)
(1,19,0)
(20,37,0)
(15,37,0)
(51,59,0)
(10,1,0)
(1,10,0)
(60,46,0)
(6,9,0)
(0,56,0)
(5,59,0)
(39,57,0)
(63,9,0)
(41,52,0)
(58,38,0)
(32,45,0)
(50,38,0)
(9,6,0)
(9,11,0)
(61,56,0)
(5,7,0)
(47,61,0)
(11,9,0)
(14,48,0)
(46,38,0)
(10,57,0)
(26,56,0)
(28,61,0)
(11,51,0)
(60,44,0)
(57,59,0)
(57,10,0)
(36,57,0)
(52,23,0)
(7,5,0)
(38,56,0)
(29,52,0)
(46,38,1)
(63,11,1)
(14,59,1)
(6,37,1)
(12,57,1)
(46,42,1)
(54,31,1)
(57,36,1)
(3,55,1)
(38,58,1)
(30,51,1)
(52,41,1)
(32,50,1)
(50,34,1)
(21,7,1)
(9,11,1)
(51,13,1)
(8,53,1)
(50,38,1)
(5,4,1)
(25,37,1)
(31,3,1)
(49,38,1)
(24,2,1)
(47,61,1)
(41,29,1)
(27,21,1)
(28,1,1)
(2,6,1)
(61,38,1)
(51,59,1)
(17,60,1)
(34,17,1)
(10,12,1)
(53,7,1)
(47,8,1)
(20,16,1)
(6,9,1)
(28,60,1)
(11,30,1)
(11,51,1)
(60,46,1)
(29,48,1)
(62,46,1)
(48,18,1)
(13,25,1)
(45,44,1)
(4,54,1)
(5,59,1)
(7,5,1)
(18,14,1)
(36,39,1)
(2,16,1)
(55,6,1)
(42,49,1)
(9,63,1)
(37,15,1)
(53,52,1)
(45,32,1)
(57,59,1)
(39,45,1)
(58,24,1)
(60,44,1)
(61,28,1)
(58,59,1)
(60,62,1)
(15,20,1)
(8,14,1)
(10,57,1)
(1,10,1)
(14,27,1)
(46,16,2)
(58,59,2)
(10,60,2)
(60,44,2)
(39,60,2)
(60,6,2)
(36,60,2)
(20,16,2)
(46,6,2)
(60,16,2)
(34,60,2)
(38,6,2)
(53,6,2)
(24,16,2)
(10,57,2)
(5,59,2)
(13,37,2)
(30,37,2)
(4,6,2)
(3,6,2)
(37,16,2)
(61,38,2)
(41,7,2)
(42,16,2)
(7,6,2)
(50,38,2)
(11,37,2)
(28,6,2)
(58,6,2)
(49,6,2)
(63,37,2)
(7,5,2)
(11,51,2)
(6,37,2)
(51,59,2)
(5,6,2)
(1,60,2)
(47,8,2)
(51,37,2)
(15,16,2)
(28,16,2)
(2,16,2)
(38,16,2)
(14,7,2)
(27,7,2)
(32,60,2)
(6,16,2)
(60,46,2)
(21,7,2)
(8,14,2)
(61,6,2)
(46,38,2)
(38,58,2)
(47,61,2)
(9,37,2)
(57,60,2)
(45,60,2)
(9,11,2)
(50,60,2)
(58,16,2)
(24,6,2)
(12,60,2)
(55,6,2)
(6,9,2)
(31,6,2)
(52,7,2)
(2,6,2)
(54,6,2)
(8,6,2)
(62,46,2)
(49,16,2)
(45,44,2)
(17,60,2)
(18,7,2)
(29,7,2)
(57,59,2)
(25,37,2)
(42,6,2)
(14,59,2)
(48,7,2)
(1,10,2)
(61,16,2)
-----------------------------------
(0,if (limit_type)
(1,rack->r_ctl.rc_num_split_allocs++)
(2,rsm)
(3,1)
(4,alloc_limit_reported)
(5,rack->alloc_limit_reported)
(6,rack_map_split_limit > 0 &&\n\\n\\t\\t    rack->r_ctl.rc_num_split_allocs >= rack_map_split_limit)
(7,!rack->alloc_limit_reported)
(8,return (NULL)
(9,rack->r_ctl.rc_num_split_allocs >= rack_map_split_limit)
(10,rack->r_ctl.rc_num_split_allocs)
(11,rack->r_ctl.rc_num_split_allocs)
(12,rc_num_split_allocs)
(13,r_ctl)
(14,rack->alloc_limit_reported)
(15,0)
(16,limit_type)
(17,rsm)
(18,1)
(19,)
(20,rack_map_split_limit)
(21,rack)
(22,if (rack_map_split_limit > 0 &&\n\\n\\t\\t    rack->r_ctl.rc_num_split_allocs >= rack_map_split_limit)
(23,)
(24,rack)
(25,rack)
(26,if (rsm != NULL && limit_type)
(27,alloc_limit_reported)
(28,rsm)
(29,rack_alloc_limited_conns)
(30,rc_num_split_allocs)
(31,counter_u64_add(rack_split_limited, 1)
(32,limit_type)
(33,)
(34,r_limit_type)
(35,rsm)
(36,r_ctl)
(37,rack_map_split_limit > 0)
(38,rsm = rack_alloc(rack)
(39,rack)
(40,)
(41,1)
(42,NULL)
(43,if (!rack->alloc_limit_reported)
(44,uint8_t limit_type)
(45,rsm->r_limit_type = limit_type)
(46,rsm != NULL)
(47,RET)
(48,rack->alloc_limit_reported = 1)
(49,rsm)
(50,rsm->r_limit_type)
(51,rack->r_ctl)
(52,counter_u64_add(rack_alloc_limited_conns, 1)
(53,NULL)
(54,rack)
(55,rack_split_limited)
(56,)
(57,rack->r_ctl)
(58,rack_alloc(rack)
(59,struct tcp_rack *rack)
(60,rsm != NULL && limit_type)
(61,return (rsm)
(62,limit_type)
(63,rack_map_split_limit)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^