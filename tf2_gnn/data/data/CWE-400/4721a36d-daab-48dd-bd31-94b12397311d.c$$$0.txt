-----label-----
0
-----code-----
void
tcp_init(void)
{
	const char *tcbhash_tuneable;
	int hashsize;

	tcbhash_tuneable = "net.inet.tcp.tcbhashsize";

	if (hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_IN,
	    &V_tcp_hhh[HHOOK_TCP_EST_IN], HHOOK_NOWAIT|HHOOK_HEADISINVNET) != 0)
		printf("%s: WARNING: unable to register helper hook\n", __func__);
	if (hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_OUT,
	    &V_tcp_hhh[HHOOK_TCP_EST_OUT], HHOOK_NOWAIT|HHOOK_HEADISINVNET) != 0)
		printf("%s: WARNING: unable to register helper hook\n", __func__);

	hashsize = TCBHASHSIZE;
	TUNABLE_INT_FETCH(tcbhash_tuneable, &hashsize);
	if (hashsize == 0) {
		/*
		 * Auto tune the hash size based on maxsockets.
		 * A perfect hash would have a 1:1 mapping
		 * (hashsize = maxsockets) however it's been
		 * suggested that O(2) average is better.
		 */
		hashsize = maketcp_hashsize(maxsockets / 4);
		/*
		 * Our historical default is 512,
		 * do not autotune lower than this.
		 */
		if (hashsize < 512)
			hashsize = 512;
		if (bootverbose)
			printf("%s: %s auto tuned to %d\n", __func__,
			    tcbhash_tuneable, hashsize);
	}
	/*
	 * We require a hashsize to be a power of two.
	 * Previously if it was not a power of two we would just reset it
	 * back to 512, which could be a nasty surprise if you did not notice
	 * the error message.
	 * Instead what we do is clip it to the closest power of two lower
	 * than the specified hash value.
	 */
	if (!powerof2(hashsize)) {
		int oldhashsize = hashsize;

		hashsize = maketcp_hashsize(hashsize);
		/* prevent absurdly low value */
		if (hashsize < 16)
			hashsize = 16;
		printf("%s: WARNING: TCB hash size not a power of 2, "
		    "clipped from %d to %d.\n", __func__, oldhashsize,
		    hashsize);
	}
	in_pcbinfo_init(&V_tcbinfo, "tcp", &V_tcb, hashsize, hashsize,
	    "tcp_inpcb", tcp_inpcb_init, NULL, UMA_ZONE_NOFREE,
	    IPI_HASHFIELDS_4TUPLE);

	/*
	 * These have to be type stable for the benefit of the timers.
	 */
	V_tcpcb_zone = uma_zcreate("tcpcb", sizeof(struct tcpcb_mem),
	    NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, UMA_ZONE_NOFREE);
	uma_zone_set_max(V_tcpcb_zone, maxsockets);
	uma_zone_set_warning(V_tcpcb_zone, "kern.ipc.maxsockets limit reached");

	tcp_tw_init();
	syncache_init();
	tcp_hc_init();
	tcp_reass_init();

	TUNABLE_INT_FETCH("net.inet.tcp.sack.enable", &V_tcp_do_sack);
	V_sack_hole_zone = uma_zcreate("sackhole", sizeof(struct sackhole),
	    NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, UMA_ZONE_NOFREE);

	/* Skip initialization of globals for non-default instances. */
	if (!IS_DEFAULT_VNET(curvnet))
		return;

	/* XXX virtualize those bellow? */
	tcp_delacktime = TCPTV_DELACK;
	tcp_keepinit = TCPTV_KEEP_INIT;
	tcp_keepidle = TCPTV_KEEP_IDLE;
	tcp_keepintvl = TCPTV_KEEPINTVL;
	tcp_maxpersistidle = TCPTV_KEEP_IDLE;
	tcp_msl = TCPTV_MSL;
	tcp_rexmit_min = TCPTV_MIN;
	if (tcp_rexmit_min < 1)
		tcp_rexmit_min = 1;
	tcp_rexmit_slop = TCPTV_CPU_VAR;
	tcp_finwait2_timeout = TCPTV_FINWAIT2_TIMEOUT;
	tcp_tcbhashsize = hashsize;

	TUNABLE_INT_FETCH("net.inet.tcp.soreceive_stream", &tcp_soreceive_stream);
	if (tcp_soreceive_stream) {
#ifdef INET
		tcp_usrreqs.pru_soreceive = soreceive_stream;
#endif
#ifdef INET6
		tcp6_usrreqs.pru_soreceive = soreceive_stream;
#endif /* INET6 */
	}

#ifdef INET6
#define TCP_MINPROTOHDR (sizeof(struct ip6_hdr) + sizeof(struct tcphdr))
#else /* INET6 */
#define TCP_MINPROTOHDR (sizeof(struct tcpiphdr))
#endif /* INET6 */
	if (max_protohdr < TCP_MINPROTOHDR)
		max_protohdr = TCP_MINPROTOHDR;
	if (max_linkhdr + TCP_MINPROTOHDR > MHLEN)
		panic("tcp_init");
#undef TCP_MINPROTOHDR

	ISN_LOCK_INIT();
	EVENTHANDLER_REGISTER(shutdown_pre_sync, tcp_fini, NULL,
		SHUTDOWN_PRI_DEFAULT);
	EVENTHANDLER_REGISTER(maxsockets_change, tcp_zone_change, NULL,
		EVENTHANDLER_PRI_ANY);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
9,10
9,11
9,12
9,13
9,14
9,15
9,16
9,17
9,18
9,19
9,20
9,21
9,22
9,23
9,24
9,25
9,26
9,27
9,28
9,29
9,30
9,31
9,32
9,33
9,34
9,35
9,36
9,37
9,38
9,39
9,40
9,41
9,42
9,43
9,44
9,45
9,46
9,47
10,11
11,12
11,13
13,14
13,15
16,17
17,18
17,19
19,20
21,22
22,23
22,24
23,24
26,27
26,28
27,28
27,29
28,29
28,30
28,31
28,32
28,33
29,30
31,32
33,34
35,36
36,37
36,38
37,38
39,40
41,42
41,43
42,43
44,45
47,48
48,49
48,50
48,51
49,50
52,53
54,55
54,56
55,56
55,57
56,57
56,58
56,59
56,60
56,61
57,58
59,60
61,62
63,64
64,65
64,66
65,66
67,68
69,70
69,71
70,71
72,73
75,76
76,77
76,78
76,79
77,78
80,81
82,83
83,84
83,85
84,85
86,87
88,89
89,90
89,91
89,92
90,91
92,93
94,95
95,96
97,98
97,99
98,99
98,100
99,100
102,103
102,104
102,105
103,104
104,105
104,106
105,106
107,108
107,109
108,109
110,111
110,112
111,112
114,115
114,116
115,116
115,117
116,117
119,120
120,121
120,122
121,122
124,125
124,126
125,126
127,128
128,129
128,130
128,131
128,132
128,133
129,130
132,133
134,135
136,137
138,139
138,140
139,140
140,141
140,142
141,142
143,144
145,146
145,147
145,148
145,149
146,147
147,148
147,149
149,150
149,151
151,152
152,153
154,155
155,156
155,157
156,157
158,159
158,160
159,160
161,162
163,164
163,165
164,165
164,166
165,166
168,169
169,170
169,171
170,171
173,174
174,175
174,176
174,177
174,178
174,179
175,176
178,179
180,181
182,183
184,185
185,186
185,187
185,188
185,189
185,190
185,191
185,192
185,193
185,194
185,195
185,196
186,187
188,189
189,190
192,193
193,194
195,196
197,198
200,201
202,203
204,205
206,207
208,209
209,210
209,211
210,211
212,213
212,214
212,215
212,216
212,217
212,218
212,219
212,220
212,221
213,214
216,217
217,218
217,219
218,219
221,222
223,224
225,226
227,228
229,230
231,232
233,234
234,235
234,236
234,237
235,236
237,238
239,240
241,242
242,243
242,244
242,245
243,244
245,246
248,249
249,250
250,251
252,253
253,254
254,255
256,257
257,258
258,259
260,261
261,262
262,263
264,265
265,266
265,267
265,268
266,267
269,270
270,271
272,273
273,274
273,275
274,275
276,277
276,278
276,279
276,280
276,281
276,282
276,283
276,284
276,285
277,278
280,281
281,282
281,283
282,283
285,286
287,288
289,290
291,292
293,294
295,296
297,298
297,299
298,299
299,300
299,301
300,301
302,303
305,306
306,307
306,308
307,308
309,310
311,312
312,313
312,314
313,314
315,316
317,318
318,319
318,320
319,320
321,322
323,324
324,325
324,326
325,326
327,328
329,330
330,331
330,332
331,332
333,334
335,336
336,337
336,338
337,338
339,340
341,342
342,343
342,344
343,344
345,346
347,348
347,349
348,349
348,350
349,350
352,353
353,354
353,355
354,355
357,358
358,359
358,360
359,360
361,362
363,364
364,365
364,366
365,366
367,368
369,370
370,371
370,372
371,372
373,374
375,376
376,377
376,378
376,379
377,378
380,381
381,382
383,384
383,385
384,385
387,388
387,389
388,389
388,390
389,390
391,392
392,393
393,394
393,395
394,395
397,398
398,399
398,400
399,400
401,402
402,403
403,404
403,405
404,405
407,408
407,409
408,409
408,410
409,410
409,411
410,411
412,413
413,414
414,415
414,416
415,416
418,419
420,421
421,422
421,423
422,423
425,426
426,427
427,428
429,430
430,431
430,432
430,433
430,434
430,435
431,432
433,434
435,436
437,438
439,440
441,442
442,443
442,444
442,445
442,446
442,447
443,444
445,446
447,448
449,450
451,452
-----nextToken-----
2,4,6,8,12,14,15,18,20,24,25,30,32,34,38,40,43,45,46,50,51,53,58,60,62,66,68,71,73,74,78,79,81,85,87,91,93,96,100,101,106,109,112,113,117,118,122,123,126,130,131,133,135,137,142,144,148,150,153,157,160,162,166,167,171,172,176,177,179,181,183,187,190,191,194,196,198,199,201,203,205,207,211,214,215,219,220,222,224,226,228,230,232,236,238,240,244,246,247,251,255,259,263,267,268,271,275,278,279,283,284,286,288,290,292,294,296,301,303,304,308,310,314,316,320,322,326,328,332,334,338,340,344,346,350,351,355,356,360,362,366,368,372,374,378,379,382,385,386,390,395,396,400,405,406,411,416,417,419,423,424,428,432,434,436,438,440,444,446,448,450,452
-----computeFrom-----
22,23
22,24
27,28
27,29
41,42
41,43
55,56
55,57
69,70
69,71
83,84
83,85
98,99
98,100
104,105
104,106
110,111
110,112
115,116
115,117
120,121
120,122
155,156
155,157
164,165
164,166
169,170
169,171
209,210
209,211
273,274
273,275
306,307
306,308
312,313
312,314
318,319
318,320
324,325
324,326
330,331
330,332
336,337
336,338
342,343
342,344
348,349
348,350
353,354
353,355
358,359
358,360
364,365
364,366
370,371
370,372
388,389
388,390
398,399
398,400
408,409
408,410
409,410
409,411
-----guardedBy-----
100,137
117,122
166,171
350,355
395,405
390,400
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;TypeIdExpression;TypeId;ElaboratedTypeSpecifier;Name;Declarator;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;
-----ast_node-----
voidtcp_init(void){	const char *tcbhash_tuneable;	int hashsize;	tcbhash_tuneable = "net.inet.tcp.tcbhashsize";	if (hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_IN,	    &V_tcp_hhh[HHOOK_TCP_EST_IN], HHOOK_NOWAIT|HHOOK_HEADISINVNET) != 0)		printf("%s: WARNING: unable to register helper hook\n", __func__);	if (hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_OUT,	    &V_tcp_hhh[HHOOK_TCP_EST_OUT], HHOOK_NOWAIT|HHOOK_HEADISINVNET) != 0)		printf("%s: WARNING: unable to register helper hook\n", __func__);	hashsize = TCBHASHSIZE;	TUNABLE_INT_FETCH(tcbhash_tuneable, &hashsize);	if (hashsize == 0) {		/*		 * Auto tune the hash size based on maxsockets.		 * A perfect hash would have a 1:1 mapping		 * (hashsize = maxsockets) however it's been		 * suggested that O(2) average is better.		 */		hashsize = maketcp_hashsize(maxsockets / 4);		/*		 * Our historical default is 512,		 * do not autotune lower than this.		 */		if (hashsize < 512)			hashsize = 512;		if (bootverbose)			printf("%s: %s auto tuned to %d\n", __func__,			    tcbhash_tuneable, hashsize);	}	/*	 * We require a hashsize to be a power of two.	 * Previously if it was not a power of two we would just reset it	 * back to 512, which could be a nasty surprise if you did not notice	 * the error message.	 * Instead what we do is clip it to the closest power of two lower	 * than the specified hash value.	 */	if (!powerof2(hashsize)) {		int oldhashsize = hashsize;		hashsize = maketcp_hashsize(hashsize);		/* prevent absurdly low value */		if (hashsize < 16)			hashsize = 16;		printf("%s: WARNING: TCB hash size not a power of 2, "		    "clipped from %d to %d.\n", __func__, oldhashsize,		    hashsize);	}	in_pcbinfo_init(&V_tcbinfo, "tcp", &V_tcb, hashsize, hashsize,	    "tcp_inpcb", tcp_inpcb_init, NULL, UMA_ZONE_NOFREE,	    IPI_HASHFIELDS_4TUPLE);	/*	 * These have to be type stable for the benefit of the timers.	 */	V_tcpcb_zone = uma_zcreate("tcpcb", sizeof(struct tcpcb_mem),	    NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, UMA_ZONE_NOFREE);	uma_zone_set_max(V_tcpcb_zone, maxsockets);	uma_zone_set_warning(V_tcpcb_zone, "kern.ipc.maxsockets limit reached");	tcp_tw_init();	syncache_init();	tcp_hc_init();	tcp_reass_init();	TUNABLE_INT_FETCH("net.inet.tcp.sack.enable", &V_tcp_do_sack);	V_sack_hole_zone = uma_zcreate("sackhole", sizeof(struct sackhole),	    NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, UMA_ZONE_NOFREE);	/* Skip initialization of globals for non-default instances. */	if (!IS_DEFAULT_VNET(curvnet))		return;	/* XXX virtualize those bellow? */	tcp_delacktime = TCPTV_DELACK;	tcp_keepinit = TCPTV_KEEP_INIT;	tcp_keepidle = TCPTV_KEEP_IDLE;	tcp_keepintvl = TCPTV_KEEPINTVL;	tcp_maxpersistidle = TCPTV_KEEP_IDLE;	tcp_msl = TCPTV_MSL;	tcp_rexmit_min = TCPTV_MIN;	if (tcp_rexmit_min < 1)		tcp_rexmit_min = 1;	tcp_rexmit_slop = TCPTV_CPU_VAR;	tcp_finwait2_timeout = TCPTV_FINWAIT2_TIMEOUT;	tcp_tcbhashsize = hashsize;	TUNABLE_INT_FETCH("net.inet.tcp.soreceive_stream", &tcp_soreceive_stream);	if (tcp_soreceive_stream) {#ifdef INET		tcp_usrreqs.pru_soreceive = soreceive_stream;#endif#ifdef INET6		tcp6_usrreqs.pru_soreceive = soreceive_stream;#endif /* INET6 */	}#ifdef INET6#define TCP_MINPROTOHDR (sizeof(struct ip6_hdr) + sizeof(struct tcphdr))#else /* INET6 */#define TCP_MINPROTOHDR (sizeof(struct tcpiphdr))#endif /* INET6 */	if (max_protohdr < TCP_MINPROTOHDR)		max_protohdr = TCP_MINPROTOHDR;	if (max_linkhdr + TCP_MINPROTOHDR > MHLEN)		panic("tcp_init");#undef TCP_MINPROTOHDR	ISN_LOCK_INIT();	EVENTHANDLER_REGISTER(shutdown_pre_sync, tcp_fini, NULL,		SHUTDOWN_PRI_DEFAULT);	EVENTHANDLER_REGISTER(maxsockets_change, tcp_zone_change, NULL,		EVENTHANDLER_PRI_ANY);}
void
tcp_init(void)
tcp_init
void
void


{	const char *tcbhash_tuneable;	int hashsize;	tcbhash_tuneable = "net.inet.tcp.tcbhashsize";	if (hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_IN,	    &V_tcp_hhh[HHOOK_TCP_EST_IN], HHOOK_NOWAIT|HHOOK_HEADISINVNET) != 0)		printf("%s: WARNING: unable to register helper hook\n", __func__);	if (hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_OUT,	    &V_tcp_hhh[HHOOK_TCP_EST_OUT], HHOOK_NOWAIT|HHOOK_HEADISINVNET) != 0)		printf("%s: WARNING: unable to register helper hook\n", __func__);	hashsize = TCBHASHSIZE;	TUNABLE_INT_FETCH(tcbhash_tuneable, &hashsize);	if (hashsize == 0) {		/*		 * Auto tune the hash size based on maxsockets.		 * A perfect hash would have a 1:1 mapping		 * (hashsize = maxsockets) however it's been		 * suggested that O(2) average is better.		 */		hashsize = maketcp_hashsize(maxsockets / 4);		/*		 * Our historical default is 512,		 * do not autotune lower than this.		 */		if (hashsize < 512)			hashsize = 512;		if (bootverbose)			printf("%s: %s auto tuned to %d\n", __func__,			    tcbhash_tuneable, hashsize);	}	/*	 * We require a hashsize to be a power of two.	 * Previously if it was not a power of two we would just reset it	 * back to 512, which could be a nasty surprise if you did not notice	 * the error message.	 * Instead what we do is clip it to the closest power of two lower	 * than the specified hash value.	 */	if (!powerof2(hashsize)) {		int oldhashsize = hashsize;		hashsize = maketcp_hashsize(hashsize);		/* prevent absurdly low value */		if (hashsize < 16)			hashsize = 16;		printf("%s: WARNING: TCB hash size not a power of 2, "		    "clipped from %d to %d.\n", __func__, oldhashsize,		    hashsize);	}	in_pcbinfo_init(&V_tcbinfo, "tcp", &V_tcb, hashsize, hashsize,	    "tcp_inpcb", tcp_inpcb_init, NULL, UMA_ZONE_NOFREE,	    IPI_HASHFIELDS_4TUPLE);	/*	 * These have to be type stable for the benefit of the timers.	 */	V_tcpcb_zone = uma_zcreate("tcpcb", sizeof(struct tcpcb_mem),	    NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, UMA_ZONE_NOFREE);	uma_zone_set_max(V_tcpcb_zone, maxsockets);	uma_zone_set_warning(V_tcpcb_zone, "kern.ipc.maxsockets limit reached");	tcp_tw_init();	syncache_init();	tcp_hc_init();	tcp_reass_init();	TUNABLE_INT_FETCH("net.inet.tcp.sack.enable", &V_tcp_do_sack);	V_sack_hole_zone = uma_zcreate("sackhole", sizeof(struct sackhole),	    NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, UMA_ZONE_NOFREE);	/* Skip initialization of globals for non-default instances. */	if (!IS_DEFAULT_VNET(curvnet))		return;	/* XXX virtualize those bellow? */	tcp_delacktime = TCPTV_DELACK;	tcp_keepinit = TCPTV_KEEP_INIT;	tcp_keepidle = TCPTV_KEEP_IDLE;	tcp_keepintvl = TCPTV_KEEPINTVL;	tcp_maxpersistidle = TCPTV_KEEP_IDLE;	tcp_msl = TCPTV_MSL;	tcp_rexmit_min = TCPTV_MIN;	if (tcp_rexmit_min < 1)		tcp_rexmit_min = 1;	tcp_rexmit_slop = TCPTV_CPU_VAR;	tcp_finwait2_timeout = TCPTV_FINWAIT2_TIMEOUT;	tcp_tcbhashsize = hashsize;	TUNABLE_INT_FETCH("net.inet.tcp.soreceive_stream", &tcp_soreceive_stream);	if (tcp_soreceive_stream) {#ifdef INET		tcp_usrreqs.pru_soreceive = soreceive_stream;#endif#ifdef INET6		tcp6_usrreqs.pru_soreceive = soreceive_stream;#endif /* INET6 */	}#ifdef INET6#define TCP_MINPROTOHDR (sizeof(struct ip6_hdr) + sizeof(struct tcphdr))#else /* INET6 */#define TCP_MINPROTOHDR (sizeof(struct tcpiphdr))#endif /* INET6 */	if (max_protohdr < TCP_MINPROTOHDR)		max_protohdr = TCP_MINPROTOHDR;	if (max_linkhdr + TCP_MINPROTOHDR > MHLEN)		panic("tcp_init");#undef TCP_MINPROTOHDR	ISN_LOCK_INIT();	EVENTHANDLER_REGISTER(shutdown_pre_sync, tcp_fini, NULL,		SHUTDOWN_PRI_DEFAULT);	EVENTHANDLER_REGISTER(maxsockets_change, tcp_zone_change, NULL,		EVENTHANDLER_PRI_ANY);}
const char *tcbhash_tuneable;
const char *tcbhash_tuneable;
const char
*tcbhash_tuneable
*
tcbhash_tuneable
int hashsize;
int hashsize;
int
hashsize
hashsize
tcbhash_tuneable = "net.inet.tcp.tcbhashsize";
tcbhash_tuneable = "net.inet.tcp.tcbhashsize"
tcbhash_tuneable
tcbhash_tuneable
"net.inet.tcp.tcbhashsize"
if (hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_IN,	    &V_tcp_hhh[HHOOK_TCP_EST_IN], HHOOK_NOWAIT|HHOOK_HEADISINVNET) != 0)		printf("%s: WARNING: unable to register helper hook\n", __func__);
hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_IN,	    &V_tcp_hhh[HHOOK_TCP_EST_IN], HHOOK_NOWAIT|HHOOK_HEADISINVNET) != 0
hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_IN,	    &V_tcp_hhh[HHOOK_TCP_EST_IN], HHOOK_NOWAIT|HHOOK_HEADISINVNET)
hhook_head_register
hhook_head_register
HHOOK_TYPE_TCP
HHOOK_TYPE_TCP
HHOOK_TCP_EST_IN
HHOOK_TCP_EST_IN
&V_tcp_hhh[HHOOK_TCP_EST_IN]
V_tcp_hhh[HHOOK_TCP_EST_IN]
V_tcp_hhh
V_tcp_hhh
HHOOK_TCP_EST_IN
HHOOK_TCP_EST_IN
HHOOK_NOWAIT|HHOOK_HEADISINVNET
HHOOK_NOWAIT
HHOOK_NOWAIT
HHOOK_HEADISINVNET
HHOOK_HEADISINVNET
0
printf("%s: WARNING: unable to register helper hook\n", __func__);
printf("%s: WARNING: unable to register helper hook\n", __func__)
printf
printf
"%s: WARNING: unable to register helper hook\n"
__func__
__func__
if (hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_OUT,	    &V_tcp_hhh[HHOOK_TCP_EST_OUT], HHOOK_NOWAIT|HHOOK_HEADISINVNET) != 0)		printf("%s: WARNING: unable to register helper hook\n", __func__);
hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_OUT,	    &V_tcp_hhh[HHOOK_TCP_EST_OUT], HHOOK_NOWAIT|HHOOK_HEADISINVNET) != 0
hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_OUT,	    &V_tcp_hhh[HHOOK_TCP_EST_OUT], HHOOK_NOWAIT|HHOOK_HEADISINVNET)
hhook_head_register
hhook_head_register
HHOOK_TYPE_TCP
HHOOK_TYPE_TCP
HHOOK_TCP_EST_OUT
HHOOK_TCP_EST_OUT
&V_tcp_hhh[HHOOK_TCP_EST_OUT]
V_tcp_hhh[HHOOK_TCP_EST_OUT]
V_tcp_hhh
V_tcp_hhh
HHOOK_TCP_EST_OUT
HHOOK_TCP_EST_OUT
HHOOK_NOWAIT|HHOOK_HEADISINVNET
HHOOK_NOWAIT
HHOOK_NOWAIT
HHOOK_HEADISINVNET
HHOOK_HEADISINVNET
0
printf("%s: WARNING: unable to register helper hook\n", __func__);
printf("%s: WARNING: unable to register helper hook\n", __func__)
printf
printf
"%s: WARNING: unable to register helper hook\n"
__func__
__func__
hashsize = TCBHASHSIZE;
hashsize = TCBHASHSIZE
hashsize
hashsize
TCBHASHSIZE
TCBHASHSIZE
TUNABLE_INT_FETCH(tcbhash_tuneable, &hashsize);
TUNABLE_INT_FETCH(tcbhash_tuneable, &hashsize)
TUNABLE_INT_FETCH
TUNABLE_INT_FETCH
tcbhash_tuneable
tcbhash_tuneable
&hashsize
hashsize
hashsize
if (hashsize == 0) {		/*		 * Auto tune the hash size based on maxsockets.		 * A perfect hash would have a 1:1 mapping		 * (hashsize = maxsockets) however it's been		 * suggested that O(2) average is better.		 */		hashsize = maketcp_hashsize(maxsockets / 4);		/*		 * Our historical default is 512,		 * do not autotune lower than this.		 */		if (hashsize < 512)			hashsize = 512;		if (bootverbose)			printf("%s: %s auto tuned to %d\n", __func__,			    tcbhash_tuneable, hashsize);	}
hashsize == 0
hashsize
hashsize
0
{		/*		 * Auto tune the hash size based on maxsockets.		 * A perfect hash would have a 1:1 mapping		 * (hashsize = maxsockets) however it's been		 * suggested that O(2) average is better.		 */		hashsize = maketcp_hashsize(maxsockets / 4);		/*		 * Our historical default is 512,		 * do not autotune lower than this.		 */		if (hashsize < 512)			hashsize = 512;		if (bootverbose)			printf("%s: %s auto tuned to %d\n", __func__,			    tcbhash_tuneable, hashsize);	}
hashsize = maketcp_hashsize(maxsockets / 4);
hashsize = maketcp_hashsize(maxsockets / 4)
hashsize
hashsize
maketcp_hashsize(maxsockets / 4)
maketcp_hashsize
maketcp_hashsize
maxsockets / 4
maxsockets
maxsockets
4
if (hashsize < 512)			hashsize = 512;
hashsize < 512
hashsize
hashsize
512
hashsize = 512;
hashsize = 512
hashsize
hashsize
512
if (bootverbose)			printf("%s: %s auto tuned to %d\n", __func__,			    tcbhash_tuneable, hashsize);
bootverbose
bootverbose
printf("%s: %s auto tuned to %d\n", __func__,			    tcbhash_tuneable, hashsize);
printf("%s: %s auto tuned to %d\n", __func__,			    tcbhash_tuneable, hashsize)
printf
printf
"%s: %s auto tuned to %d\n"
__func__
__func__
tcbhash_tuneable
tcbhash_tuneable
hashsize
hashsize
if (!powerof2(hashsize)) {		int oldhashsize = hashsize;		hashsize = maketcp_hashsize(hashsize);		/* prevent absurdly low value */		if (hashsize < 16)			hashsize = 16;		printf("%s: WARNING: TCB hash size not a power of 2, "		    "clipped from %d to %d.\n", __func__, oldhashsize,		    hashsize);	}
!powerof2(hashsize)
powerof2(hashsize)
powerof2
powerof2
hashsize
hashsize
{		int oldhashsize = hashsize;		hashsize = maketcp_hashsize(hashsize);		/* prevent absurdly low value */		if (hashsize < 16)			hashsize = 16;		printf("%s: WARNING: TCB hash size not a power of 2, "		    "clipped from %d to %d.\n", __func__, oldhashsize,		    hashsize);	}
int oldhashsize = hashsize;
int oldhashsize = hashsize;
int
oldhashsize = hashsize
oldhashsize
= hashsize
hashsize
hashsize
hashsize = maketcp_hashsize(hashsize);
hashsize = maketcp_hashsize(hashsize)
hashsize
hashsize
maketcp_hashsize(hashsize)
maketcp_hashsize
maketcp_hashsize
hashsize
hashsize
if (hashsize < 16)			hashsize = 16;
hashsize < 16
hashsize
hashsize
16
hashsize = 16;
hashsize = 16
hashsize
hashsize
16
printf("%s: WARNING: TCB hash size not a power of 2, "		    "clipped from %d to %d.\n", __func__, oldhashsize,		    hashsize);
printf("%s: WARNING: TCB hash size not a power of 2, "		    "clipped from %d to %d.\n", __func__, oldhashsize,		    hashsize)
printf
printf
"%s: WARNING: TCB hash size not a power of 2, "		    "clipped from %d to %d.\n"
__func__
__func__
oldhashsize
oldhashsize
hashsize
hashsize
in_pcbinfo_init(&V_tcbinfo, "tcp", &V_tcb, hashsize, hashsize,	    "tcp_inpcb", tcp_inpcb_init, NULL, UMA_ZONE_NOFREE,	    IPI_HASHFIELDS_4TUPLE);
in_pcbinfo_init(&V_tcbinfo, "tcp", &V_tcb, hashsize, hashsize,	    "tcp_inpcb", tcp_inpcb_init, NULL, UMA_ZONE_NOFREE,	    IPI_HASHFIELDS_4TUPLE)
in_pcbinfo_init
in_pcbinfo_init
&V_tcbinfo
V_tcbinfo
V_tcbinfo
"tcp"
&V_tcb
V_tcb
V_tcb
hashsize
hashsize
hashsize
hashsize
"tcp_inpcb"
tcp_inpcb_init
tcp_inpcb_init
NULL
NULL
UMA_ZONE_NOFREE
UMA_ZONE_NOFREE
IPI_HASHFIELDS_4TUPLE
IPI_HASHFIELDS_4TUPLE
V_tcpcb_zone = uma_zcreate("tcpcb", sizeof(struct tcpcb_mem),	    NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, UMA_ZONE_NOFREE);
V_tcpcb_zone = uma_zcreate("tcpcb", sizeof(struct tcpcb_mem),	    NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, UMA_ZONE_NOFREE)
V_tcpcb_zone
V_tcpcb_zone
uma_zcreate("tcpcb", sizeof(struct tcpcb_mem),	    NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, UMA_ZONE_NOFREE)
uma_zcreate
uma_zcreate
"tcpcb"
sizeof(struct tcpcb_mem)
struct tcpcb_mem
struct tcpcb_mem
tcpcb_mem

NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
UMA_ALIGN_PTR
UMA_ALIGN_PTR
UMA_ZONE_NOFREE
UMA_ZONE_NOFREE
uma_zone_set_max(V_tcpcb_zone, maxsockets);
uma_zone_set_max(V_tcpcb_zone, maxsockets)
uma_zone_set_max
uma_zone_set_max
V_tcpcb_zone
V_tcpcb_zone
maxsockets
maxsockets
uma_zone_set_warning(V_tcpcb_zone, "kern.ipc.maxsockets limit reached");
uma_zone_set_warning(V_tcpcb_zone, "kern.ipc.maxsockets limit reached")
uma_zone_set_warning
uma_zone_set_warning
V_tcpcb_zone
V_tcpcb_zone
"kern.ipc.maxsockets limit reached"
tcp_tw_init();
tcp_tw_init()
tcp_tw_init
tcp_tw_init
syncache_init();
syncache_init()
syncache_init
syncache_init
tcp_hc_init();
tcp_hc_init()
tcp_hc_init
tcp_hc_init
tcp_reass_init();
tcp_reass_init()
tcp_reass_init
tcp_reass_init
TUNABLE_INT_FETCH("net.inet.tcp.sack.enable", &V_tcp_do_sack);
TUNABLE_INT_FETCH("net.inet.tcp.sack.enable", &V_tcp_do_sack)
TUNABLE_INT_FETCH
TUNABLE_INT_FETCH
"net.inet.tcp.sack.enable"
&V_tcp_do_sack
V_tcp_do_sack
V_tcp_do_sack
V_sack_hole_zone = uma_zcreate("sackhole", sizeof(struct sackhole),	    NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, UMA_ZONE_NOFREE);
V_sack_hole_zone = uma_zcreate("sackhole", sizeof(struct sackhole),	    NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, UMA_ZONE_NOFREE)
V_sack_hole_zone
V_sack_hole_zone
uma_zcreate("sackhole", sizeof(struct sackhole),	    NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, UMA_ZONE_NOFREE)
uma_zcreate
uma_zcreate
"sackhole"
sizeof(struct sackhole)
struct sackhole
struct sackhole
sackhole

NULL
NULL
NULL
NULL
NULL
NULL
NULL
NULL
UMA_ALIGN_PTR
UMA_ALIGN_PTR
UMA_ZONE_NOFREE
UMA_ZONE_NOFREE
if (!IS_DEFAULT_VNET(curvnet))		return;
!IS_DEFAULT_VNET(curvnet)
IS_DEFAULT_VNET(curvnet)
IS_DEFAULT_VNET
IS_DEFAULT_VNET
curvnet
curvnet
return;
tcp_delacktime = TCPTV_DELACK;
tcp_delacktime = TCPTV_DELACK
tcp_delacktime
tcp_delacktime
TCPTV_DELACK
TCPTV_DELACK
tcp_keepinit = TCPTV_KEEP_INIT;
tcp_keepinit = TCPTV_KEEP_INIT
tcp_keepinit
tcp_keepinit
TCPTV_KEEP_INIT
TCPTV_KEEP_INIT
tcp_keepidle = TCPTV_KEEP_IDLE;
tcp_keepidle = TCPTV_KEEP_IDLE
tcp_keepidle
tcp_keepidle
TCPTV_KEEP_IDLE
TCPTV_KEEP_IDLE
tcp_keepintvl = TCPTV_KEEPINTVL;
tcp_keepintvl = TCPTV_KEEPINTVL
tcp_keepintvl
tcp_keepintvl
TCPTV_KEEPINTVL
TCPTV_KEEPINTVL
tcp_maxpersistidle = TCPTV_KEEP_IDLE;
tcp_maxpersistidle = TCPTV_KEEP_IDLE
tcp_maxpersistidle
tcp_maxpersistidle
TCPTV_KEEP_IDLE
TCPTV_KEEP_IDLE
tcp_msl = TCPTV_MSL;
tcp_msl = TCPTV_MSL
tcp_msl
tcp_msl
TCPTV_MSL
TCPTV_MSL
tcp_rexmit_min = TCPTV_MIN;
tcp_rexmit_min = TCPTV_MIN
tcp_rexmit_min
tcp_rexmit_min
TCPTV_MIN
TCPTV_MIN
if (tcp_rexmit_min < 1)		tcp_rexmit_min = 1;
tcp_rexmit_min < 1
tcp_rexmit_min
tcp_rexmit_min
1
tcp_rexmit_min = 1;
tcp_rexmit_min = 1
tcp_rexmit_min
tcp_rexmit_min
1
tcp_rexmit_slop = TCPTV_CPU_VAR;
tcp_rexmit_slop = TCPTV_CPU_VAR
tcp_rexmit_slop
tcp_rexmit_slop
TCPTV_CPU_VAR
TCPTV_CPU_VAR
tcp_finwait2_timeout = TCPTV_FINWAIT2_TIMEOUT;
tcp_finwait2_timeout = TCPTV_FINWAIT2_TIMEOUT
tcp_finwait2_timeout
tcp_finwait2_timeout
TCPTV_FINWAIT2_TIMEOUT
TCPTV_FINWAIT2_TIMEOUT
tcp_tcbhashsize = hashsize;
tcp_tcbhashsize = hashsize
tcp_tcbhashsize
tcp_tcbhashsize
hashsize
hashsize
TUNABLE_INT_FETCH("net.inet.tcp.soreceive_stream", &tcp_soreceive_stream);
TUNABLE_INT_FETCH("net.inet.tcp.soreceive_stream", &tcp_soreceive_stream)
TUNABLE_INT_FETCH
TUNABLE_INT_FETCH
"net.inet.tcp.soreceive_stream"
&tcp_soreceive_stream
tcp_soreceive_stream
tcp_soreceive_stream
if (tcp_soreceive_stream) {#ifdef INET		tcp_usrreqs.pru_soreceive = soreceive_stream;#endif#ifdef INET6		tcp6_usrreqs.pru_soreceive = soreceive_stream;#endif /* INET6 */	}
tcp_soreceive_stream
tcp_soreceive_stream
{#ifdef INET		tcp_usrreqs.pru_soreceive = soreceive_stream;#endif#ifdef INET6		tcp6_usrreqs.pru_soreceive = soreceive_stream;#endif /* INET6 */	}
if (max_protohdr < TCP_MINPROTOHDR)		max_protohdr = TCP_MINPROTOHDR;
max_protohdr < TCP_MINPROTOHDR
max_protohdr
max_protohdr
TCP_MINPROTOHDR
TCP_MINPROTOHDR
TCP_MINPROTOHDR
TCP_MINPROTOHDR
TCP_MINPROTOHDR
TCP_MINPROTOHDR
max_protohdr = TCP_MINPROTOHDR;
max_protohdr = TCP_MINPROTOHDR
max_protohdr
max_protohdr
TCP_MINPROTOHDR
TCP_MINPROTOHDR
TCP_MINPROTOHDR
TCP_MINPROTOHDR
TCP_MINPROTOHDR
TCP_MINPROTOHDR
if (max_linkhdr + TCP_MINPROTOHDR > MHLEN)		panic("tcp_init");
max_linkhdr + TCP_MINPROTOHDR > MHLEN
max_linkhdr + TCP_MINPROTOHDR
max_linkhdr
max_linkhdr
TCP_MINPROTOHDR
TCP_MINPROTOHDR
TCP_MINPROTOHDR
TCP_MINPROTOHDR
TCP_MINPROTOHDR
TCP_MINPROTOHDR
MHLEN
MHLEN
panic("tcp_init");
panic("tcp_init")
panic
panic
"tcp_init"
ISN_LOCK_INIT();
ISN_LOCK_INIT()
ISN_LOCK_INIT
ISN_LOCK_INIT
EVENTHANDLER_REGISTER(shutdown_pre_sync, tcp_fini, NULL,		SHUTDOWN_PRI_DEFAULT);
EVENTHANDLER_REGISTER(shutdown_pre_sync, tcp_fini, NULL,		SHUTDOWN_PRI_DEFAULT)
EVENTHANDLER_REGISTER
EVENTHANDLER_REGISTER
shutdown_pre_sync
shutdown_pre_sync
tcp_fini
tcp_fini
NULL
NULL
SHUTDOWN_PRI_DEFAULT
SHUTDOWN_PRI_DEFAULT
EVENTHANDLER_REGISTER(maxsockets_change, tcp_zone_change, NULL,		EVENTHANDLER_PRI_ANY);
EVENTHANDLER_REGISTER(maxsockets_change, tcp_zone_change, NULL,		EVENTHANDLER_PRI_ANY)
EVENTHANDLER_REGISTER
EVENTHANDLER_REGISTER
maxsockets_change
maxsockets_change
tcp_zone_change
tcp_zone_change
NULL
NULL
EVENTHANDLER_PRI_ANY
EVENTHANDLER_PRI_ANY
-----joern-----
(116,120,0)
(65,141,0)
(128,110,0)
(169,211,0)
(201,87,0)
(77,150,0)
(185,96,0)
(90,74,0)
(41,102,0)
(204,214,0)
(170,52,0)
(150,105,0)
(118,136,0)
(78,52,0)
(32,105,0)
(136,203,0)
(175,168,0)
(226,105,0)
(181,105,0)
(177,103,0)
(188,211,0)
(125,202,0)
(57,128,0)
(188,102,0)
(210,46,0)
(134,137,0)
(80,87,0)
(31,120,0)
(224,102,0)
(41,126,0)
(104,110,0)
(67,121,0)
(103,43,0)
(217,88,0)
(222,71,0)
(170,106,0)
(194,105,0)
(61,179,0)
(196,105,0)
(10,13,0)
(14,211,0)
(85,52,0)
(16,211,0)
(138,96,0)
(158,219,0)
(133,162,0)
(156,3,0)
(86,52,0)
(148,158,0)
(47,136,0)
(126,41,0)
(27,136,0)
(83,70,0)
(12,116,0)
(213,169,0)
(195,136,0)
(102,41,0)
(176,146,0)
(100,204,0)
(142,102,0)
(214,204,0)
(199,66,0)
(71,128,0)
(163,128,0)
(219,158,0)
(43,102,0)
(203,98,0)
(19,45,0)
(50,204,0)
(221,97,0)
(81,212,0)
(223,181,0)
(166,105,0)
(66,102,0)
(188,17,0)
(22,185,0)
(204,108,0)
(189,66,0)
(145,96,0)
(187,105,0)
(184,166,0)
(225,224,0)
(45,145,0)
(169,150,0)
(103,17,0)
(151,153,0)
(48,4,0)
(62,105,0)
(106,170,0)
(229,62,0)
(0,136,0)
(131,44,0)
(129,126,0)
(21,191,0)
(145,45,0)
(180,46,0)
(72,150,0)
(178,204,0)
(142,105,0)
(44,105,0)
(26,191,0)
(204,211,0)
(167,204,0)
(204,105,0)
(144,150,0)
(208,153,0)
(168,103,0)
(68,128,0)
(121,162,0)
(128,71,0)
(37,169,0)
(127,88,0)
(64,181,0)
(144,121,0)
(28,204,0)
(165,105,0)
(142,103,0)
(218,44,0)
(6,52,0)
(160,136,0)
(49,144,0)
(111,204,0)
(69,126,0)
(190,17,0)
(169,213,0)
(39,223,0)
(9,105,0)
(36,105,0)
(186,68,0)
(54,108,0)
(142,150,0)
(191,105,0)
(204,167,0)
(53,105,0)
(205,141,0)
(59,168,0)
(66,211,0)
(231,75,0)
(79,141,0)
(197,105,0)
(204,103,0)
(43,103,0)
(98,203,0)
(109,198,0)
(209,204,0)
(4,105,0)
(206,66,0)
(212,150,0)
(152,224,0)
(122,4,0)
(52,200,0)
(29,110,0)
(193,198,0)
(204,102,0)
(5,162,0)
(82,137,0)
(13,96,0)
(169,102,0)
(216,204,0)
(162,105,0)
(135,116,0)
(75,93,0)
(153,208,0)
(124,142,0)
(33,166,0)
(121,105,0)
(38,1,0)
(71,222,0)
(30,1,0)
(168,188,0)
(200,52,0)
(182,226,0)
(141,105,0)
(128,68,0)
(140,200,0)
(200,105,0)
(73,3,0)
(95,220,0)
(181,223,0)
(74,105,0)
(120,116,0)
(168,17,0)
(112,105,0)
(143,220,0)
(107,221,0)
(102,1,0)
(183,62,0)
(142,108,0)
(97,171,0)
(76,204,0)
(172,167,0)
(113,45,0)
(11,222,0)
(154,66,0)
(58,18,0)
(136,118,0)
(132,188,0)
(56,219,0)
(93,171,0)
(158,105,0)
(8,105,0)
(174,222,0)
(155,118,0)
(130,179,0)
(119,142,0)
(230,168,0)
(164,105,0)
(202,105,0)
(43,211,0)
(91,93,0)
(114,105,0)
(24,74,0)
(192,136,0)
(66,162,0)
(2,52,0)
(204,150,0)
(96,13,0)
(157,105,0)
(94,13,0)
(220,105,0)
(147,97,0)
(96,145,0)
(63,20,0)
(99,141,0)
(115,136,0)
(15,17,0)
(52,170,0)
(203,136,0)
(123,108,0)
(188,150,0)
(117,20,0)
(43,150,0)
(7,43,0)
(89,102,0)
(149,105,0)
(110,128,0)
(46,105,0)
(84,228,0)
(51,52,0)
(92,52,0)
(173,96,0)
(207,105,0)
(118,105,0)
(34,221,0)
(88,105,0)
(159,214,0)
(137,105,0)
(121,144,0)
(55,188,0)
(142,211,0)
(96,185,0)
(35,202,0)
(227,168,0)
(25,146,0)
(23,70,0)
(215,88,0)
(42,226,0)
(60,212,0)
(87,103,0)
(139,75,0)
(168,108,0)
(161,88,0)
(142,211,1)
(100,111,1)
(42,74,1)
(193,109,1)
(51,170,1)
(160,203,1)
(121,162,1)
(218,208,1)
(180,191,1)
(210,180,1)
(19,113,1)
(145,45,1)
(222,174,1)
(191,26,1)
(46,210,1)
(9,8,1)
(75,139,1)
(204,76,1)
(14,16,1)
(202,35,1)
(77,68,1)
(177,188,1)
(223,39,1)
(55,213,1)
(124,119,1)
(108,54,1)
(169,102,1)
(130,166,1)
(182,42,1)
(104,29,1)
(219,56,1)
(87,80,1)
(95,143,1)
(40,211,1)
(89,212,1)
(149,4,1)
(101,181,1)
(81,121,1)
(92,6,1)
(204,102,1)
(175,59,1)
(70,23,1)
(125,220,1)
(150,72,1)
(169,211,1)
(79,205,1)
(68,186,1)
(204,108,1)
(22,96,1)
(201,103,1)
(179,61,1)
(225,102,1)
(143,179,1)
(209,178,1)
(138,173,1)
(41,126,1)
(188,132,1)
(6,51,1)
(227,230,1)
(57,198,1)
(168,103,1)
(76,50,1)
(228,84,1)
(48,122,1)
(129,89,1)
(128,71,1)
(111,214,1)
(126,69,1)
(96,13,1)
(142,150,1)
(155,158,1)
(97,147,1)
(134,82,1)
(115,47,1)
(204,150,1)
(50,216,1)
(43,150,1)
(117,70,1)
(172,213,1)
(45,19,1)
(60,81,1)
(203,0,1)
(141,99,1)
(94,145,1)
(64,142,1)
(229,183,1)
(86,85,1)
(139,231,1)
(153,151,1)
(168,108,1)
(176,25,1)
(192,27,1)
(205,88,1)
(116,12,1)
(27,160,1)
(185,96,1)
(85,2,1)
(170,78,1)
(66,162,1)
(110,104,1)
(26,21,1)
(122,137,1)
(80,201,1)
(67,150,1)
(91,75,1)
(39,64,1)
(119,202,1)
(167,172,1)
(90,24,1)
(16,224,1)
(66,102,1)
(123,87,1)
(203,98,1)
(169,37,1)
(146,176,1)
(204,103,1)
(188,150,1)
(118,136,1)
(120,116,1)
(120,31,1)
(166,184,1)
(58,141,1)
(169,150,1)
(44,131,1)
(154,189,1)
(68,128,1)
(136,203,1)
(143,146,1)
(4,48,1)
(10,94,1)
(158,219,1)
(159,28,1)
(173,162,1)
(142,108,1)
(144,49,1)
(214,159,1)
(148,207,1)
(58,18,1)
(189,40,1)
(137,134,1)
(220,95,1)
(87,103,1)
(217,161,1)
(77,3,1)
(183,46,1)
(168,175,1)
(37,40,1)
(188,102,1)
(231,97,1)
(71,222,1)
(215,127,1)
(52,170,1)
(172,168,1)
(135,20,1)
(230,108,1)
(83,93,1)
(47,195,1)
(40,224,1)
(20,63,1)
(181,223,1)
(2,92,1)
(82,200,1)
(161,120,1)
(152,225,1)
(54,123,1)
(34,101,1)
(109,185,1)
(221,107,1)
(107,34,1)
(142,124,1)
(56,148,1)
(113,138,1)
(212,150,1)
(59,227,1)
(74,90,1)
(96,145,1)
(63,117,1)
(170,106,1)
(5,133,1)
(230,87,1)
(24,62,1)
(35,125,1)
(18,208,1)
(12,135,1)
(131,218,1)
(72,77,1)
(204,167,1)
(135,70,1)
(11,163,1)
(195,192,1)
(93,91,1)
(31,116,1)
(211,14,1)
(224,152,1)
(198,193,1)
(128,110,1)
(224,102,1)
(23,83,1)
(142,103,1)
(8,149,1)
(188,211,1)
(84,120,1)
(208,153,1)
(3,73,1)
(33,226,1)
(147,221,1)
(37,212,1)
(127,217,1)
(226,182,1)
(88,215,1)
(78,140,1)
(151,118,1)
(69,129,1)
(73,156,1)
(186,128,1)
(103,43,1)
(200,52,1)
(21,44,1)
(28,167,1)
(61,130,1)
(62,229,1)
(156,68,1)
(52,86,1)
(13,10,1)
(7,177,1)
(37,66,1)
(163,57,1)
(43,211,1)
(213,169,1)
(0,155,1)
(65,79,1)
(83,101,1)
(66,199,1)
(185,22,1)
(57,185,1)
(142,102,1)
(66,211,1)
(99,65,1)
(43,7,1)
(212,60,1)
(43,102,1)
(29,71,1)
(102,41,1)
(132,55,1)
(168,188,1)
(178,100,1)
(204,211,1)
(207,9,1)
(206,154,1)
(216,209,1)
(204,214,1)
(184,33,1)
(199,206,1)
(136,115,1)
(121,144,1)
(25,179,1)
(49,67,1)
(140,204,1)
(161,228,1)
(144,150,1)
(174,11,1)
(162,5,1)
(199,40,2)
(188,150,2)
(59,213,2)
(204,214,2)
(142,103,2)
(118,136,2)
(12,208,2)
(217,208,2)
(102,41,2)
(14,224,2)
(183,208,2)
(145,45,2)
(210,208,2)
(179,208,2)
(176,179,2)
(31,208,2)
(16,224,2)
(152,212,2)
(91,101,2)
(25,179,2)
(201,213,2)
(223,208,2)
(103,43,2)
(121,162,2)
(117,70,2)
(168,103,2)
(42,208,2)
(142,108,2)
(128,110,2)
(208,153,2)
(103,213,2)
(156,68,2)
(102,212,2)
(58,18,2)
(228,120,2)
(71,222,2)
(123,87,2)
(95,208,2)
(62,208,2)
(124,208,2)
(188,102,2)
(154,40,2)
(203,98,2)
(204,167,2)
(212,150,2)
(83,208,2)
(213,169,2)
(168,188,2)
(55,213,2)
(126,212,2)
(220,208,2)
(119,208,2)
(97,101,2)
(23,208,2)
(218,208,2)
(66,162,2)
(39,208,2)
(74,208,2)
(200,52,2)
(84,120,2)
(230,213,2)
(224,102,2)
(180,208,2)
(52,170,2)
(184,208,2)
(43,211,2)
(136,203,2)
(69,212,2)
(70,208,2)
(169,102,2)
(132,213,2)
(224,212,2)
(35,208,2)
(193,185,2)
(3,68,2)
(166,208,2)
(204,150,2)
(21,208,2)
(26,208,2)
(125,208,2)
(99,208,2)
(68,128,2)
(75,101,2)
(204,108,2)
(18,208,2)
(66,102,2)
(205,208,2)
(169,150,2)
(158,219,2)
(43,102,2)
(93,101,2)
(96,13,2)
(211,224,2)
(204,211,2)
(142,211,2)
(116,208,2)
(227,213,2)
(107,101,2)
(46,208,2)
(188,213,2)
(41,126,2)
(90,208,2)
(135,208,2)
(189,40,2)
(204,103,2)
(215,208,2)
(101,208,2)
(34,101,2)
(181,208,2)
(206,40,2)
(128,71,2)
(139,101,2)
(147,101,2)
(80,213,2)
(229,208,2)
(108,87,2)
(202,208,2)
(161,208,2)
(146,179,2)
(66,40,2)
(88,208,2)
(64,208,2)
(120,208,2)
(168,213,2)
(89,212,2)
(40,212,2)
(141,208,2)
(144,150,2)
(20,70,2)
(73,68,2)
(182,208,2)
(109,185,2)
(181,223,2)
(198,185,2)
(170,106,2)
(96,145,2)
(131,208,2)
(221,101,2)
(177,213,2)
(226,208,2)
(142,102,2)
(33,208,2)
(142,150,2)
(63,70,2)
(24,208,2)
(121,144,2)
(175,213,2)
(225,212,2)
(43,213,2)
(66,211,2)
(185,96,2)
(120,116,2)
(142,208,2)
(231,101,2)
(79,208,2)
(87,213,2)
(65,208,2)
(43,150,2)
(127,208,2)
(41,212,2)
(7,213,2)
(168,108,2)
(188,211,2)
(87,103,2)
(61,208,2)
(129,212,2)
(54,87,2)
(130,208,2)
(143,208,2)
(169,211,2)
(44,208,2)
(204,102,2)
(191,208,2)
-----------------------------------
(0,"sackhole")
(1,)
(2,NULL)
(3,printf("%s: WARNING: unable to register helper hook\\n", __func__)
(4,uma_zone_set_warning(V_tcpcb_zone, "kern.ipc.maxsockets limit reached")
(5,"net.inet.tcp.tcbhashsize")
(6,NULL)
(7,hashsize)
(8,syncache_init()
(9,tcp_hc_init()
(10,HHOOK_HEADISINVNET)
(11,V_tcp_hhh)
(12,TCP_MINPROTOHDR)
(13,HHOOK_NOWAIT|HHOOK_HEADISINVNET)
(14,512)
(15,if (hashsize < 16)
(16,hashsize)
(17,)
(18,return;)
(19,HHOOK_TCP_EST_IN)
(20,max_protohdr = TCP_MINPROTOHDR)
(21,tcp_keepinit)
(22,0)
(23,TCP_MINPROTOHDR)
(24,tcp_maxpersistidle)
(25,tcp_rexmit_min)
(26,TCPTV_KEEP_INIT)
(27,NULL)
(28,"tcp")
(29,HHOOK_NOWAIT)
(30,if (bootverbose)
(31,MHLEN)
(32,if (hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_IN,\n\\n\\t    &V_tcp_hhh[HHOOK_TCP_EST_IN], HHOOK_NOWAIT|HHOOK_HEADISINVNET)
(33,tcp_rexmit_min)
(34,tcp_usrreqs)
(35,TCPTV_FINWAIT2_TIMEOUT)
(36,tcbhash_tuneable)
(37,hashsize)
(38,if (hashsize < 512)
(39,tcp_soreceive_stream)
(40,bootverbose)
(41,maketcp_hashsize(maxsockets / 4)
(42,tcp_msl)
(43,maketcp_hashsize(hashsize)
(44,tcp_delacktime = TCPTV_DELACK)
(45,V_tcp_hhh[HHOOK_TCP_EST_IN])
(46,tcp_keepidle = TCPTV_KEEP_IDLE)
(47,UMA_ALIGN_PTR)
(48,"kern.ipc.maxsockets limit reached")
(49,hashsize)
(50,UMA_ZONE_NOFREE)
(51,NULL)
(52,uma_zcreate("tcpcb", sizeof(struct tcpcb_mem)
(53,if (hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_OUT,\n\\n\\t    &V_tcp_hhh[HHOOK_TCP_EST_OUT], HHOOK_NOWAIT|HHOOK_HEADISINVNET)
(54,16)
(55,oldhashsize)
(56,V_tcp_do_sack)
(57,HHOOK_TYPE_TCP)
(58,RET)
(59,oldhashsize)
(60,0)
(61,1)
(62,tcp_keepintvl = TCPTV_KEEPINTVL)
(63,TCP_MINPROTOHDR)
(64,"net.inet.tcp.soreceive_stream")
(65,NULL)
(66,printf("%s: %s auto tuned to %d\\n", __func__,\n\\n\\t\\t\\t    tcbhash_tuneable, hashsize)
(67,tcbhash_tuneable)
(68,hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_OUT,\n\\n\\t    &V_tcp_hhh[HHOOK_TCP_EST_OUT], HHOOK_NOWAIT|HHOOK_HEADISINVNET)
(69,4)
(70,max_protohdr < TCP_MINPROTOHDR)
(71,&V_tcp_hhh[HHOOK_TCP_EST_OUT])
(72,TCBHASHSIZE)
(73,__func__)
(74,tcp_maxpersistidle = TCPTV_KEEP_IDLE)
(75,tcp6_usrreqs.pru_soreceive)
(76,IPI_HASHFIELDS_4TUPLE)
(77,hashsize)
(78,"tcpcb")
(79,tcp_zone_change)
(80,16)
(81,hashsize)
(82,V_tcpcb_zone)
(83,max_protohdr)
(84,"tcp_init")
(85,UMA_ALIGN_PTR)
(86,UMA_ZONE_NOFREE)
(87,hashsize < 16)
(88,EVENTHANDLER_REGISTER(shutdown_pre_sync, tcp_fini, NULL,\n\\n\\t\\tSHUTDOWN_PRI_DEFAULT)
(89,hashsize)
(90,TCPTV_KEEP_IDLE)
(91,soreceive_stream)
(92,NULL)
(93,tcp6_usrreqs.pru_soreceive = soreceive_stream)
(94,HHOOK_NOWAIT)
(95,TCPTV_CPU_VAR)
(96,hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_IN,\n\\n\\t    &V_tcp_hhh[HHOOK_TCP_EST_IN], HHOOK_NOWAIT|HHOOK_HEADISINVNET)
(97,tcp_usrreqs.pru_soreceive = soreceive_stream)
(98,struct sackhole)
(99,EVENTHANDLER_PRI_ANY)
(100,hashsize)
(101,tcp_soreceive_stream)
(102,hashsize = maketcp_hashsize(maxsockets / 4)
(103,hashsize = maketcp_hashsize(hashsize)
(104,HHOOK_HEADISINVNET)
(105,)
(106,struct tcpcb_mem)
(107,pru_soreceive)
(108,hashsize = 16)
(109,"%s: WARNING: unable to register helper hook\\n")
(110,HHOOK_NOWAIT|HHOOK_HEADISINVNET)
(111,hashsize)
(112,if (!IS_DEFAULT_VNET(curvnet)
(113,V_tcp_hhh)
(114,if (tcp_soreceive_stream)
(115,UMA_ZONE_NOFREE)
(116,max_linkhdr + TCP_MINPROTOHDR)
(117,max_protohdr)
(118,V_sack_hole_zone = uma_zcreate("sackhole", sizeof(struct sackhole)
(119,tcp_tcbhashsize)
(120,max_linkhdr + TCP_MINPROTOHDR > MHLEN)
(121,TUNABLE_INT_FETCH(tcbhash_tuneable, &hashsize)
(122,V_tcpcb_zone)
(123,hashsize)
(124,hashsize)
(125,tcp_finwait2_timeout)
(126,maxsockets / 4)
(127,NULL)
(128,hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_OUT,\n\\n\\t    &V_tcp_hhh[HHOOK_TCP_EST_OUT], HHOOK_NOWAIT|HHOOK_HEADISINVNET)
(129,maxsockets)
(130,tcp_rexmit_min)
(131,TCPTV_DELACK)
(132,hashsize)
(133,tcbhash_tuneable)
(134,maxsockets)
(135,max_linkhdr)
(136,uma_zcreate("sackhole", sizeof(struct sackhole)
(137,uma_zone_set_max(V_tcpcb_zone, maxsockets)
(138,HHOOK_TCP_EST_IN)
(139,pru_soreceive)
(140,V_tcpcb_zone)
(141,EVENTHANDLER_REGISTER(maxsockets_change, tcp_zone_change, NULL,\n\\n\\t\\tEVENTHANDLER_PRI_ANY)
(142,tcp_tcbhashsize = hashsize)
(143,tcp_rexmit_slop)
(144,&hashsize)
(145,&V_tcp_hhh[HHOOK_TCP_EST_IN])
(146,tcp_rexmit_min = 1)
(147,soreceive_stream)
(148,"net.inet.tcp.sack.enable")
(149,tcp_tw_init()
(150,hashsize = TCBHASHSIZE)
(151,curvnet)
(152,512)
(153,IS_DEFAULT_VNET(curvnet)
(154,__func__)
(155,V_sack_hole_zone)
(156,"%s: WARNING: unable to register helper hook\\n")
(157,hashsize)
(158,TUNABLE_INT_FETCH("net.inet.tcp.sack.enable", &V_tcp_do_sack)
(159,V_tcb)
(160,NULL)
(161,shutdown_pre_sync)
(162,tcbhash_tuneable = "net.inet.tcp.tcbhashsize")
(163,HHOOK_TCP_EST_OUT)
(164,if (!powerof2(hashsize)
(165,if (max_protohdr < TCP_MINPROTOHDR)
(166,tcp_rexmit_min = TCPTV_MIN)
(167,&V_tcbinfo)
(168,printf("%s: WARNING: TCB hash size not a power of 2, "\n\\n\\t\\t    "clipped from %d to %d.\\n", __func__, oldhashsize,\n\\n\\t\\t    hashsize)
(169,powerof2(hashsize)
(170,sizeof(struct tcpcb_mem)
(171,)
(172,V_tcbinfo)
(173,HHOOK_TYPE_TCP)
(174,HHOOK_TCP_EST_OUT)
(175,hashsize)
(176,1)
(177,hashsize)
(178,"tcp_inpcb")
(179,tcp_rexmit_min < 1)
(180,tcp_keepidle)
(181,TUNABLE_INT_FETCH("net.inet.tcp.soreceive_stream", &tcp_soreceive_stream)
(182,TCPTV_MSL)
(183,tcp_keepintvl)
(184,TCPTV_MIN)
(185,hhook_head_register(HHOOK_TYPE_TCP, HHOOK_TCP_EST_IN,\n\\n\\t    &V_tcp_hhh[HHOOK_TCP_EST_IN], HHOOK_NOWAIT|HHOOK_HEADISINVNET)
(186,0)
(187,if (max_linkhdr + TCP_MINPROTOHDR > MHLEN)
(188,oldhashsize = hashsize)
(189,"%s: %s auto tuned to %d\\n")
(190,oldhashsize)
(191,tcp_keepinit = TCPTV_KEEP_INIT)
(192,NULL)
(193,__func__)
(194,if (tcp_rexmit_min < 1)
(195,NULL)
(196,if (hashsize == 0)
(197,ISN_LOCK_INIT)
(198,printf("%s: WARNING: unable to register helper hook\\n", __func__)
(199,hashsize)
(200,V_tcpcb_zone = uma_zcreate("tcpcb", sizeof(struct tcpcb_mem)
(201,hashsize)
(202,tcp_finwait2_timeout = TCPTV_FINWAIT2_TIMEOUT)
(203,sizeof(struct sackhole)
(204,in_pcbinfo_init(&V_tcbinfo, "tcp", &V_tcb, hashsize, hashsize,\n\\n\\t    "tcp_inpcb", tcp_inpcb_init, NULL, UMA_ZONE_NOFREE,\n\\n\\t    IPI_HASHFIELDS_4TUPLE)
(205,maxsockets_change)
(206,tcbhash_tuneable)
(207,tcp_reass_init()
(208,!IS_DEFAULT_VNET(curvnet)
(209,tcp_inpcb_init)
(210,TCPTV_KEEP_IDLE)
(211,hashsize = 512)
(212,hashsize == 0)
(213,!powerof2(hashsize)
(214,&V_tcb)
(215,SHUTDOWN_PRI_DEFAULT)
(216,NULL)
(217,tcp_fini)
(218,tcp_delacktime)
(219,&V_tcp_do_sack)
(220,tcp_rexmit_slop = TCPTV_CPU_VAR)
(221,tcp_usrreqs.pru_soreceive)
(222,V_tcp_hhh[HHOOK_TCP_EST_OUT])
(223,&tcp_soreceive_stream)
(224,hashsize < 512)
(225,hashsize)
(226,tcp_msl = TCPTV_MSL)
(227,__func__)
(228,panic("tcp_init")
(229,TCPTV_KEEPINTVL)
(230,"%s: WARNING: TCB hash size not a power of 2, "\n\\n\\t\\t    "clipped from %d to %d.\\n")
(231,tcp6_usrreqs)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^