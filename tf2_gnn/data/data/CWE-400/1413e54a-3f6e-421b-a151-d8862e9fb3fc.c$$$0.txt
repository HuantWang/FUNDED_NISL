-----label-----
1
-----code-----
void
winimg_paint(void)
{
  imglist *img;
  imglist *prev = NULL;

  /* free disk space if number of tempfile exceeds TEMPFILE_MAX_NUM */
  while (tempfile_num > TEMPFILE_MAX_NUM && term.imgs.first) {
    img = term.imgs.first;
    term.imgs.first = term.imgs.first->next;
    winimg_destroy(img);
  }

  HDC dc = GetDC(wnd);

  RECT rc;
  GetClientRect(wnd, &rc);
  IntersectClipRect(dc, rc.left + PADDING, rc.top + PADDING,
                    rc.left + PADDING + term.cols * cell_width,
                    rc.top + PADDING + term.rows * cell_height);
  for (img = term.imgs.first; img;) {
    // if the image is out of scrollback, collect it
    if (img->top + img->height - term.virtuallines < - term.sblines) {
      if (img == term.imgs.first)
        term.imgs.first = img->next;
      if (img == term.imgs.last)
        term.imgs.last = prev;
      if (prev)
        prev->next = img->next;
      prev = img;
      img = img->next;
      winimg_destroy(prev);
    } else {
      // if the image is scrolled out, serialize it into a temp file.
      int left = img->left;
      int top = img->top - term.virtuallines - term.disptop;
      if (top + img->height < 0 || top > term.rows) {
        winimg_hibernate(img);
      } else {
        // create DC handle if it is not initialized, or resume from hibernate
        winimg_lazyinit(img);
        for (int y = max(0, top); y < min(top + img->height, term.rows); ++y) {
          int wide_factor = (term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM ? 1: 2;
          for (int x = left; x < min(left + img->width, term.cols); ++x) {
            termchar *dchar = &term.displines[y]->chars[x];

            // if sixel image is overwirtten by characters,
            // exclude the area from the clipping rect.
            bool update_flag = false;
            if (dchar->chr != SIXELCH)
              update_flag = true;
            if (dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED))
              update_flag = true;
            if (term.selected && !update_flag) {
              pos scrpos = {y + term.disptop, x, false};
              update_flag = term.sel_rect
                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)
                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end);
            }
            if (update_flag)
              ExcludeClipRect(dc,
                              x * wide_factor * cell_width + PADDING,
                              y * cell_height + PADDING,
                              (x + 1) * wide_factor * cell_width + PADDING,
                              (y + 1) * cell_height + PADDING);
          }
        }
        StretchBlt(dc, left * cell_width + PADDING, top * cell_height + PADDING,
                   img->width * cell_width, img->height * cell_height, img->hdc,
                   0, 0, img->pixelwidth, img->pixelheight, SRCCOPY);
      }
      prev = img;
      img = img->next;
    }
  }

  ReleaseDC(wnd, dc);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
9,10
9,11
9,12
9,13
9,14
9,15
9,16
9,17
9,18
10,11
11,12
11,13
12,13
14,15
14,16
17,18
18,19
18,20
19,20
21,22
21,23
21,24
24,25
25,26
27,28
27,29
28,29
28,30
29,30
29,31
30,31
32,33
34,35
34,36
35,36
35,37
36,37
40,41
40,42
40,43
41,42
42,43
42,44
43,44
45,46
45,47
46,47
46,48
47,48
51,52
52,53
52,54
53,54
53,55
54,55
54,56
55,56
59,60
59,61
60,61
60,62
61,62
61,63
62,63
67,68
68,69
68,70
69,70
71,72
73,74
74,75
74,76
75,76
77,78
77,79
79,80
80,81
80,82
81,82
83,84
85,86
86,87
86,88
87,88
89,90
91,92
92,93
92,94
92,95
93,94
95,96
97,98
98,99
100,101
101,102
101,103
101,104
101,105
101,106
101,107
102,103
104,105
106,107
106,108
107,108
107,109
108,109
111,112
113,114
113,115
114,115
114,116
115,116
118,119
120,121
120,122
121,122
121,123
122,123
122,124
123,124
126,127
128,129
128,130
129,130
129,131
130,131
133,134
135,136
135,137
136,137
136,138
137,138
137,139
138,139
141,142
143,144
143,145
144,145
144,146
145,146
148,149
150,151
150,152
150,153
151,152
152,153
152,154
153,154
155,156
155,157
156,157
156,158
157,158
161,162
163,164
164,165
164,166
164,167
165,166
165,167
166,167
166,168
167,168
167,169
168,169
168,170
169,170
172,173
172,174
173,174
176,177
176,178
177,178
180,181
181,182
181,183
182,183
185,186
185,187
185,188
185,189
185,190
185,191
186,187
186,188
187,188
187,189
188,189
190,191
190,192
191,192
191,193
192,193
196,197
197,198
197,199
198,199
198,200
199,200
199,201
200,201
204,205
204,206
205,206
208,209
208,210
209,210
209,211
210,211
212,213
212,214
213,214
213,215
214,215
218,219
219,220
219,221
220,221
220,222
221,222
221,223
222,223
226,227
228,229
228,230
229,230
231,232
232,233
232,234
233,234
233,235
234,235
237,238
237,239
238,239
241,242
242,243
242,244
243,244
245,246
247,248
248,249
248,250
249,250
251,252
251,253
252,253
255,256
256,257
256,258
257,258
259,260
261,262
261,263
261,264
261,265
261,266
262,263
263,264
263,265
265,266
265,267
267,268
268,269
268,270
269,270
272,273
273,274
273,275
275,276
275,277
277,278
278,279
278,280
279,280
279,281
280,281
280,282
281,282
284,285
284,286
285,286
288,289
288,290
289,290
292,293
292,294
292,295
293,294
293,295
294,295
294,296
295,296
295,297
296,297
298,299
298,300
299,300
303,304
303,305
304,305
306,307
306,308
307,308
310,311
311,312
312,313
312,314
313,314
315,316
317,318
317,319
317,320
318,319
319,320
319,321
320,321
322,323
324,325
324,326
324,327
324,328
325,326
326,327
326,328
328,329
328,330
330,331
331,332
331,333
331,334
332,333
335,336
337,338
337,339
338,339
340,341
340,342
340,343
341,342
343,344
343,345
344,345
346,347
346,348
347,348
350,351
350,352
351,352
354,355
355,356
357,358
357,359
358,359
359,360
359,361
361,362
361,363
363,364
364,365
364,366
364,367
365,366
365,367
366,367
367,368
367,369
368,369
368,370
369,370
369,371
370,371
370,372
371,372
374,375
377,378
379,380
383,384
383,385
383,386
383,387
384,385
385,386
385,387
387,388
387,389
389,390
390,391
392,393
392,394
393,394
395,396
395,397
395,398
396,397
398,399
398,400
399,400
401,402
401,403
402,403
405,406
405,407
406,407
409,410
410,411
412,413
412,414
412,415
412,416
412,417
412,418
413,414
414,415
414,416
415,416
417,418
417,419
417,420
420,421
421,422
422,423
422,424
423,424
423,425
424,425
424,426
425,426
425,427
426,427
429,430
432,433
434,435
435,436
435,437
437,438
437,439
439,440
441,442
441,443
442,443
442,444
443,444
443,445
444,445
447,448
449,450
450,451
450,452
451,452
454,455
454,456
455,456
455,457
456,457
456,458
457,458
457,459
458,459
462,463
463,464
463,465
464,465
464,466
465,466
465,467
466,467
468,469
470,471
472,473
474,475
475,476
475,477
476,477
479,480
479,481
480,481
480,482
481,482
481,483
482,483
485,486
486,487
488,489
488,490
489,490
490,491
490,492
491,492
493,494
493,495
495,496
496,497
496,498
496,499
497,498
497,499
498,499
500,501
500,502
501,502
504,505
507,508
508,509
508,510
509,510
511,512
511,513
511,514
512,513
512,514
513,514
516,517
516,518
517,518
517,519
517,520
518,519
520,521
520,522
521,522
524,525
526,527
526,528
526,529
527,528
529,530
531,532
531,533
532,533
535,536
535,537
536,537
536,538
536,539
537,538
539,540
539,541
540,541
543,544
545,546
545,547
545,548
546,547
548,549
550,551
550,552
551,552
554,555
554,556
555,556
557,558
558,559
558,560
558,561
558,562
558,563
558,564
559,560
561,562
563,564
563,565
564,565
564,566
565,566
565,567
566,567
568,569
570,571
572,573
574,575
574,576
575,576
575,577
576,577
578,579
580,581
582,583
582,584
583,584
583,585
584,585
584,586
585,586
586,587
586,588
587,588
590,591
592,593
594,595
596,597
596,598
597,598
597,599
598,599
599,600
599,601
600,601
603,604
605,606
607,608
608,609
608,610
608,611
608,612
608,613
608,614
608,615
608,616
608,617
608,618
608,619
608,620
609,610
611,612
613,614
613,615
614,615
614,616
615,616
617,618
619,620
621,622
621,623
622,623
622,624
623,624
625,626
627,628
629,630
629,631
630,631
630,632
631,632
634,635
636,637
636,638
637,638
637,639
638,639
641,642
643,644
643,645
644,645
649,650
649,651
650,651
653,654
653,655
654,655
657,658
659,660
660,661
660,662
661,662
663,664
665,666
666,667
666,668
667,668
669,670
669,671
670,671
673,674
674,675
674,676
674,677
675,676
677,678
679,680
-----nextToken-----
2,4,6,8,13,15,16,20,22,23,26,31,33,37,38,39,44,48,49,50,56,57,58,63,64,65,66,70,72,76,78,82,84,88,90,94,96,99,103,105,109,110,112,116,117,119,124,125,127,131,132,134,139,140,142,146,147,149,154,158,159,160,162,170,171,174,175,178,179,183,184,189,193,194,195,201,202,203,206,207,211,215,216,217,223,224,225,227,230,235,236,239,240,244,246,250,253,254,258,260,264,266,270,271,274,276,282,283,286,287,290,291,297,300,301,302,305,308,309,314,316,321,323,327,329,333,334,336,339,342,345,348,349,352,353,356,360,362,372,373,375,376,378,380,381,382,386,388,391,394,397,400,403,404,407,408,411,416,418,419,427,428,430,431,433,436,438,440,445,446,448,452,453,459,460,461,467,469,471,473,477,478,483,484,487,492,494,499,502,503,505,506,510,514,515,519,522,523,525,528,530,533,534,538,541,542,544,547,549,552,553,556,560,562,567,569,571,573,577,579,581,588,589,591,593,595,601,602,604,606,610,612,616,618,620,624,626,628,632,633,635,639,640,642,645,646,647,648,651,652,655,656,658,662,664,668,671,672,676,678,680
-----computeFrom-----
28,29
28,30
29,30
29,31
42,43
42,44
52,53
52,54
106,107
106,108
113,114
113,115
120,121
120,122
121,122
121,123
128,129
128,130
135,136
135,137
136,137
136,138
143,144
143,145
152,153
152,154
165,166
165,167
166,167
166,168
167,168
167,169
187,188
187,189
197,198
197,199
209,210
209,211
219,220
219,221
232,233
232,234
242,243
242,244
248,249
248,250
278,279
278,280
279,280
279,281
293,294
293,295
294,295
294,296
295,296
295,297
303,304
303,305
337,338
337,339
343,344
343,345
365,366
365,367
367,368
367,369
392,393
392,394
398,399
398,400
442,443
442,444
450,451
450,452
455,456
455,457
463,464
463,465
464,465
464,466
465,466
465,467
475,476
475,477
480,481
480,482
497,498
497,499
508,509
508,510
516,517
516,518
535,536
535,537
563,564
563,565
564,565
564,566
565,566
565,567
574,575
574,576
575,576
575,577
582,583
582,584
583,584
583,585
584,585
584,586
586,587
586,588
596,597
596,598
597,598
597,599
599,600
599,601
613,614
613,615
614,615
614,616
621,622
621,623
622,623
622,624
629,630
629,631
636,637
636,638
660,661
660,662
666,667
666,668
-----guardedBy-----
174,253
183,223
194,202
189,206
193,201
195,203
216,224
217,225
215,223
300,316
487,510
483,552
-----guardedByNegation-----
174,671
171,624
183,552
179,287
175,640
300,655
305,624
308,552
309,353
301,640
-----lastLexicalUse-----
174,671
183,552
300,655
-----jump-----
174,671
183,552
300,655
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;WhileStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;FieldReference;FieldReference;IdExpression;Name;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;IdExpression;Name;IfStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;BinaryExpression;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ForStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;ConditionalExpression;BinaryExpression;UnaryExpression;BinaryExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;ForStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;IdExpression;Name;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;ArraySubscriptExpression;FieldReference;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;UnaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;InitializerList;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;ConditionalExpression;FieldReference;IdExpression;Name;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;
-----ast_node-----
voidwinimg_paint(void){  imglist *img;  imglist *prev = NULL;  /* free disk space if number of tempfile exceeds TEMPFILE_MAX_NUM */  while (tempfile_num > TEMPFILE_MAX_NUM && term.imgs.first) {    img = term.imgs.first;    term.imgs.first = term.imgs.first->next;    winimg_destroy(img);  }  HDC dc = GetDC(wnd);  RECT rc;  GetClientRect(wnd, &rc);  IntersectClipRect(dc, rc.left + PADDING, rc.top + PADDING,                    rc.left + PADDING + term.cols * cell_width,                    rc.top + PADDING + term.rows * cell_height);  for (img = term.imgs.first; img;) {    // if the image is out of scrollback, collect it    if (img->top + img->height - term.virtuallines < - term.sblines) {      if (img == term.imgs.first)        term.imgs.first = img->next;      if (img == term.imgs.last)        term.imgs.last = prev;      if (prev)        prev->next = img->next;      prev = img;      img = img->next;      winimg_destroy(prev);    } else {      // if the image is scrolled out, serialize it into a temp file.      int left = img->left;      int top = img->top - term.virtuallines - term.disptop;      if (top + img->height < 0 || top > term.rows) {        winimg_hibernate(img);      } else {        // create DC handle if it is not initialized, or resume from hibernate        winimg_lazyinit(img);        for (int y = max(0, top); y < min(top + img->height, term.rows); ++y) {          int wide_factor = (term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM ? 1: 2;          for (int x = left; x < min(left + img->width, term.cols); ++x) {            termchar *dchar = &term.displines[y]->chars[x];            // if sixel image is overwirtten by characters,            // exclude the area from the clipping rect.            bool update_flag = false;            if (dchar->chr != SIXELCH)              update_flag = true;            if (dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED))              update_flag = true;            if (term.selected && !update_flag) {              pos scrpos = {y + term.disptop, x, false};              update_flag = term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end);            }            if (update_flag)              ExcludeClipRect(dc,                              x * wide_factor * cell_width + PADDING,                              y * cell_height + PADDING,                              (x + 1) * wide_factor * cell_width + PADDING,                              (y + 1) * cell_height + PADDING);          }        }        StretchBlt(dc, left * cell_width + PADDING, top * cell_height + PADDING,                   img->width * cell_width, img->height * cell_height, img->hdc,                   0, 0, img->pixelwidth, img->pixelheight, SRCCOPY);      }      prev = img;      img = img->next;    }  }  ReleaseDC(wnd, dc);}
void
winimg_paint(void)
winimg_paint
void
void


{  imglist *img;  imglist *prev = NULL;  /* free disk space if number of tempfile exceeds TEMPFILE_MAX_NUM */  while (tempfile_num > TEMPFILE_MAX_NUM && term.imgs.first) {    img = term.imgs.first;    term.imgs.first = term.imgs.first->next;    winimg_destroy(img);  }  HDC dc = GetDC(wnd);  RECT rc;  GetClientRect(wnd, &rc);  IntersectClipRect(dc, rc.left + PADDING, rc.top + PADDING,                    rc.left + PADDING + term.cols * cell_width,                    rc.top + PADDING + term.rows * cell_height);  for (img = term.imgs.first; img;) {    // if the image is out of scrollback, collect it    if (img->top + img->height - term.virtuallines < - term.sblines) {      if (img == term.imgs.first)        term.imgs.first = img->next;      if (img == term.imgs.last)        term.imgs.last = prev;      if (prev)        prev->next = img->next;      prev = img;      img = img->next;      winimg_destroy(prev);    } else {      // if the image is scrolled out, serialize it into a temp file.      int left = img->left;      int top = img->top - term.virtuallines - term.disptop;      if (top + img->height < 0 || top > term.rows) {        winimg_hibernate(img);      } else {        // create DC handle if it is not initialized, or resume from hibernate        winimg_lazyinit(img);        for (int y = max(0, top); y < min(top + img->height, term.rows); ++y) {          int wide_factor = (term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM ? 1: 2;          for (int x = left; x < min(left + img->width, term.cols); ++x) {            termchar *dchar = &term.displines[y]->chars[x];            // if sixel image is overwirtten by characters,            // exclude the area from the clipping rect.            bool update_flag = false;            if (dchar->chr != SIXELCH)              update_flag = true;            if (dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED))              update_flag = true;            if (term.selected && !update_flag) {              pos scrpos = {y + term.disptop, x, false};              update_flag = term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end);            }            if (update_flag)              ExcludeClipRect(dc,                              x * wide_factor * cell_width + PADDING,                              y * cell_height + PADDING,                              (x + 1) * wide_factor * cell_width + PADDING,                              (y + 1) * cell_height + PADDING);          }        }        StretchBlt(dc, left * cell_width + PADDING, top * cell_height + PADDING,                   img->width * cell_width, img->height * cell_height, img->hdc,                   0, 0, img->pixelwidth, img->pixelheight, SRCCOPY);      }      prev = img;      img = img->next;    }  }  ReleaseDC(wnd, dc);}
imglist *img;
imglist *img;
imglist
imglist
*img
*
img
imglist *prev = NULL;
imglist *prev = NULL;
imglist
imglist
*prev = NULL
*
prev
= NULL
NULL
NULL
while (tempfile_num > TEMPFILE_MAX_NUM && term.imgs.first) {    img = term.imgs.first;    term.imgs.first = term.imgs.first->next;    winimg_destroy(img);  }
tempfile_num > TEMPFILE_MAX_NUM && term.imgs.first
tempfile_num > TEMPFILE_MAX_NUM
tempfile_num
tempfile_num
TEMPFILE_MAX_NUM
TEMPFILE_MAX_NUM
term.imgs.first
term.imgs
term
term
imgs
first
{    img = term.imgs.first;    term.imgs.first = term.imgs.first->next;    winimg_destroy(img);  }
img = term.imgs.first;
img = term.imgs.first
img
img
term.imgs.first
term.imgs
term
term
imgs
first
term.imgs.first = term.imgs.first->next;
term.imgs.first = term.imgs.first->next
term.imgs.first
term.imgs
term
term
imgs
first
term.imgs.first->next
term.imgs.first
term.imgs
term
term
imgs
first
next
winimg_destroy(img);
winimg_destroy(img)
winimg_destroy
winimg_destroy
img
img
HDC dc = GetDC(wnd);
HDC dc = GetDC(wnd);
HDC
HDC
dc = GetDC(wnd)
dc
= GetDC(wnd)
GetDC(wnd)
GetDC
GetDC
wnd
wnd
RECT rc;
RECT rc;
RECT
RECT
rc
rc
GetClientRect(wnd, &rc);
GetClientRect(wnd, &rc)
GetClientRect
GetClientRect
wnd
wnd
&rc
rc
rc
IntersectClipRect(dc, rc.left + PADDING, rc.top + PADDING,                    rc.left + PADDING + term.cols * cell_width,                    rc.top + PADDING + term.rows * cell_height);
IntersectClipRect(dc, rc.left + PADDING, rc.top + PADDING,                    rc.left + PADDING + term.cols * cell_width,                    rc.top + PADDING + term.rows * cell_height)
IntersectClipRect
IntersectClipRect
dc
dc
rc.left + PADDING
rc.left
rc
rc
left
PADDING
PADDING
rc.top + PADDING
rc.top
rc
rc
top
PADDING
PADDING
rc.left + PADDING + term.cols * cell_width
rc.left + PADDING
rc.left
rc
rc
left
PADDING
PADDING
term.cols * cell_width
term.cols
term
term
cols
cell_width
cell_width
rc.top + PADDING + term.rows * cell_height
rc.top + PADDING
rc.top
rc
rc
top
PADDING
PADDING
term.rows * cell_height
term.rows
term
term
rows
cell_height
cell_height
for (img = term.imgs.first; img;) {    // if the image is out of scrollback, collect it    if (img->top + img->height - term.virtuallines < - term.sblines) {      if (img == term.imgs.first)        term.imgs.first = img->next;      if (img == term.imgs.last)        term.imgs.last = prev;      if (prev)        prev->next = img->next;      prev = img;      img = img->next;      winimg_destroy(prev);    } else {      // if the image is scrolled out, serialize it into a temp file.      int left = img->left;      int top = img->top - term.virtuallines - term.disptop;      if (top + img->height < 0 || top > term.rows) {        winimg_hibernate(img);      } else {        // create DC handle if it is not initialized, or resume from hibernate        winimg_lazyinit(img);        for (int y = max(0, top); y < min(top + img->height, term.rows); ++y) {          int wide_factor = (term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM ? 1: 2;          for (int x = left; x < min(left + img->width, term.cols); ++x) {            termchar *dchar = &term.displines[y]->chars[x];            // if sixel image is overwirtten by characters,            // exclude the area from the clipping rect.            bool update_flag = false;            if (dchar->chr != SIXELCH)              update_flag = true;            if (dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED))              update_flag = true;            if (term.selected && !update_flag) {              pos scrpos = {y + term.disptop, x, false};              update_flag = term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end);            }            if (update_flag)              ExcludeClipRect(dc,                              x * wide_factor * cell_width + PADDING,                              y * cell_height + PADDING,                              (x + 1) * wide_factor * cell_width + PADDING,                              (y + 1) * cell_height + PADDING);          }        }        StretchBlt(dc, left * cell_width + PADDING, top * cell_height + PADDING,                   img->width * cell_width, img->height * cell_height, img->hdc,                   0, 0, img->pixelwidth, img->pixelheight, SRCCOPY);      }      prev = img;      img = img->next;    }  }
img = term.imgs.first;
img = term.imgs.first
img
img
term.imgs.first
term.imgs
term
term
imgs
first
img
img
{    // if the image is out of scrollback, collect it    if (img->top + img->height - term.virtuallines < - term.sblines) {      if (img == term.imgs.first)        term.imgs.first = img->next;      if (img == term.imgs.last)        term.imgs.last = prev;      if (prev)        prev->next = img->next;      prev = img;      img = img->next;      winimg_destroy(prev);    } else {      // if the image is scrolled out, serialize it into a temp file.      int left = img->left;      int top = img->top - term.virtuallines - term.disptop;      if (top + img->height < 0 || top > term.rows) {        winimg_hibernate(img);      } else {        // create DC handle if it is not initialized, or resume from hibernate        winimg_lazyinit(img);        for (int y = max(0, top); y < min(top + img->height, term.rows); ++y) {          int wide_factor = (term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM ? 1: 2;          for (int x = left; x < min(left + img->width, term.cols); ++x) {            termchar *dchar = &term.displines[y]->chars[x];            // if sixel image is overwirtten by characters,            // exclude the area from the clipping rect.            bool update_flag = false;            if (dchar->chr != SIXELCH)              update_flag = true;            if (dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED))              update_flag = true;            if (term.selected && !update_flag) {              pos scrpos = {y + term.disptop, x, false};              update_flag = term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end);            }            if (update_flag)              ExcludeClipRect(dc,                              x * wide_factor * cell_width + PADDING,                              y * cell_height + PADDING,                              (x + 1) * wide_factor * cell_width + PADDING,                              (y + 1) * cell_height + PADDING);          }        }        StretchBlt(dc, left * cell_width + PADDING, top * cell_height + PADDING,                   img->width * cell_width, img->height * cell_height, img->hdc,                   0, 0, img->pixelwidth, img->pixelheight, SRCCOPY);      }      prev = img;      img = img->next;    }  }
if (img->top + img->height - term.virtuallines < - term.sblines) {      if (img == term.imgs.first)        term.imgs.first = img->next;      if (img == term.imgs.last)        term.imgs.last = prev;      if (prev)        prev->next = img->next;      prev = img;      img = img->next;      winimg_destroy(prev);    } else {      // if the image is scrolled out, serialize it into a temp file.      int left = img->left;      int top = img->top - term.virtuallines - term.disptop;      if (top + img->height < 0 || top > term.rows) {        winimg_hibernate(img);      } else {        // create DC handle if it is not initialized, or resume from hibernate        winimg_lazyinit(img);        for (int y = max(0, top); y < min(top + img->height, term.rows); ++y) {          int wide_factor = (term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM ? 1: 2;          for (int x = left; x < min(left + img->width, term.cols); ++x) {            termchar *dchar = &term.displines[y]->chars[x];            // if sixel image is overwirtten by characters,            // exclude the area from the clipping rect.            bool update_flag = false;            if (dchar->chr != SIXELCH)              update_flag = true;            if (dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED))              update_flag = true;            if (term.selected && !update_flag) {              pos scrpos = {y + term.disptop, x, false};              update_flag = term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end);            }            if (update_flag)              ExcludeClipRect(dc,                              x * wide_factor * cell_width + PADDING,                              y * cell_height + PADDING,                              (x + 1) * wide_factor * cell_width + PADDING,                              (y + 1) * cell_height + PADDING);          }        }        StretchBlt(dc, left * cell_width + PADDING, top * cell_height + PADDING,                   img->width * cell_width, img->height * cell_height, img->hdc,                   0, 0, img->pixelwidth, img->pixelheight, SRCCOPY);      }      prev = img;      img = img->next;    }
img->top + img->height - term.virtuallines < - term.sblines
img->top + img->height - term.virtuallines
img->top + img->height
img->top
img
img
top
img->height
img
img
height
term.virtuallines
term
term
virtuallines
- term.sblines
term.sblines
term
term
sblines
{      if (img == term.imgs.first)        term.imgs.first = img->next;      if (img == term.imgs.last)        term.imgs.last = prev;      if (prev)        prev->next = img->next;      prev = img;      img = img->next;      winimg_destroy(prev);    }
if (img == term.imgs.first)        term.imgs.first = img->next;
img == term.imgs.first
img
img
term.imgs.first
term.imgs
term
term
imgs
first
term.imgs.first = img->next;
term.imgs.first = img->next
term.imgs.first
term.imgs
term
term
imgs
first
img->next
img
img
next
if (img == term.imgs.last)        term.imgs.last = prev;
img == term.imgs.last
img
img
term.imgs.last
term.imgs
term
term
imgs
last
term.imgs.last = prev;
term.imgs.last = prev
term.imgs.last
term.imgs
term
term
imgs
last
prev
prev
if (prev)        prev->next = img->next;
prev
prev
prev->next = img->next;
prev->next = img->next
prev->next
prev
prev
next
img->next
img
img
next
prev = img;
prev = img
prev
prev
img
img
img = img->next;
img = img->next
img
img
img->next
img
img
next
winimg_destroy(prev);
winimg_destroy(prev)
winimg_destroy
winimg_destroy
prev
prev
{      // if the image is scrolled out, serialize it into a temp file.      int left = img->left;      int top = img->top - term.virtuallines - term.disptop;      if (top + img->height < 0 || top > term.rows) {        winimg_hibernate(img);      } else {        // create DC handle if it is not initialized, or resume from hibernate        winimg_lazyinit(img);        for (int y = max(0, top); y < min(top + img->height, term.rows); ++y) {          int wide_factor = (term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM ? 1: 2;          for (int x = left; x < min(left + img->width, term.cols); ++x) {            termchar *dchar = &term.displines[y]->chars[x];            // if sixel image is overwirtten by characters,            // exclude the area from the clipping rect.            bool update_flag = false;            if (dchar->chr != SIXELCH)              update_flag = true;            if (dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED))              update_flag = true;            if (term.selected && !update_flag) {              pos scrpos = {y + term.disptop, x, false};              update_flag = term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end);            }            if (update_flag)              ExcludeClipRect(dc,                              x * wide_factor * cell_width + PADDING,                              y * cell_height + PADDING,                              (x + 1) * wide_factor * cell_width + PADDING,                              (y + 1) * cell_height + PADDING);          }        }        StretchBlt(dc, left * cell_width + PADDING, top * cell_height + PADDING,                   img->width * cell_width, img->height * cell_height, img->hdc,                   0, 0, img->pixelwidth, img->pixelheight, SRCCOPY);      }      prev = img;      img = img->next;    }
int left = img->left;
int left = img->left;
int
left = img->left
left
= img->left
img->left
img
img
left
int top = img->top - term.virtuallines - term.disptop;
int top = img->top - term.virtuallines - term.disptop;
int
top = img->top - term.virtuallines - term.disptop
top
= img->top - term.virtuallines - term.disptop
img->top - term.virtuallines - term.disptop
img->top - term.virtuallines
img->top
img
img
top
term.virtuallines
term
term
virtuallines
term.disptop
term
term
disptop
if (top + img->height < 0 || top > term.rows) {        winimg_hibernate(img);      } else {        // create DC handle if it is not initialized, or resume from hibernate        winimg_lazyinit(img);        for (int y = max(0, top); y < min(top + img->height, term.rows); ++y) {          int wide_factor = (term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM ? 1: 2;          for (int x = left; x < min(left + img->width, term.cols); ++x) {            termchar *dchar = &term.displines[y]->chars[x];            // if sixel image is overwirtten by characters,            // exclude the area from the clipping rect.            bool update_flag = false;            if (dchar->chr != SIXELCH)              update_flag = true;            if (dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED))              update_flag = true;            if (term.selected && !update_flag) {              pos scrpos = {y + term.disptop, x, false};              update_flag = term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end);            }            if (update_flag)              ExcludeClipRect(dc,                              x * wide_factor * cell_width + PADDING,                              y * cell_height + PADDING,                              (x + 1) * wide_factor * cell_width + PADDING,                              (y + 1) * cell_height + PADDING);          }        }        StretchBlt(dc, left * cell_width + PADDING, top * cell_height + PADDING,                   img->width * cell_width, img->height * cell_height, img->hdc,                   0, 0, img->pixelwidth, img->pixelheight, SRCCOPY);      }
top + img->height < 0 || top > term.rows
top + img->height < 0
top + img->height
top
top
img->height
img
img
height
0
top > term.rows
top
top
term.rows
term
term
rows
{        winimg_hibernate(img);      }
winimg_hibernate(img);
winimg_hibernate(img)
winimg_hibernate
winimg_hibernate
img
img
{        // create DC handle if it is not initialized, or resume from hibernate        winimg_lazyinit(img);        for (int y = max(0, top); y < min(top + img->height, term.rows); ++y) {          int wide_factor = (term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM ? 1: 2;          for (int x = left; x < min(left + img->width, term.cols); ++x) {            termchar *dchar = &term.displines[y]->chars[x];            // if sixel image is overwirtten by characters,            // exclude the area from the clipping rect.            bool update_flag = false;            if (dchar->chr != SIXELCH)              update_flag = true;            if (dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED))              update_flag = true;            if (term.selected && !update_flag) {              pos scrpos = {y + term.disptop, x, false};              update_flag = term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end);            }            if (update_flag)              ExcludeClipRect(dc,                              x * wide_factor * cell_width + PADDING,                              y * cell_height + PADDING,                              (x + 1) * wide_factor * cell_width + PADDING,                              (y + 1) * cell_height + PADDING);          }        }        StretchBlt(dc, left * cell_width + PADDING, top * cell_height + PADDING,                   img->width * cell_width, img->height * cell_height, img->hdc,                   0, 0, img->pixelwidth, img->pixelheight, SRCCOPY);      }
winimg_lazyinit(img);
winimg_lazyinit(img)
winimg_lazyinit
winimg_lazyinit
img
img
for (int y = max(0, top); y < min(top + img->height, term.rows); ++y) {          int wide_factor = (term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM ? 1: 2;          for (int x = left; x < min(left + img->width, term.cols); ++x) {            termchar *dchar = &term.displines[y]->chars[x];            // if sixel image is overwirtten by characters,            // exclude the area from the clipping rect.            bool update_flag = false;            if (dchar->chr != SIXELCH)              update_flag = true;            if (dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED))              update_flag = true;            if (term.selected && !update_flag) {              pos scrpos = {y + term.disptop, x, false};              update_flag = term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end);            }            if (update_flag)              ExcludeClipRect(dc,                              x * wide_factor * cell_width + PADDING,                              y * cell_height + PADDING,                              (x + 1) * wide_factor * cell_width + PADDING,                              (y + 1) * cell_height + PADDING);          }        }
int y = max(0, top);
int y = max(0, top);
int
y = max(0, top)
y
= max(0, top)
max(0, top)
max
max
0
top
top
y < min(top + img->height, term.rows)
y
y
min(top + img->height, term.rows)
min
min
top + img->height
top
top
img->height
img
img
height
term.rows
term
term
rows
++y
y
y
{          int wide_factor = (term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM ? 1: 2;          for (int x = left; x < min(left + img->width, term.cols); ++x) {            termchar *dchar = &term.displines[y]->chars[x];            // if sixel image is overwirtten by characters,            // exclude the area from the clipping rect.            bool update_flag = false;            if (dchar->chr != SIXELCH)              update_flag = true;            if (dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED))              update_flag = true;            if (term.selected && !update_flag) {              pos scrpos = {y + term.disptop, x, false};              update_flag = term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end);            }            if (update_flag)              ExcludeClipRect(dc,                              x * wide_factor * cell_width + PADDING,                              y * cell_height + PADDING,                              (x + 1) * wide_factor * cell_width + PADDING,                              (y + 1) * cell_height + PADDING);          }        }
int wide_factor = (term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM ? 1: 2;
int wide_factor = (term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM ? 1: 2;
int
wide_factor = (term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM ? 1: 2
wide_factor
= (term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM ? 1: 2
(term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM ? 1: 2
(term.displines[y]->lattr & LATTR_MODE) == LATTR_NORM
(term.displines[y]->lattr & LATTR_MODE)
term.displines[y]->lattr & LATTR_MODE
term.displines[y]->lattr
term.displines[y]
term.displines
term
term
displines
y
y
lattr
LATTR_MODE
LATTR_MODE
LATTR_NORM
LATTR_NORM
1
2
for (int x = left; x < min(left + img->width, term.cols); ++x) {            termchar *dchar = &term.displines[y]->chars[x];            // if sixel image is overwirtten by characters,            // exclude the area from the clipping rect.            bool update_flag = false;            if (dchar->chr != SIXELCH)              update_flag = true;            if (dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED))              update_flag = true;            if (term.selected && !update_flag) {              pos scrpos = {y + term.disptop, x, false};              update_flag = term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end);            }            if (update_flag)              ExcludeClipRect(dc,                              x * wide_factor * cell_width + PADDING,                              y * cell_height + PADDING,                              (x + 1) * wide_factor * cell_width + PADDING,                              (y + 1) * cell_height + PADDING);          }
int x = left;
int x = left;
int
x = left
x
= left
left
left
x < min(left + img->width, term.cols)
x
x
min(left + img->width, term.cols)
min
min
left + img->width
left
left
img->width
img
img
width
term.cols
term
term
cols
++x
x
x
{            termchar *dchar = &term.displines[y]->chars[x];            // if sixel image is overwirtten by characters,            // exclude the area from the clipping rect.            bool update_flag = false;            if (dchar->chr != SIXELCH)              update_flag = true;            if (dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED))              update_flag = true;            if (term.selected && !update_flag) {              pos scrpos = {y + term.disptop, x, false};              update_flag = term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end);            }            if (update_flag)              ExcludeClipRect(dc,                              x * wide_factor * cell_width + PADDING,                              y * cell_height + PADDING,                              (x + 1) * wide_factor * cell_width + PADDING,                              (y + 1) * cell_height + PADDING);          }
termchar *dchar = &term.displines[y]->chars[x];
termchar *dchar = &term.displines[y]->chars[x];
termchar
termchar
*dchar = &term.displines[y]->chars[x]
*
dchar
= &term.displines[y]->chars[x]
&term.displines[y]->chars[x]
term.displines[y]->chars[x]
term.displines[y]->chars
term.displines[y]
term.displines
term
term
displines
y
y
chars
x
x
bool update_flag = false;
bool update_flag = false;
bool
update_flag = false
update_flag
= false
false
if (dchar->chr != SIXELCH)              update_flag = true;
dchar->chr != SIXELCH
dchar->chr
dchar
dchar
chr
SIXELCH
SIXELCH
update_flag = true;
update_flag = true
update_flag
update_flag
true
if (dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED))              update_flag = true;
dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED)
dchar->attr.attr
dchar->attr
dchar
dchar
attr
attr
(TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED)
TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED
TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED
TATTR_RESULT | TATTR_CURRESULT
TATTR_RESULT
TATTR_RESULT
TATTR_CURRESULT
TATTR_CURRESULT
TATTR_MARKED
TATTR_MARKED
TATTR_CURMARKED
TATTR_CURMARKED
update_flag = true;
update_flag = true
update_flag
update_flag
true
if (term.selected && !update_flag) {              pos scrpos = {y + term.disptop, x, false};              update_flag = term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end);            }
term.selected && !update_flag
term.selected
term
term
selected
!update_flag
update_flag
update_flag
{              pos scrpos = {y + term.disptop, x, false};              update_flag = term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end);            }
pos scrpos = {y + term.disptop, x, false};
pos scrpos = {y + term.disptop, x, false};
pos
pos
scrpos = {y + term.disptop, x, false}
scrpos
= {y + term.disptop, x, false}
{y + term.disptop, x, false}
y + term.disptop
y
y
term.disptop
term
term
disptop
x
x
false
update_flag = term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end);
update_flag = term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end)
update_flag
update_flag
term.sel_rect                  ? posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)                  : posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end)
term.sel_rect
term
term
sel_rect
posPle(term.sel_start, scrpos) && posPlt(scrpos, term.sel_end)
posPle(term.sel_start, scrpos)
posPle
posPle
term.sel_start
term
term
sel_start
scrpos
scrpos
posPlt(scrpos, term.sel_end)
posPlt
posPlt
scrpos
scrpos
term.sel_end
term
term
sel_end
posle(term.sel_start, scrpos) && poslt(scrpos, term.sel_end)
posle(term.sel_start, scrpos)
posle
posle
term.sel_start
term
term
sel_start
scrpos
scrpos
poslt(scrpos, term.sel_end)
poslt
poslt
scrpos
scrpos
term.sel_end
term
term
sel_end
if (update_flag)              ExcludeClipRect(dc,                              x * wide_factor * cell_width + PADDING,                              y * cell_height + PADDING,                              (x + 1) * wide_factor * cell_width + PADDING,                              (y + 1) * cell_height + PADDING);
update_flag
update_flag
ExcludeClipRect(dc,                              x * wide_factor * cell_width + PADDING,                              y * cell_height + PADDING,                              (x + 1) * wide_factor * cell_width + PADDING,                              (y + 1) * cell_height + PADDING);
ExcludeClipRect(dc,                              x * wide_factor * cell_width + PADDING,                              y * cell_height + PADDING,                              (x + 1) * wide_factor * cell_width + PADDING,                              (y + 1) * cell_height + PADDING)
ExcludeClipRect
ExcludeClipRect
dc
dc
x * wide_factor * cell_width + PADDING
x * wide_factor * cell_width
x * wide_factor
x
x
wide_factor
wide_factor
cell_width
cell_width
PADDING
PADDING
y * cell_height + PADDING
y * cell_height
y
y
cell_height
cell_height
PADDING
PADDING
(x + 1) * wide_factor * cell_width + PADDING
(x + 1) * wide_factor * cell_width
(x + 1) * wide_factor
(x + 1)
x + 1
x
x
1
wide_factor
wide_factor
cell_width
cell_width
PADDING
PADDING
(y + 1) * cell_height + PADDING
(y + 1) * cell_height
(y + 1)
y + 1
y
y
1
cell_height
cell_height
PADDING
PADDING
StretchBlt(dc, left * cell_width + PADDING, top * cell_height + PADDING,                   img->width * cell_width, img->height * cell_height, img->hdc,                   0, 0, img->pixelwidth, img->pixelheight, SRCCOPY);
StretchBlt(dc, left * cell_width + PADDING, top * cell_height + PADDING,                   img->width * cell_width, img->height * cell_height, img->hdc,                   0, 0, img->pixelwidth, img->pixelheight, SRCCOPY)
StretchBlt
StretchBlt
dc
dc
left * cell_width + PADDING
left * cell_width
left
left
cell_width
cell_width
PADDING
PADDING
top * cell_height + PADDING
top * cell_height
top
top
cell_height
cell_height
PADDING
PADDING
img->width * cell_width
img->width
img
img
width
cell_width
cell_width
img->height * cell_height
img->height
img
img
height
cell_height
cell_height
img->hdc
img
img
hdc
0
0
img->pixelwidth
img
img
pixelwidth
img->pixelheight
img
img
pixelheight
SRCCOPY
SRCCOPY
prev = img;
prev = img
prev
prev
img
img
img = img->next;
img = img->next
img
img
img->next
img
img
next
ReleaseDC(wnd, dc);
ReleaseDC(wnd, dc)
ReleaseDC
ReleaseDC
wnd
wnd
dc
dc
-----joern-----
(123,161,0)
(277,4,0)
(391,400,0)
(255,353,0)
(12,150,0)
(29,263,0)
(285,178,0)
(103,303,0)
(332,216,0)
(129,98,0)
(323,121,0)
(270,199,0)
(44,259,0)
(139,308,0)
(411,415,0)
(161,123,0)
(371,171,0)
(99,376,0)
(340,89,0)
(220,285,0)
(390,101,0)
(230,114,0)
(133,56,0)
(41,259,0)
(154,89,0)
(377,348,0)
(375,200,0)
(171,371,0)
(310,105,0)
(1,44,0)
(327,311,0)
(317,182,0)
(263,29,0)
(385,358,0)
(53,157,0)
(217,1,0)
(46,409,0)
(170,102,0)
(359,182,0)
(384,367,0)
(315,211,0)
(353,83,0)
(56,403,0)
(66,105,0)
(271,37,0)
(179,315,0)
(127,89,0)
(11,350,0)
(296,400,0)
(389,394,0)
(272,199,0)
(122,281,0)
(268,344,0)
(68,228,0)
(383,311,0)
(78,72,0)
(62,105,0)
(330,196,0)
(308,103,0)
(100,44,0)
(16,388,0)
(155,211,0)
(187,89,0)
(211,89,0)
(241,293,0)
(381,376,0)
(154,311,0)
(145,170,0)
(327,89,0)
(311,350,0)
(198,152,0)
(168,400,0)
(312,385,0)
(186,171,0)
(87,140,0)
(201,282,0)
(124,287,0)
(408,358,0)
(397,61,0)
(395,65,0)
(52,311,0)
(70,89,0)
(237,381,0)
(61,261,0)
(104,253,0)
(24,335,0)
(224,120,0)
(254,259,0)
(123,63,0)
(126,286,0)
(244,23,0)
(223,301,0)
(236,9,0)
(271,71,0)
(316,144,0)
(353,68,0)
(327,135,0)
(23,244,0)
(377,126,0)
(398,311,0)
(417,138,0)
(8,61,0)
(379,303,0)
(407,121,0)
(206,389,0)
(30,327,0)
(328,126,0)
(306,263,0)
(340,311,0)
(3,174,0)
(286,126,0)
(221,413,0)
(40,384,0)
(152,198,0)
(200,244,0)
(246,282,0)
(70,51,0)
(415,411,0)
(301,311,0)
(102,408,0)
(198,64,0)
(88,210,0)
(27,105,0)
(265,80,0)
(352,113,0)
(83,408,0)
(349,88,0)
(65,9,0)
(409,1,0)
(213,228,0)
(405,64,0)
(331,376,0)
(68,101,0)
(194,72,0)
(271,221,0)
(204,385,0)
(397,311,0)
(82,9,0)
(68,240,0)
(231,35,0)
(111,311,0)
(83,353,0)
(126,377,0)
(191,381,0)
(240,311,0)
(131,2,0)
(150,261,0)
(252,149,0)
(81,270,0)
(394,120,0)
(29,138,0)
(291,382,0)
(132,302,0)
(132,248,0)
(43,247,0)
(227,415,0)
(333,140,0)
(363,43,0)
(136,376,0)
(288,261,0)
(278,210,0)
(281,347,0)
(273,69,0)
(70,44,0)
(178,285,0)
(247,284,0)
(68,100,0)
(300,161,0)
(94,220,0)
(16,102,0)
(79,170,0)
(295,220,0)
(292,76,0)
(416,348,0)
(393,388,0)
(200,23,0)
(287,124,0)
(385,311,0)
(314,114,0)
(146,186,0)
(156,260,0)
(150,44,0)
(215,127,0)
(119,391,0)
(270,113,0)
(35,311,0)
(196,199,0)
(272,339,0)
(150,89,0)
(101,382,0)
(211,311,0)
(333,47,0)
(108,100,0)
(362,367,0)
(266,68,0)
(162,398,0)
(302,132,0)
(259,44,0)
(48,344,0)
(374,302,0)
(398,44,0)
(406,166,0)
(267,384,0)
(135,253,0)
(361,44,0)
(113,270,0)
(365,134,0)
(152,376,0)
(192,295,0)
(183,161,0)
(386,154,0)
(350,44,0)
(240,68,0)
(243,408,0)
(18,153,0)
(31,264,0)
(157,44,0)
(207,166,0)
(104,44,0)
(85,76,0)
(392,270,0)
(295,0,0)
(307,187,0)
(366,65,0)
(211,44,0)
(135,327,0)
(257,69,0)
(380,153,0)
(138,29,0)
(51,408,0)
(63,230,0)
(121,339,0)
(337,5,0)
(154,44,0)
(240,89,0)
(260,344,0)
(412,325,0)
(34,68,0)
(74,51,0)
(336,358,0)
(25,228,0)
(14,198,0)
(281,122,0)
(394,389,0)
(86,373,0)
(125,287,0)
(175,348,0)
(115,68,0)
(320,4,0)
(294,359,0)
(173,74,0)
(113,352,0)
(222,43,0)
(54,411,0)
(416,408,0)
(361,391,0)
(355,375,0)
(35,89,0)
(111,44,0)
(189,397,0)
(235,82,0)
(178,199,0)
(159,104,0)
(397,44,0)
(51,70,0)
(304,172,0)
(84,346,0)
(339,272,0)
(74,173,0)
(264,23,0)
(138,50,0)
(240,44,0)
(199,261,0)
(33,0,0)
(109,342,0)
(59,1,0)
(72,384,0)
(120,224,0)
(63,123,0)
(150,311,0)
(301,89,0)
(268,297,0)
(350,311,0)
(287,144,0)
(182,359,0)
(210,144,0)
(284,124,0)
(256,244,0)
(403,23,0)
(104,311,0)
(251,408,0)
(163,104,0)
(340,248,0)
(157,311,0)
(334,394,0)
(350,89,0)
(171,186,0)
(220,295,0)
(264,301,0)
(385,89,0)
(410,308,0)
(409,68,0)
(60,376,0)
(261,358,0)
(357,398,0)
(141,247,0)
(221,271,0)
(361,311,0)
(371,233,0)
(127,311,0)
(303,103,0)
(244,200,0)
(26,293,0)
(1,89,0)
(89,187,0)
(20,70,0)
(186,117,0)
(175,103,0)
(274,23,0)
(388,16,0)
(103,308,0)
(1,409,0)
(243,157,0)
(38,376,0)
(1,311,0)
(253,104,0)
(52,89,0)
(218,174,0)
(187,23,0)
(96,377,0)
(13,416,0)
(193,52,0)
(290,358,0)
(364,200,0)
(130,35,0)
(148,80,0)
(184,263,0)
(212,37,0)
(164,119,0)
(137,35,0)
(402,69,0)
(418,314,0)
(250,187,0)
(77,2,0)
(165,397,0)
(248,340,0)
(381,101,0)
(325,129,0)
(346,117,0)
(378,348,0)
(135,153,0)
(50,138,0)
(102,170,0)
(122,124,0)
(214,350,0)
(2,131,0)
(129,274,0)
(225,56,0)
(414,89,0)
(149,385,0)
(220,101,0)
(178,78,0)
(68,409,0)
(188,378,0)
(313,352,0)
(65,348,0)
(338,297,0)
(97,119,0)
(158,124,0)
(88,76,0)
(100,68,0)
(398,357,0)
(76,88,0)
(190,403,0)
(149,211,0)
(29,152,0)
(36,348,0)
(281,210,0)
(110,371,0)
(384,72,0)
(352,72,0)
(32,201,0)
(399,131,0)
(44,358,0)
(152,224,0)
(112,158,0)
(101,376,0)
(152,29,0)
(142,220,0)
(305,274,0)
(88,284,0)
(242,413,0)
(213,261,0)
(230,63,0)
(37,105,0)
(342,74,0)
(228,68,0)
(149,166,0)
(157,243,0)
(68,357,0)
(318,335,0)
(411,314,0)
(280,233,0)
(203,50,0)
(51,74,0)
(61,339,0)
(35,231,0)
(259,89,0)
(397,89,0)
(181,376,0)
(123,348,0)
(220,94,0)
(55,327,0)
(377,5,0)
(400,211,0)
(245,78,0)
(369,132,0)
(220,82,0)
(187,307,0)
(6,340,0)
(117,346,0)
(68,174,0)
(301,264,0)
(391,119,0)
(259,311,0)
(111,174,0)
(151,175,0)
(21,83,0)
(382,101,0)
(326,243,0)
(205,347,0)
(348,416,0)
(118,373,0)
(72,69,0)
(177,357,0)
(2,152,0)
(23,98,0)
(100,311,0)
(64,198,0)
(368,152,0)
(185,117,0)
(127,44,0)
(224,152,0)
(370,233,0)
(253,47,0)
(17,416,0)
(303,52,0)
(209,173,0)
(401,352,0)
(73,105,0)
(275,149,0)
(152,101,0)
(169,68,0)
(7,347,0)
(104,89,0)
(61,397,0)
(22,281,0)
(107,398,0)
(82,220,0)
(122,282,0)
(284,88,0)
(0,295,0)
(90,302,0)
(157,89,0)
(47,333,0)
(341,157,0)
(176,391,0)
(253,135,0)
(339,121,0)
(274,129,0)
(202,260,0)
(52,44,0)
(388,243,0)
(345,286,0)
(114,314,0)
(224,4,0)
(58,102,0)
(297,268,0)
(351,83,0)
(93,52,0)
(247,43,0)
(284,247,0)
(385,44,0)
(149,231,0)
(387,240,0)
(344,260,0)
(68,127,0)
(160,271,0)
(124,158,0)
(347,281,0)
(75,111,0)
(113,94,0)
(134,296,0)
(322,230,0)
(35,44,0)
(282,122,0)
(166,376,0)
(70,311,0)
(167,71,0)
(45,140,0)
(0,348,0)
(303,408,0)
(391,361,0)
(271,293,0)
(258,37,0)
(243,388,0)
(94,113,0)
(314,105,0)
(282,201,0)
(400,166,0)
(219,296,0)
(211,80,0)
(226,94,0)
(373,264,0)
(111,89,0)
(116,213,0)
(154,356,0)
(103,175,0)
(68,353,0)
(67,63,0)
(357,68,0)
(329,100,0)
(140,333,0)
(299,211,0)
(367,384,0)
(19,78,0)
(403,56,0)
(335,274,0)
(398,89,0)
(319,71,0)
(264,373,0)
(289,80,0)
(91,272,0)
(117,186,0)
(286,367,0)
(197,131,0)
(343,158,0)
(262,173,0)
(325,98,0)
(57,127,0)
(78,178,0)
(249,216,0)
(233,314,0)
(301,44,0)
(261,150,0)
(52,303,0)
(327,44,0)
(274,335,0)
(208,134,0)
(247,210,0)
(4,224,0)
(238,340,0)
(180,342,0)
(404,0,0)
(361,89,0)
(344,268,0)
(200,375,0)
(413,221,0)
(47,253,0)
(264,248,0)
(340,44,0)
(216,50,0)
(106,307,0)
(232,285,0)
(9,82,0)
(9,65,0)
(372,105,0)
(324,5,0)
(321,411,0)
(195,389,0)
(147,120,0)
(100,89,0)
(309,240,0)
(233,371,0)
(279,213,0)
(315,80,0)
(298,199,0)
(234,123,0)
(228,213,0)
(124,122,0)
(42,150,0)
(182,376,0)
(311,80,0)
(419,199,0)
(269,361,0)
(10,297,0)
(120,394,0)
(128,346,0)
(50,216,0)
(239,201,0)
(400,385,0)
(230,199,0)
(339,61,0)
(276,64,0)
(152,2,0)
(5,377,0)
(354,44,0)
(282,210,0)
(49,375,0)
(39,70,0)
(396,413,0)
(102,16,0)
(296,134,0)
(114,230,0)
(283,178,0)
(127,68,0)
(74,342,0)
(28,307,0)
(15,129,0)
(408,51,0)
(285,220,0)
(124,284,0)
(95,358,0)
(367,286,0)
(344,23,0)
(153,135,0)
(349,247,1)
(375,49,1)
(161,300,1)
(307,28,1)
(247,141,1)
(305,335,1)
(64,405,1)
(94,113,1)
(228,25,1)
(51,70,1)
(394,389,1)
(342,109,1)
(288,47,1)
(113,352,1)
(229,221,1)
(122,281,1)
(197,368,1)
(124,158,1)
(187,307,1)
(52,89,1)
(341,53,1)
(205,7,1)
(11,214,1)
(142,229,1)
(68,228,1)
(270,199,1)
(35,137,1)
(157,89,1)
(344,48,1)
(127,44,1)
(334,389,1)
(242,171,1)
(297,10,1)
(230,63,1)
(190,56,1)
(285,178,1)
(282,201,1)
(127,57,1)
(264,248,1)
(417,263,1)
(365,361,1)
(223,47,1)
(243,408,1)
(166,406,1)
(360,381,1)
(128,185,1)
(367,286,1)
(37,212,1)
(22,282,1)
(299,143,1)
(312,154,1)
(196,330,1)
(227,411,1)
(121,323,1)
(178,199,1)
(96,5,1)
(357,177,1)
(92,315,1)
(157,341,1)
(151,378,1)
(340,238,1)
(247,210,1)
(158,343,1)
(104,44,1)
(317,101,1)
(79,58,1)
(29,138,1)
(374,90,1)
(350,311,1)
(311,350,1)
(180,70,1)
(269,301,1)
(254,354,1)
(152,2,1)
(395,94,1)
(120,394,1)
(157,44,1)
(67,123,1)
(378,348,1)
(260,156,1)
(387,100,1)
(150,44,1)
(4,277,1)
(57,215,1)
(46,1,1)
(351,21,1)
(17,36,1)
(301,44,1)
(352,401,1)
(282,246,1)
(0,404,1)
(130,149,1)
(109,180,1)
(68,353,1)
(295,0,1)
(224,4,1)
(381,101,1)
(52,193,1)
(398,311,1)
(264,31,1)
(70,89,1)
(219,134,1)
(135,153,1)
(106,414,1)
(133,129,1)
(94,226,1)
(18,327,1)
(240,311,1)
(101,382,1)
(332,249,1)
(152,224,1)
(187,23,1)
(88,76,1)
(274,335,1)
(56,225,1)
(361,311,1)
(272,339,1)
(113,270,1)
(392,295,1)
(50,216,1)
(104,89,1)
(233,280,1)
(71,319,1)
(82,235,1)
(228,213,1)
(19,283,1)
(202,297,1)
(384,367,1)
(405,276,1)
(13,17,1)
(0,348,1)
(125,210,1)
(281,210,1)
(2,131,1)
(344,23,1)
(108,115,1)
(245,19,1)
(216,332,1)
(240,44,1)
(246,201,1)
(82,9,1)
(229,287,1)
(68,409,1)
(397,89,1)
(42,12,1)
(149,385,1)
(49,355,1)
(303,408,1)
(104,159,1)
(165,8,1)
(140,45,1)
(381,191,1)
(415,411,1)
(86,118,1)
(159,163,1)
(77,131,1)
(213,116,1)
(361,44,1)
(206,195,1)
(185,146,1)
(303,52,1)
(232,178,1)
(157,311,1)
(221,413,1)
(211,44,1)
(26,241,1)
(274,23,1)
(220,285,1)
(393,243,1)
(21,228,1)
(25,213,1)
(377,348,1)
(200,375,1)
(391,176,1)
(348,416,1)
(9,236,1)
(255,83,1)
(111,75,1)
(35,44,1)
(88,210,1)
(103,303,1)
(23,244,1)
(114,230,1)
(92,44,1)
(92,89,1)
(132,369,1)
(282,210,1)
(324,337,1)
(116,279,1)
(7,22,1)
(264,373,1)
(75,16,1)
(149,252,1)
(119,164,1)
(299,231,1)
(320,198,1)
(248,340,1)
(127,311,1)
(51,74,1)
(118,223,1)
(338,166,1)
(1,59,1)
(347,205,1)
(52,311,1)
(235,9,1)
(100,311,1)
(370,415,1)
(339,61,1)
(406,207,1)
(416,13,1)
(150,42,1)
(411,321,1)
(385,89,1)
(32,158,1)
(222,363,1)
(153,380,1)
(100,329,1)
(373,86,1)
(162,107,1)
(74,173,1)
(385,44,1)
(301,311,1)
(278,221,1)
(418,272,1)
(409,1,1)
(194,175,1)
(100,89,1)
(168,296,1)
(90,301,1)
(221,271,1)
(53,326,1)
(146,371,1)
(410,303,1)
(195,147,1)
(287,124,1)
(30,104,1)
(111,44,1)
(234,161,1)
(150,311,1)
(296,219,1)
(188,272,1)
(382,291,1)
(323,407,1)
(152,198,1)
(355,403,1)
(68,100,1)
(220,82,1)
(35,311,1)
(271,71,1)
(81,392,1)
(291,390,1)
(16,388,1)
(319,167,1)
(270,81,1)
(345,126,1)
(391,400,1)
(78,72,1)
(312,68,1)
(276,2,1)
(138,50,1)
(39,251,1)
(308,139,1)
(313,270,1)
(379,151,1)
(284,247,1)
(198,64,1)
(200,23,1)
(240,309,1)
(72,384,1)
(220,94,1)
(100,44,1)
(271,293,1)
(286,126,1)
(394,334,1)
(301,89,1)
(388,243,1)
(385,204,1)
(179,311,1)
(196,199,1)
(63,123,1)
(52,44,1)
(340,44,1)
(292,349,1)
(34,175,1)
(167,171,1)
(236,65,1)
(350,11,1)
(274,305,1)
(416,408,1)
(377,5,1)
(315,179,1)
(383,211,1)
(8,91,1)
(163,92,1)
(201,239,1)
(122,282,1)
(214,383,1)
(238,6,1)
(211,155,1)
(41,254,1)
(330,220,1)
(259,89,1)
(208,365,1)
(112,125,1)
(193,93,1)
(327,44,1)
(198,14,1)
(329,108,1)
(189,165,1)
(127,89,1)
(220,101,1)
(414,152,1)
(398,89,1)
(65,366,1)
(369,302,1)
(409,46,1)
(76,85,1)
(241,415,1)
(251,261,1)
(242,71,1)
(123,161,1)
(398,162,1)
(84,128,1)
(126,377,1)
(261,150,1)
(295,192,1)
(154,44,1)
(123,348,1)
(385,311,1)
(65,348,1)
(6,132,1)
(211,89,1)
(330,229,1)
(298,419,1)
(70,44,1)
(78,245,1)
(131,399,1)
(186,117,1)
(286,345,1)
(411,314,1)
(187,250,1)
(419,72,1)
(263,306,1)
(1,311,1)
(175,348,1)
(371,110,1)
(350,89,1)
(31,373,1)
(154,89,1)
(404,33,1)
(285,232,1)
(183,418,1)
(275,143,1)
(357,398,1)
(400,385,1)
(83,351,1)
(403,56,1)
(259,44,1)
(129,274,1)
(244,200,1)
(343,112,1)
(371,233,1)
(327,311,1)
(141,43,1)
(335,318,1)
(339,121,1)
(16,102,1)
(155,299,1)
(233,314,1)
(149,211,1)
(403,190,1)
(340,89,1)
(322,63,1)
(377,96,1)
(396,242,1)
(231,35,1)
(217,353,1)
(177,398,1)
(199,261,1)
(123,234,1)
(243,157,1)
(386,16,1)
(397,189,1)
(85,292,1)
(327,89,1)
(400,168,1)
(407,61,1)
(43,222,1)
(268,344,1)
(247,43,1)
(115,266,1)
(226,113,1)
(272,199,1)
(340,311,1)
(380,18,1)
(1,89,1)
(132,302,1)
(240,89,1)
(89,187,1)
(279,34,1)
(103,308,1)
(124,284,1)
(137,130,1)
(47,333,1)
(1,44,1)
(294,317,1)
(200,364,1)
(230,199,1)
(199,298,1)
(326,408,1)
(5,324,1)
(302,374,1)
(36,111,1)
(359,294,1)
(363,158,1)
(2,77,1)
(44,259,1)
(175,103,1)
(244,256,1)
(68,127,1)
(12,288,1)
(59,217,1)
(281,347,1)
(107,409,1)
(253,104,1)
(250,307,1)
(191,237,1)
(24,15,1)
(309,387,1)
(337,194,1)
(328,377,1)
(63,67,1)
(361,89,1)
(192,0,1)
(15,268,1)
(224,120,1)
(74,342,1)
(154,386,1)
(378,188,1)
(45,87,1)
(156,202,1)
(178,78,1)
(213,261,1)
(184,224,1)
(253,135,1)
(97,269,1)
(176,119,1)
(203,216,1)
(333,140,1)
(170,145,1)
(258,314,1)
(325,412,1)
(28,106,1)
(259,311,1)
(93,379,1)
(40,367,1)
(134,208,1)
(68,357,1)
(150,89,1)
(139,410,1)
(391,119,1)
(353,83,1)
(398,44,1)
(350,44,1)
(266,127,1)
(111,311,1)
(264,23,1)
(102,408,1)
(14,64,1)
(230,322,1)
(413,396,1)
(262,342,1)
(70,311,1)
(412,23,1)
(143,400,1)
(327,55,1)
(47,253,1)
(169,240,1)
(397,311,1)
(104,311,1)
(50,203,1)
(154,311,1)
(249,417,1)
(171,371,1)
(210,278,1)
(415,227,1)
(35,89,1)
(368,182,1)
(70,20,1)
(389,206,1)
(111,89,1)
(277,320,1)
(211,311,1)
(48,260,1)
(55,30,1)
(102,170,1)
(271,37,1)
(209,262,1)
(215,357,1)
(83,408,1)
(110,233,1)
(237,92,1)
(284,88,1)
(61,261,1)
(152,101,1)
(68,169,1)
(296,134,1)
(225,133,1)
(20,39,1)
(252,275,1)
(239,32,1)
(147,4,1)
(145,79,1)
(269,248,1)
(61,397,1)
(124,122,1)
(400,211,1)
(151,348,1)
(314,114,1)
(10,338,1)
(370,293,1)
(325,129,1)
(212,258,1)
(91,196,1)
(143,361,1)
(204,312,1)
(220,295,1)
(401,313,1)
(388,393,1)
(160,413,1)
(346,84,1)
(318,24,1)
(135,327,1)
(367,362,1)
(300,183,1)
(256,200,1)
(164,97,1)
(362,286,1)
(366,395,1)
(280,370,1)
(344,260,1)
(364,375,1)
(283,142,1)
(117,346,1)
(29,263,1)
(397,44,1)
(321,54,1)
(152,29,1)
(338,325,1)
(408,51,1)
(182,359,1)
(9,65,1)
(259,41,1)
(54,37,1)
(87,253,1)
(271,160,1)
(353,255,1)
(352,72,1)
(149,166,1)
(171,186,1)
(293,26,1)
(306,184,1)
(91,199,1)
(126,328,1)
(315,211,1)
(384,267,1)
(301,264,1)
(400,166,1)
(58,388,1)
(267,367,1)
(354,385,1)
(384,40,1)
(399,197,1)
(68,101,1)
(390,268,1)
(361,391,1)
(33,285,1)
(268,297,1)
(173,209,1)
(68,240,1)
(361,391,2)
(233,272,2)
(326,47,2)
(186,272,2)
(319,171,2)
(260,297,2)
(253,92,2)
(388,47,2)
(361,44,2)
(412,268,2)
(193,16,2)
(229,272,2)
(373,47,2)
(173,47,2)
(150,89,2)
(392,229,2)
(241,415,2)
(211,311,2)
(269,47,2)
(362,175,2)
(379,16,2)
(137,143,2)
(8,175,2)
(408,51,2)
(217,16,2)
(398,44,2)
(419,175,2)
(325,268,2)
(122,282,2)
(341,47,2)
(199,261,2)
(124,122,2)
(243,157,2)
(139,16,2)
(123,272,2)
(284,158,2)
(157,89,2)
(285,229,2)
(272,175,2)
(200,23,2)
(110,272,2)
(196,272,2)
(182,359,2)
(210,221,2)
(159,92,2)
(150,44,2)
(374,301,2)
(246,158,2)
(5,175,2)
(94,229,2)
(418,272,2)
(344,297,2)
(259,44,2)
(391,119,2)
(231,35,2)
(0,229,2)
(259,89,2)
(68,409,2)
(233,314,2)
(318,268,2)
(311,47,2)
(259,47,2)
(240,16,2)
(150,47,2)
(134,361,2)
(369,301,2)
(43,158,2)
(130,143,2)
(50,216,2)
(230,272,2)
(267,367,2)
(119,47,2)
(301,44,2)
(68,357,2)
(1,44,2)
(187,23,2)
(68,100,2)
(35,143,2)
(247,210,2)
(259,311,2)
(23,268,2)
(145,388,2)
(68,240,2)
(346,272,2)
(248,301,2)
(0,348,2)
(186,117,2)
(268,268,2)
(219,361,2)
(247,43,2)
(240,311,2)
(214,47,2)
(337,175,2)
(274,335,2)
(220,229,2)
(135,327,2)
(327,44,2)
(124,158,2)
(302,301,2)
(266,16,2)
(84,272,2)
(104,311,2)
(21,16,2)
(29,138,2)
(314,272,2)
(104,92,2)
(111,89,2)
(312,47,2)
(410,175,2)
(398,311,2)
(154,44,2)
(228,213,2)
(364,268,2)
(12,47,2)
(51,74,2)
(327,92,2)
(220,82,2)
(70,311,2)
(361,47,2)
(335,268,2)
(236,229,2)
(37,272,2)
(10,268,2)
(44,47,2)
(370,272,2)
(313,229,2)
(149,143,2)
(36,16,2)
(103,175,2)
(215,16,2)
(350,311,2)
(261,47,2)
(188,175,2)
(61,272,2)
(339,121,2)
(68,353,2)
(391,400,2)
(371,233,2)
(128,272,2)
(407,175,2)
(314,114,2)
(157,47,2)
(142,229,2)
(83,16,2)
(401,229,2)
(279,16,2)
(282,210,2)
(315,47,2)
(157,311,2)
(58,388,2)
(164,47,2)
(112,221,2)
(102,388,2)
(67,272,2)
(88,247,2)
(82,9,2)
(377,348,2)
(416,408,2)
(175,175,2)
(96,175,2)
(239,158,2)
(251,47,2)
(88,76,2)
(42,47,2)
(127,44,2)
(221,272,2)
(88,210,2)
(384,367,2)
(1,311,2)
(330,272,2)
(325,129,2)
(123,161,2)
(301,89,2)
(149,211,2)
(348,16,2)
(189,272,2)
(82,229,2)
(187,307,2)
(113,270,2)
(39,47,2)
(220,94,2)
(338,268,2)
(104,44,2)
(146,272,2)
(285,178,2)
(53,47,2)
(240,44,2)
(395,229,2)
(176,47,2)
(125,221,2)
(278,221,2)
(91,272,2)
(270,199,2)
(296,361,2)
(323,175,2)
(323,272,2)
(244,200,2)
(70,89,2)
(340,301,2)
(111,16,2)
(301,47,2)
(357,398,2)
(74,342,2)
(378,348,2)
(226,229,2)
(287,124,2)
(383,47,2)
(65,229,2)
(71,171,2)
(138,50,2)
(343,221,2)
(93,175,2)
(348,416,2)
(56,268,2)
(68,228,2)
(61,261,2)
(400,166,2)
(227,272,2)
(175,16,2)
(400,385,2)
(301,264,2)
(224,4,2)
(183,272,2)
(193,175,2)
(16,388,2)
(196,199,2)
(169,16,2)
(157,44,2)
(35,44,2)
(281,210,2)
(19,229,2)
(295,229,2)
(344,23,2)
(70,44,2)
(254,47,2)
(244,268,2)
(90,301,2)
(305,268,2)
(327,311,2)
(107,16,2)
(135,153,2)
(339,175,2)
(117,346,2)
(122,158,2)
(150,311,2)
(248,340,2)
(272,339,2)
(111,44,2)
(388,243,2)
(47,333,2)
(178,229,2)
(35,89,2)
(355,268,2)
(409,16,2)
(361,311,2)
(345,175,2)
(194,175,2)
(411,272,2)
(284,247,2)
(243,47,2)
(162,16,2)
(415,272,2)
(385,44,2)
(350,44,2)
(262,47,2)
(232,229,2)
(47,253,2)
(1,16,2)
(149,385,2)
(339,61,2)
(280,272,2)
(175,348,2)
(161,272,2)
(16,102,2)
(361,89,2)
(25,16,2)
(299,47,2)
(29,263,2)
(357,16,2)
(293,415,2)
(31,47,2)
(351,16,2)
(303,408,2)
(72,175,2)
(282,158,2)
(411,314,2)
(34,16,2)
(170,388,2)
(180,47,2)
(384,175,2)
(79,388,2)
(13,16,2)
(230,63,2)
(109,47,2)
(6,301,2)
(48,297,2)
(61,397,2)
(200,375,2)
(230,199,2)
(52,311,2)
(222,158,2)
(85,247,2)
(409,1,2)
(270,229,2)
(240,89,2)
(52,89,2)
(81,229,2)
(9,65,2)
(258,272,2)
(93,16,2)
(281,282,2)
(347,282,2)
(18,92,2)
(213,16,2)
(253,104,2)
(303,16,2)
(296,134,2)
(152,101,2)
(333,140,2)
(59,16,2)
(295,0,2)
(350,89,2)
(350,47,2)
(178,78,2)
(75,16,2)
(163,92,2)
(403,56,2)
(264,248,2)
(221,413,2)
(165,272,2)
(377,5,2)
(271,413,2)
(135,92,2)
(32,158,2)
(49,268,2)
(344,260,2)
(141,158,2)
(288,47,2)
(189,175,2)
(124,221,2)
(396,272,2)
(397,272,2)
(104,89,2)
(68,127,2)
(385,47,2)
(40,367,2)
(400,361,2)
(352,72,2)
(271,37,2)
(100,44,2)
(115,16,2)
(87,92,2)
(416,16,2)
(127,311,2)
(165,175,2)
(300,272,2)
(78,229,2)
(2,131,2)
(264,23,2)
(366,229,2)
(114,272,2)
(367,175,2)
(192,229,2)
(308,16,2)
(30,92,2)
(126,175,2)
(120,394,2)
(122,281,2)
(209,47,2)
(394,389,2)
(234,272,2)
(108,16,2)
(65,348,2)
(158,221,2)
(253,135,2)
(15,268,2)
(140,92,2)
(349,247,2)
(281,347,2)
(44,259,2)
(124,284,2)
(297,268,2)
(100,311,2)
(51,47,2)
(74,173,2)
(268,344,2)
(322,272,2)
(17,16,2)
(352,229,2)
(68,16,2)
(292,247,2)
(171,272,2)
(221,271,2)
(235,229,2)
(363,158,2)
(274,268,2)
(89,187,2)
(379,175,2)
(386,16,2)
(1,89,2)
(200,268,2)
(117,272,2)
(168,361,2)
(102,170,2)
(152,198,2)
(47,92,2)
(149,166,2)
(199,175,2)
(256,268,2)
(213,261,2)
(282,201,2)
(132,301,2)
(385,311,2)
(268,297,2)
(111,311,2)
(375,268,2)
(255,16,2)
(243,408,2)
(365,361,2)
(7,282,2)
(153,92,2)
(275,143,2)
(311,350,2)
(264,47,2)
(287,221,2)
(397,175,2)
(57,16,2)
(340,44,2)
(328,175,2)
(52,175,2)
(103,303,2)
(121,272,2)
(152,224,2)
(46,16,2)
(185,272,2)
(252,143,2)
(261,150,2)
(76,247,2)
(224,120,2)
(284,88,2)
(118,47,2)
(303,175,2)
(327,89,2)
(220,285,2)
(228,16,2)
(339,272,2)
(156,297,2)
(154,311,2)
(143,47,2)
(151,16,2)
(101,382,2)
(126,377,2)
(208,361,2)
(220,101,2)
(391,47,2)
(397,89,2)
(33,229,2)
(74,47,2)
(286,126,2)
(308,175,2)
(121,175,2)
(204,47,2)
(154,89,2)
(205,282,2)
(400,211,2)
(113,352,2)
(100,89,2)
(301,311,2)
(283,229,2)
(393,47,2)
(63,123,2)
(92,92,2)
(133,268,2)
(61,175,2)
(408,47,2)
(403,268,2)
(340,311,2)
(167,171,2)
(271,293,2)
(16,47,2)
(9,229,2)
(220,295,2)
(342,47,2)
(152,29,2)
(86,47,2)
(83,408,2)
(139,175,2)
(264,373,2)
(340,89,2)
(324,175,2)
(91,175,2)
(97,47,2)
(321,272,2)
(20,47,2)
(286,175,2)
(23,244,2)
(155,47,2)
(274,23,2)
(127,16,2)
(398,89,2)
(329,16,2)
(160,413,2)
(68,101,2)
(381,101,2)
(378,175,2)
(190,268,2)
(52,16,2)
(202,297,2)
(410,16,2)
(52,44,2)
(179,47,2)
(132,302,2)
(152,2,2)
(211,89,2)
(398,16,2)
(24,268,2)
(354,47,2)
(272,199,2)
(55,92,2)
(272,272,2)
(387,16,2)
(397,44,2)
(72,384,2)
(78,72,2)
(377,175,2)
(8,272,2)
(129,274,2)
(41,47,2)
(413,272,2)
(407,272,2)
(113,229,2)
(201,158,2)
(223,47,2)
(404,229,2)
(303,52,2)
(54,272,2)
(371,272,2)
(35,311,2)
(94,113,2)
(271,71,2)
(211,47,2)
(385,89,2)
(178,199,2)
(70,47,2)
(367,286,2)
(333,92,2)
(45,92,2)
(397,311,2)
(63,272,2)
(353,83,2)
(22,282,2)
(212,272,2)
(116,16,2)
(242,272,2)
(103,16,2)
(11,47,2)
(238,301,2)
(353,16,2)
(102,408,2)
(114,230,2)
(247,158,2)
(51,70,2)
(127,89,2)
(309,16,2)
(154,16,2)
(245,229,2)
(123,348,2)
(129,268,2)
(103,308,2)
(100,16,2)
(175,103,2)
(177,16,2)
(26,415,2)
(315,211,2)
(198,64,2)
(380,92,2)
(211,44,2)
(298,175,2)
(171,186,2)
(415,411,2)
(151,175,2)
(171,371,2)
(225,268,2)
(231,143,2)
-----------------------------------
(0,y * cell_height)
(1,img->width)
(2,rc.left + PADDING)
(3,for (int y = max(0, top)
(4,rc.left)
(5,term.displines)
(6,img)
(7,term)
(8,left)
(9,(y + 1)
(10,TEMPFILE_MAX_NUM)
(11,next)
(12,img)
(13,top)
(14,PADDING)
(15,img)
(16,top + img->height < 0 || top > term.rows)
(17,0)
(18,term)
(19,wide_factor)
(20,top)
(21,top)
(22,scrpos)
(23,term.imgs.first = term.imgs.first->next)
(24,term)
(25,PADDING)
(26,true)
(27,dchar)
(28,imgs)
(29,rc.top + PADDING + term.rows * cell_height)
(30,img)
(31,first)
(32,term)
(33,y)
(34,dc)
(35,img->next)
(36,y)
(37,update_flag = false)
(38,rc)
(39,img)
(40,2)
(41,next)
(42,left)
(43,term.sel_start)
(44,img = img->next)
(45,sblines)
(46,cell_width)
(47,img->top + img->height - term.virtuallines < - term.sblines)
(48,first)
(49,imgs)
(50,term.rows * cell_height)
(51,img->top - term.virtuallines - term.disptop)
(52,img->height)
(53,img)
(54,dchar)
(55,height)
(56,term.imgs)
(57,hdc)
(58,top)
(59,width)
(60,while (tempfile_num > TEMPFILE_MAX_NUM && term.imgs.first)
(61,left + img->width)
(62,update_flag)
(63,term.displines[y]->chars)
(64,rc.top)
(65,y + 1)
(66,if (dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED)
(67,chars)
(68,StretchBlt(dc, left * cell_width + PADDING, top * cell_height + PADDING,\n\\n                   img->width * cell_width, img->height * cell_height, img->hdc,\n\\n                   0, 0, img->pixelwidth, img->pixelheight, SRCCOPY)
(69,)
(70,img->top)
(71,update_flag = true)
(72,wide_factor = (term.displines[y]->lattr & LATTR_MODE)
(73,if (dchar->chr != SIXELCH)
(74,term.virtuallines - term.disptop)
(75,img)
(76,term.sel_end)
(77,PADDING)
(78,wide_factor * cell_width)
(79,term)
(80,)
(81,1)
(82,(y + 1)
(83,top * cell_height)
(84,TATTR_CURMARKED)
(85,sel_end)
(86,imgs)
(87,term)
(88,poslt(scrpos, term.sel_end)
(89,img = term.imgs.first)
(90,term)
(91,x)
(92,img)
(93,img)
(94,(x + 1)
(95,top)
(96,y)
(97,term)
(98,)
(99,prev)
(100,img->pixelwidth)
(101,dc = GetDC(wnd)
(102,top > term.rows)
(103,min(top + img->height, term.rows)
(104,img->top)
(105,)
(106,term)
(107,img)
(108,img)
(109,virtuallines)
(110,attr)
(111,winimg_lazyinit(img)
(112,term)
(113,(x + 1)
(114,&term.displines[y]->chars[x])
(115,0)
(116,cell_width)
(117,TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED)
(118,term)
(119,term.imgs)
(120,PADDING + term.cols * cell_width)
(121,term.cols)
(122,posPle(term.sel_start, scrpos)
(123,term.displines[y])
(124,term.sel_rect\n\\n                  ? posPle(term.sel_start, scrpos)
(125,update_flag)
(126,term.displines[y]->lattr)
(127,img->hdc)
(128,TATTR_MARKED)
(129,img = term.imgs.first)
(130,img)
(131,rc.left)
(132,term.imgs.first)
(133,term)
(134,term.imgs)
(135,img->height - term.virtuallines)
(136,dc)
(137,next)
(138,PADDING + term.rows * cell_height)
(139,rows)
(140,term.sblines)
(141,scrpos)
(142,dc)
(143,prev)
(144,)
(145,rows)
(146,TATTR_RESULT)
(147,PADDING)
(148,if (img == term.imgs.first)
(149,prev->next)
(150,img->left)
(151,y)
(152,IntersectClipRect(dc, rc.left + PADDING, rc.top + PADDING,\n\\n                    rc.left + PADDING + term.cols * cell_width,\n\\n                    rc.top + PADDING + term.rows * cell_height)
(153,term.virtuallines)
(154,winimg_hibernate(img)
(155,img)
(156,imgs)
(157,img->height)
(158,term.sel_rect)
(159,top)
(160,update_flag)
(161,term.displines)
(162,height)
(163,img)
(164,imgs)
(165,img)
(166,*prev = NULL)
(167,update_flag)
(168,prev)
(169,SRCCOPY)
(170,term.rows)
(171,dchar->attr.attr & (TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED)
(172,)
(173,term.disptop)
(174,)
(175,y < min(top + img->height, term.rows)
(176,last)
(177,cell_height)
(178,x * wide_factor * cell_width)
(179,prev)
(180,term)
(181,for (img = term.imgs.first; img;)
(182,GetClientRect(wnd, &rc)
(183,term)
(184,rc)
(185,TATTR_CURRESULT)
(186,TATTR_RESULT | TATTR_CURRESULT | TATTR_MARKED | TATTR_CURMARKED)
(187,term.imgs.first)
(188,y)
(189,width)
(190,first)
(191,dc)
(192,PADDING)
(193,height)
(194,wide_factor)
(195,term)
(196,++x)
(197,rc)
(198,rc.top + PADDING)
(199,x = left)
(200,term.imgs.first)
(201,term.sel_start)
(202,term)
(203,cell_height)
(204,img)
(205,sel_end)
(206,cols)
(207,prev)
(208,imgs)
(209,disptop)
(210,scrpos = {y + term.disptop, x, false})
(211,prev = img)
(212,false)
(213,left * cell_width)
(214,img)
(215,img)
(216,term.rows)
(217,img)
(218,y)
(219,last)
(220,ExcludeClipRect(dc,\n\\n                              x * wide_factor * cell_width + PADDING,\n\\n                              y * cell_height + PADDING,\n\\n                              (x + 1)
(221,term.selected && !update_flag)
(222,sel_start)
(223,img)
(224,rc.left + PADDING + term.cols * cell_width)
(225,imgs)
(226,PADDING)
(227,SIXELCH)
(228,left * cell_width + PADDING)
(229,update_flag)
(230,term.displines[y]->chars[x])
(231,prev->next = img->next)
(232,PADDING)
(233,dchar->attr)
(234,y)
(235,PADDING)
(236,cell_height)
(237,wnd)
(238,next)
(239,sel_start)
(240,img->pixelheight)
(241,update_flag)
(242,term)
(243,top + img->height)
(244,term.imgs.first->next)
(245,cell_width)
(246,scrpos)
(247,posle(term.sel_start, scrpos)
(248,term.imgs.first = img->next)
(249,term)
(250,first)
(251,top)
(252,next)
(253,img->top + img->height - term.virtuallines)
(254,img)
(255,PADDING)
(256,next)
(257,wide_factor)
(258,update_flag)
(259,img->next)
(260,term.imgs)
(261,left = img->left)
(262,term)
(263,rc.top)
(264,term.imgs.first)
(265,if (img == term.imgs.last)
(266,0)
(267,1)
(268,tempfile_num > TEMPFILE_MAX_NUM && term.imgs.first)
(269,img)
(270,x + 1)
(271,!update_flag)
(272,x < min(left + img->width, term.cols)
(273,x)
(274,term.imgs.first)
(275,prev)
(276,rc)
(277,left)
(278,scrpos)
(279,left)
(280,attr)
(281,posPlt(scrpos, term.sel_end)
(282,posPle(term.sel_start, scrpos)
(283,x)
(284,posle(term.sel_start, scrpos)
(285,x * wide_factor * cell_width + PADDING)
(286,term.displines[y]->lattr & LATTR_MODE)
(287,update_flag = term.sel_rect\n\\n                  ? posPle(term.sel_start, scrpos)
(288,left)
(289,if (prev)
(290,if (top + img->height < 0 || top > term.rows)
(291,wnd)
(292,term)
(293,update_flag = true)
(294,rc)
(295,y * cell_height + PADDING)
(296,term.imgs.last)
(297,tempfile_num > TEMPFILE_MAX_NUM)
(298,left)
(299,prev)
(300,displines)
(301,img == term.imgs.first)
(302,term.imgs)
(303,top + img->height)
(304,if (img->top + img->height - term.virtuallines < - term.sblines)
(305,first)
(306,top)
(307,term.imgs)
(308,term.rows)
(309,pixelheight)
(310,if (term.selected && !update_flag)
(311,img = img->next)
(312,prev)
(313,wide_factor)
(314,*dchar = &term.displines[y]->chars[x])
(315,winimg_destroy(prev)
(316,scrpos)
(317,wnd)
(318,imgs)
(319,true)
(320,rc)
(321,chr)
(322,x)
(323,cols)
(324,displines)
(325,winimg_destroy(img)
(326,top)
(327,img->height)
(328,lattr)
(329,pixelwidth)
(330,x)
(331,img)
(332,rows)
(333,- term.sblines)
(334,cell_width)
(335,term.imgs)
(336,left)
(337,term)
(338,tempfile_num)
(339,min(left + img->width, term.cols)
(340,img->next)
(341,height)
(342,term.virtuallines)
(343,sel_rect)
(344,term.imgs.first)
(345,LATTR_MODE)
(346,TATTR_MARKED | TATTR_CURMARKED)
(347,term.sel_end)
(348,y = max(0, top)
(349,scrpos)
(350,img->next)
(351,cell_height)
(352,wide_factor * cell_width)
(353,top * cell_height + PADDING)
(354,img)
(355,term)
(356,)
(357,img->height * cell_height)
(358,)
(359,&rc)
(360,RET)
(361,img == term.imgs.last)
(362,LATTR_NORM)
(363,term)
(364,first)
(365,term)
(366,1)
(367,(term.displines[y]->lattr & LATTR_MODE)
(368,dc)
(369,first)
(370,dchar)
(371,dchar->attr.attr)
(372,if (update_flag)
(373,term.imgs)
(374,imgs)
(375,term.imgs)
(376,)
(377,term.displines[y])
(378,++y)
(379,top)
(380,virtuallines)
(381,ReleaseDC(wnd, dc)
(382,GetDC(wnd)
(383,img)
(384,(term.displines[y]->lattr & LATTR_MODE)
(385,prev = img)
(386,img)
(387,img)
(388,top + img->height < 0)
(389,term.cols)
(390,dc)
(391,term.imgs.last)
(392,x)
(393,0)
(394,term.cols * cell_width)
(395,y)
(396,selected)
(397,img->width)
(398,img->height)
(399,left)
(400,term.imgs.last = prev)
(401,cell_width)
(402,for (int x = left; x < min(left + img->width, term.cols)
(403,term.imgs.first)
(404,cell_height)
(405,top)
(406,NULL)
(407,term)
(408,top = img->top - term.virtuallines - term.disptop)
(409,img->width * cell_width)
(410,term)
(411,dchar->chr)
(412,img)
(413,term.selected)
(414,img)
(415,dchar->chr != SIXELCH)
(416,max(0, top)
(417,PADDING)
(418,dchar)
(419,x)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^