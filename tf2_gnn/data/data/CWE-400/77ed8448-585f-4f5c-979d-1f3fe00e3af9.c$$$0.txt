-----label-----
0
-----code-----
int do_copyfd(void)
{
/* Copy a file descriptor between processes, or close a remote file descriptor.
 * This call is used as back-call by device drivers (UDS, VND), and is expected
 * to be used in response to an IOCTL to such device drivers.
 */
  struct fproc *rfp;
  struct filp *rfilp;
  struct vnode *vp;
  struct smap *sp;
  endpoint_t endpt;
  int r, fd, what, slot;

  /* This should be replaced with an ACL check. */
  if (!super_user) return(EPERM);

  endpt = job_m_in.m_lsys_vfs_copyfd.endpt;
  fd = job_m_in.m_lsys_vfs_copyfd.fd;
  what = job_m_in.m_lsys_vfs_copyfd.what;

  if (isokendpt(endpt, &slot) != OK) return(EINVAL);
  rfp = &fproc[slot];

  /* FIXME: we should now check that the user process is indeed blocked on an
   * IOCTL call, so that we can safely mess with its file descriptors.  We
   * currently do not have the necessary state to verify this, so we assume
   * that the call is always used in the right way.
   */

  /* Depending on the operation, get the file descriptor from the caller or the
   * user process.  Do not lock the filp yet: we first need to make sure that
   * locking it will not result in a deadlock.
   */
  rfilp = get_filp2((what == COPYFD_TO) ? fp : rfp, fd, VNODE_NONE);
  if (rfilp == NULL)
	return(err_code);

  /* If the filp is involved in an IOCTL by the user process, locking the filp
   * here would result in a deadlock.  This would happen if a user process
   * passes in the file descriptor to the device node on which it is performing
   * the IOCTL.  We do not allow manipulation of such device nodes.  In
   * practice, this only applies to block-special files (and thus VND), because
   * character-special files (as used by UDS) are unlocked during the IOCTL.
   */
  if (rfilp->filp_ioctl_fp == rfp)
	return(EBADF);

  /* Now we can safely lock the filp, copy or close it, and unlock it again. */
  lock_filp(rfilp, VNODE_READ);

  switch (what) {
  case COPYFD_FROM:
	/*
	 * If the caller is a socket driver (namely, UDS) and the file
	 * descriptor being copied in is a socket for that socket driver, then
	 * deny the call, because of at least two known issues.  Both issues
	 * are related to UDS having an in-flight file descriptor that is the
	 * last reference to a UDS socket:
	 *
	 * 1) if UDS tries to close the file descriptor, this will prompt VFS
	 *    to close the underlying object, which is a UDS socket.  As a
	 *    result, while UDS is blocked in the close(2), VFS will try to
	 *    send a request to UDS to close the socket.  This results in a
	 *    deadlock of the UDS service.
	 *
	 * 2) if a file descriptor for a UDS socket is sent across that same
	 *    UDS socket, the socket will remain referenced by UDS, thus open
	 *    in VFS, and therefore also open in UDS.  The socket and file
	 *    descriptor will both remain in use for the rest of UDS' lifetime.
	 *    This can easily result in denial-of-service in the UDS service.
	 *    The same problem can be triggered using multiple sockets that
	 *    have in-flight file descriptors referencing each other.
	 *
	 * A proper solution for these problems may consist of some form of
	 * "soft reference counting" where VFS does not count UDS having a
	 * filp open as a real reference.  That is tricky business, so for now
	 * we prevent any such problems with the check here.
	 */
	if ((vp = rfilp->filp_vno) != NULL && S_ISSOCK(vp->v_mode) &&
	    (sp = get_smap_by_dev(vp->v_sdev, NULL)) != NULL &&
	    sp->smap_endpt == who_e) {
		r = EDEADLK;

		break;
	}

	rfp = fp;

	/* FALLTHROUGH */
  case COPYFD_TO:
	/* Find a free file descriptor slot in the local or remote process. */
	for (fd = 0; fd < OPEN_MAX; fd++)
		if (rfp->fp_filp[fd] == NULL)
			break;

	/* If found, fill the slot and return the slot number. */
	if (fd < OPEN_MAX) {
		rfp->fp_filp[fd] = rfilp;
		rfilp->filp_count++;
		r = fd;
	} else
		r = EMFILE;

	break;

  case COPYFD_CLOSE:
	/* This should be used ONLY to revert a successful copy-to operation,
	 * and assumes that the filp is still in use by the caller as well.
	 */
	if (rfilp->filp_count > 1) {
		rfilp->filp_count--;
		rfp->fp_filp[fd] = NULL;
		r = OK;
	} else
		r = EBADF;

	break;

  default:
	r = EINVAL;
  }

  unlock_filp(rfilp);

  return(r);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
9,10
9,11
9,12
9,13
9,14
9,15
9,16
9,17
9,18
9,19
9,20
9,21
9,22
9,23
9,24
9,25
9,26
9,27
9,28
10,11
11,12
11,13
12,13
14,15
14,16
17,18
18,19
18,20
19,20
21,22
21,23
24,25
25,26
25,27
26,27
28,29
28,30
31,32
32,33
32,34
33,34
35,36
35,37
38,39
39,40
39,41
40,41
42,43
44,45
45,46
45,47
45,48
45,49
45,50
47,48
49,50
51,52
53,54
55,56
55,57
56,57
57,58
59,60
60,61
61,62
63,64
64,65
64,66
65,66
67,68
67,69
68,69
68,70
69,70
73,74
74,75
74,76
75,76
77,78
77,79
78,79
78,80
79,80
83,84
84,85
84,86
85,86
87,88
87,89
88,89
88,90
89,90
93,94
93,95
94,95
94,96
95,96
95,97
95,98
96,97
98,99
100,101
101,102
103,104
105,106
106,107
107,108
109,110
110,111
110,112
111,112
113,114
114,115
114,116
115,116
117,118
119,120
120,121
120,122
121,122
123,124
123,125
123,126
123,127
124,125
126,127
126,128
126,129
127,128
128,129
128,130
129,130
131,132
133,134
135,136
137,138
139,140
141,142
141,143
142,143
142,144
143,144
145,146
147,148
148,149
149,150
151,152
151,153
152,153
152,154
153,154
153,155
154,155
157,158
159,160
160,161
161,162
163,164
164,165
164,166
164,167
165,166
167,168
169,170
171,172
171,173
172,173
174,175
174,176
174,177
174,178
174,179
174,180
174,181
174,182
174,183
174,184
174,185
174,186
175,176
176,177
178,179
178,180
179,180
179,181
180,181
180,182
181,182
181,183
182,183
182,184
183,184
184,185
184,186
185,186
187,188
187,189
188,189
191,192
193,194
193,195
194,195
196,197
196,198
197,198
200,201
200,202
201,202
202,203
202,204
203,204
205,206
205,207
205,208
206,207
208,209
208,210
209,210
212,213
214,215
216,217
216,218
217,218
217,219
218,219
221,222
223,224
223,225
224,225
225,226
225,227
226,227
228,229
231,232
232,233
232,234
233,234
235,236
237,238
238,239
240,241
240,242
240,243
240,244
241,242
242,243
242,244
243,244
246,247
246,248
247,248
249,250
251,252
252,253
254,255
254,256
255,256
255,257
256,257
256,258
257,258
257,259
258,259
261,262
263,264
266,267
266,268
266,269
267,268
267,269
268,269
270,271
272,273
272,274
272,275
273,274
274,275
274,276
275,276
275,277
276,277
276,278
277,278
280,281
282,283
284,285
285,286
286,287
286,288
287,288
290,291
291,292
291,293
292,293
294,295
296,297
297,298
297,299
298,299
300,301
303,304
304,305
306,307
306,308
306,309
307,308
307,309
308,309
308,310
309,310
313,314
313,315
313,316
314,315
315,316
316,317
316,318
317,318
320,321
321,322
321,323
322,323
322,324
323,324
323,325
324,325
327,328
329,330
331,332
332,333
332,334
333,334
335,336
337,338
338,339
338,340
339,340
341,342
345,346
346,347
346,348
347,348
349,350
351,352
352,353
352,354
353,354
355,356
357,358
358,359
359,360
-----nextToken-----
2,4,6,8,13,15,16,20,22,23,27,29,30,34,36,37,41,43,46,48,50,52,54,58,62,66,70,71,72,76,80,81,82,86,90,91,92,97,99,102,104,108,112,116,118,122,125,130,132,134,136,138,140,144,146,150,155,156,158,162,166,168,170,173,177,186,189,190,192,195,198,199,204,207,210,211,213,215,219,220,222,227,229,230,234,236,239,244,245,248,250,253,259,260,262,264,265,269,271,278,279,281,283,288,289,293,295,299,301,302,305,310,311,312,318,319,325,326,328,330,334,336,340,342,343,344,348,350,354,356,360
-----computeFrom-----
64,65
64,66
74,75
74,76
84,85
84,86
94,95
94,96
110,111
110,112
120,121
120,122
128,129
128,130
142,143
142,144
152,153
152,154
179,180
179,181
180,181
180,182
181,182
181,183
182,183
182,184
184,185
184,186
200,201
200,202
202,203
202,204
216,217
216,218
225,226
225,227
232,233
232,234
242,243
242,244
246,247
246,248
255,256
255,257
267,268
267,269
274,275
274,276
291,292
291,293
297,298
297,299
307,308
307,309
321,322
321,323
332,333
332,334
338,339
338,340
346,347
346,348
-----guardedBy-----
269,295
311,319
310,318
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;Declarator;Name;Declarator;Name;Declarator;Name;IfStatement;UnaryExpression;IdExpression;Name;ReturnStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;ConditionalExpression;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;SwitchStatement;IdExpression;Name;CompoundStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;BinaryExpression;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CaseStatement;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;BreakStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;BreakStatement;DefaultStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;IdExpression;Name;
-----ast_node-----
int do_copyfd(void){/* Copy a file descriptor between processes, or close a remote file descriptor. * This call is used as back-call by device drivers (UDS, VND), and is expected * to be used in response to an IOCTL to such device drivers. */  struct fproc *rfp;  struct filp *rfilp;  struct vnode *vp;  struct smap *sp;  endpoint_t endpt;  int r, fd, what, slot;  /* This should be replaced with an ACL check. */  if (!super_user) return(EPERM);  endpt = job_m_in.m_lsys_vfs_copyfd.endpt;  fd = job_m_in.m_lsys_vfs_copyfd.fd;  what = job_m_in.m_lsys_vfs_copyfd.what;  if (isokendpt(endpt, &slot) != OK) return(EINVAL);  rfp = &fproc[slot];  /* FIXME: we should now check that the user process is indeed blocked on an   * IOCTL call, so that we can safely mess with its file descriptors.  We   * currently do not have the necessary state to verify this, so we assume   * that the call is always used in the right way.   */  /* Depending on the operation, get the file descriptor from the caller or the   * user process.  Do not lock the filp yet: we first need to make sure that   * locking it will not result in a deadlock.   */  rfilp = get_filp2((what == COPYFD_TO) ? fp : rfp, fd, VNODE_NONE);  if (rfilp == NULL)	return(err_code);  /* If the filp is involved in an IOCTL by the user process, locking the filp   * here would result in a deadlock.  This would happen if a user process   * passes in the file descriptor to the device node on which it is performing   * the IOCTL.  We do not allow manipulation of such device nodes.  In   * practice, this only applies to block-special files (and thus VND), because   * character-special files (as used by UDS) are unlocked during the IOCTL.   */  if (rfilp->filp_ioctl_fp == rfp)	return(EBADF);  /* Now we can safely lock the filp, copy or close it, and unlock it again. */  lock_filp(rfilp, VNODE_READ);  switch (what) {  case COPYFD_FROM:	/*	 * If the caller is a socket driver (namely, UDS) and the file	 * descriptor being copied in is a socket for that socket driver, then	 * deny the call, because of at least two known issues.  Both issues	 * are related to UDS having an in-flight file descriptor that is the	 * last reference to a UDS socket:	 *	 * 1) if UDS tries to close the file descriptor, this will prompt VFS	 *    to close the underlying object, which is a UDS socket.  As a	 *    result, while UDS is blocked in the close(2), VFS will try to	 *    send a request to UDS to close the socket.  This results in a	 *    deadlock of the UDS service.	 *	 * 2) if a file descriptor for a UDS socket is sent across that same	 *    UDS socket, the socket will remain referenced by UDS, thus open	 *    in VFS, and therefore also open in UDS.  The socket and file	 *    descriptor will both remain in use for the rest of UDS' lifetime.	 *    This can easily result in denial-of-service in the UDS service.	 *    The same problem can be triggered using multiple sockets that	 *    have in-flight file descriptors referencing each other.	 *	 * A proper solution for these problems may consist of some form of	 * "soft reference counting" where VFS does not count UDS having a	 * filp open as a real reference.  That is tricky business, so for now	 * we prevent any such problems with the check here.	 */	if ((vp = rfilp->filp_vno) != NULL && S_ISSOCK(vp->v_mode) &&	    (sp = get_smap_by_dev(vp->v_sdev, NULL)) != NULL &&	    sp->smap_endpt == who_e) {		r = EDEADLK;		break;	}	rfp = fp;	/* FALLTHROUGH */  case COPYFD_TO:	/* Find a free file descriptor slot in the local or remote process. */	for (fd = 0; fd < OPEN_MAX; fd++)		if (rfp->fp_filp[fd] == NULL)			break;	/* If found, fill the slot and return the slot number. */	if (fd < OPEN_MAX) {		rfp->fp_filp[fd] = rfilp;		rfilp->filp_count++;		r = fd;	} else		r = EMFILE;	break;  case COPYFD_CLOSE:	/* This should be used ONLY to revert a successful copy-to operation,	 * and assumes that the filp is still in use by the caller as well.	 */	if (rfilp->filp_count > 1) {		rfilp->filp_count--;		rfp->fp_filp[fd] = NULL;		r = OK;	} else		r = EBADF;	break;  default:	r = EINVAL;  }  unlock_filp(rfilp);  return(r);}
int
do_copyfd(void)
do_copyfd
void
void


{/* Copy a file descriptor between processes, or close a remote file descriptor. * This call is used as back-call by device drivers (UDS, VND), and is expected * to be used in response to an IOCTL to such device drivers. */  struct fproc *rfp;  struct filp *rfilp;  struct vnode *vp;  struct smap *sp;  endpoint_t endpt;  int r, fd, what, slot;  /* This should be replaced with an ACL check. */  if (!super_user) return(EPERM);  endpt = job_m_in.m_lsys_vfs_copyfd.endpt;  fd = job_m_in.m_lsys_vfs_copyfd.fd;  what = job_m_in.m_lsys_vfs_copyfd.what;  if (isokendpt(endpt, &slot) != OK) return(EINVAL);  rfp = &fproc[slot];  /* FIXME: we should now check that the user process is indeed blocked on an   * IOCTL call, so that we can safely mess with its file descriptors.  We   * currently do not have the necessary state to verify this, so we assume   * that the call is always used in the right way.   */  /* Depending on the operation, get the file descriptor from the caller or the   * user process.  Do not lock the filp yet: we first need to make sure that   * locking it will not result in a deadlock.   */  rfilp = get_filp2((what == COPYFD_TO) ? fp : rfp, fd, VNODE_NONE);  if (rfilp == NULL)	return(err_code);  /* If the filp is involved in an IOCTL by the user process, locking the filp   * here would result in a deadlock.  This would happen if a user process   * passes in the file descriptor to the device node on which it is performing   * the IOCTL.  We do not allow manipulation of such device nodes.  In   * practice, this only applies to block-special files (and thus VND), because   * character-special files (as used by UDS) are unlocked during the IOCTL.   */  if (rfilp->filp_ioctl_fp == rfp)	return(EBADF);  /* Now we can safely lock the filp, copy or close it, and unlock it again. */  lock_filp(rfilp, VNODE_READ);  switch (what) {  case COPYFD_FROM:	/*	 * If the caller is a socket driver (namely, UDS) and the file	 * descriptor being copied in is a socket for that socket driver, then	 * deny the call, because of at least two known issues.  Both issues	 * are related to UDS having an in-flight file descriptor that is the	 * last reference to a UDS socket:	 *	 * 1) if UDS tries to close the file descriptor, this will prompt VFS	 *    to close the underlying object, which is a UDS socket.  As a	 *    result, while UDS is blocked in the close(2), VFS will try to	 *    send a request to UDS to close the socket.  This results in a	 *    deadlock of the UDS service.	 *	 * 2) if a file descriptor for a UDS socket is sent across that same	 *    UDS socket, the socket will remain referenced by UDS, thus open	 *    in VFS, and therefore also open in UDS.  The socket and file	 *    descriptor will both remain in use for the rest of UDS' lifetime.	 *    This can easily result in denial-of-service in the UDS service.	 *    The same problem can be triggered using multiple sockets that	 *    have in-flight file descriptors referencing each other.	 *	 * A proper solution for these problems may consist of some form of	 * "soft reference counting" where VFS does not count UDS having a	 * filp open as a real reference.  That is tricky business, so for now	 * we prevent any such problems with the check here.	 */	if ((vp = rfilp->filp_vno) != NULL && S_ISSOCK(vp->v_mode) &&	    (sp = get_smap_by_dev(vp->v_sdev, NULL)) != NULL &&	    sp->smap_endpt == who_e) {		r = EDEADLK;		break;	}	rfp = fp;	/* FALLTHROUGH */  case COPYFD_TO:	/* Find a free file descriptor slot in the local or remote process. */	for (fd = 0; fd < OPEN_MAX; fd++)		if (rfp->fp_filp[fd] == NULL)			break;	/* If found, fill the slot and return the slot number. */	if (fd < OPEN_MAX) {		rfp->fp_filp[fd] = rfilp;		rfilp->filp_count++;		r = fd;	} else		r = EMFILE;	break;  case COPYFD_CLOSE:	/* This should be used ONLY to revert a successful copy-to operation,	 * and assumes that the filp is still in use by the caller as well.	 */	if (rfilp->filp_count > 1) {		rfilp->filp_count--;		rfp->fp_filp[fd] = NULL;		r = OK;	} else		r = EBADF;	break;  default:	r = EINVAL;  }  unlock_filp(rfilp);  return(r);}
struct fproc *rfp;
struct fproc *rfp;
struct fproc
fproc
*rfp
*
rfp
struct filp *rfilp;
struct filp *rfilp;
struct filp
filp
*rfilp
*
rfilp
struct vnode *vp;
struct vnode *vp;
struct vnode
vnode
*vp
*
vp
struct smap *sp;
struct smap *sp;
struct smap
smap
*sp
*
sp
endpoint_t endpt;
endpoint_t endpt;
endpoint_t
endpoint_t
endpt
endpt
int r, fd, what, slot;
int r, fd, what, slot;
int
r
r
fd
fd
what
what
slot
slot
if (!super_user) return(EPERM);
!super_user
super_user
super_user
return(EPERM);
(EPERM)
EPERM
EPERM
endpt = job_m_in.m_lsys_vfs_copyfd.endpt;
endpt = job_m_in.m_lsys_vfs_copyfd.endpt
endpt
endpt
job_m_in.m_lsys_vfs_copyfd.endpt
job_m_in.m_lsys_vfs_copyfd
job_m_in
job_m_in
m_lsys_vfs_copyfd
endpt
fd = job_m_in.m_lsys_vfs_copyfd.fd;
fd = job_m_in.m_lsys_vfs_copyfd.fd
fd
fd
job_m_in.m_lsys_vfs_copyfd.fd
job_m_in.m_lsys_vfs_copyfd
job_m_in
job_m_in
m_lsys_vfs_copyfd
fd
what = job_m_in.m_lsys_vfs_copyfd.what;
what = job_m_in.m_lsys_vfs_copyfd.what
what
what
job_m_in.m_lsys_vfs_copyfd.what
job_m_in.m_lsys_vfs_copyfd
job_m_in
job_m_in
m_lsys_vfs_copyfd
what
if (isokendpt(endpt, &slot) != OK) return(EINVAL);
isokendpt(endpt, &slot) != OK
isokendpt(endpt, &slot)
isokendpt
isokendpt
endpt
endpt
&slot
slot
slot
OK
OK
return(EINVAL);
(EINVAL)
EINVAL
EINVAL
rfp = &fproc[slot];
rfp = &fproc[slot]
rfp
rfp
&fproc[slot]
fproc[slot]
fproc
fproc
slot
slot
rfilp = get_filp2((what == COPYFD_TO) ? fp : rfp, fd, VNODE_NONE);
rfilp = get_filp2((what == COPYFD_TO) ? fp : rfp, fd, VNODE_NONE)
rfilp
rfilp
get_filp2((what == COPYFD_TO) ? fp : rfp, fd, VNODE_NONE)
get_filp2
get_filp2
(what == COPYFD_TO) ? fp : rfp
(what == COPYFD_TO)
what == COPYFD_TO
what
what
COPYFD_TO
COPYFD_TO
fp
fp
rfp
rfp
fd
fd
VNODE_NONE
VNODE_NONE
if (rfilp == NULL)	return(err_code);
rfilp == NULL
rfilp
rfilp
NULL
NULL
return(err_code);
(err_code)
err_code
err_code
if (rfilp->filp_ioctl_fp == rfp)	return(EBADF);
rfilp->filp_ioctl_fp == rfp
rfilp->filp_ioctl_fp
rfilp
rfilp
filp_ioctl_fp
rfp
rfp
return(EBADF);
(EBADF)
EBADF
EBADF
lock_filp(rfilp, VNODE_READ);
lock_filp(rfilp, VNODE_READ)
lock_filp
lock_filp
rfilp
rfilp
VNODE_READ
VNODE_READ
switch (what) {  case COPYFD_FROM:	/*	 * If the caller is a socket driver (namely, UDS) and the file	 * descriptor being copied in is a socket for that socket driver, then	 * deny the call, because of at least two known issues.  Both issues	 * are related to UDS having an in-flight file descriptor that is the	 * last reference to a UDS socket:	 *	 * 1) if UDS tries to close the file descriptor, this will prompt VFS	 *    to close the underlying object, which is a UDS socket.  As a	 *    result, while UDS is blocked in the close(2), VFS will try to	 *    send a request to UDS to close the socket.  This results in a	 *    deadlock of the UDS service.	 *	 * 2) if a file descriptor for a UDS socket is sent across that same	 *    UDS socket, the socket will remain referenced by UDS, thus open	 *    in VFS, and therefore also open in UDS.  The socket and file	 *    descriptor will both remain in use for the rest of UDS' lifetime.	 *    This can easily result in denial-of-service in the UDS service.	 *    The same problem can be triggered using multiple sockets that	 *    have in-flight file descriptors referencing each other.	 *	 * A proper solution for these problems may consist of some form of	 * "soft reference counting" where VFS does not count UDS having a	 * filp open as a real reference.  That is tricky business, so for now	 * we prevent any such problems with the check here.	 */	if ((vp = rfilp->filp_vno) != NULL && S_ISSOCK(vp->v_mode) &&	    (sp = get_smap_by_dev(vp->v_sdev, NULL)) != NULL &&	    sp->smap_endpt == who_e) {		r = EDEADLK;		break;	}	rfp = fp;	/* FALLTHROUGH */  case COPYFD_TO:	/* Find a free file descriptor slot in the local or remote process. */	for (fd = 0; fd < OPEN_MAX; fd++)		if (rfp->fp_filp[fd] == NULL)			break;	/* If found, fill the slot and return the slot number. */	if (fd < OPEN_MAX) {		rfp->fp_filp[fd] = rfilp;		rfilp->filp_count++;		r = fd;	} else		r = EMFILE;	break;  case COPYFD_CLOSE:	/* This should be used ONLY to revert a successful copy-to operation,	 * and assumes that the filp is still in use by the caller as well.	 */	if (rfilp->filp_count > 1) {		rfilp->filp_count--;		rfp->fp_filp[fd] = NULL;		r = OK;	} else		r = EBADF;	break;  default:	r = EINVAL;  }
what
what
{  case COPYFD_FROM:	/*	 * If the caller is a socket driver (namely, UDS) and the file	 * descriptor being copied in is a socket for that socket driver, then	 * deny the call, because of at least two known issues.  Both issues	 * are related to UDS having an in-flight file descriptor that is the	 * last reference to a UDS socket:	 *	 * 1) if UDS tries to close the file descriptor, this will prompt VFS	 *    to close the underlying object, which is a UDS socket.  As a	 *    result, while UDS is blocked in the close(2), VFS will try to	 *    send a request to UDS to close the socket.  This results in a	 *    deadlock of the UDS service.	 *	 * 2) if a file descriptor for a UDS socket is sent across that same	 *    UDS socket, the socket will remain referenced by UDS, thus open	 *    in VFS, and therefore also open in UDS.  The socket and file	 *    descriptor will both remain in use for the rest of UDS' lifetime.	 *    This can easily result in denial-of-service in the UDS service.	 *    The same problem can be triggered using multiple sockets that	 *    have in-flight file descriptors referencing each other.	 *	 * A proper solution for these problems may consist of some form of	 * "soft reference counting" where VFS does not count UDS having a	 * filp open as a real reference.  That is tricky business, so for now	 * we prevent any such problems with the check here.	 */	if ((vp = rfilp->filp_vno) != NULL && S_ISSOCK(vp->v_mode) &&	    (sp = get_smap_by_dev(vp->v_sdev, NULL)) != NULL &&	    sp->smap_endpt == who_e) {		r = EDEADLK;		break;	}	rfp = fp;	/* FALLTHROUGH */  case COPYFD_TO:	/* Find a free file descriptor slot in the local or remote process. */	for (fd = 0; fd < OPEN_MAX; fd++)		if (rfp->fp_filp[fd] == NULL)			break;	/* If found, fill the slot and return the slot number. */	if (fd < OPEN_MAX) {		rfp->fp_filp[fd] = rfilp;		rfilp->filp_count++;		r = fd;	} else		r = EMFILE;	break;  case COPYFD_CLOSE:	/* This should be used ONLY to revert a successful copy-to operation,	 * and assumes that the filp is still in use by the caller as well.	 */	if (rfilp->filp_count > 1) {		rfilp->filp_count--;		rfp->fp_filp[fd] = NULL;		r = OK;	} else		r = EBADF;	break;  default:	r = EINVAL;  }
case COPYFD_FROM:
COPYFD_FROM
COPYFD_FROM
if ((vp = rfilp->filp_vno) != NULL && S_ISSOCK(vp->v_mode) &&	    (sp = get_smap_by_dev(vp->v_sdev, NULL)) != NULL &&	    sp->smap_endpt == who_e) {		r = EDEADLK;		break;	}
(vp = rfilp->filp_vno) != NULL && S_ISSOCK(vp->v_mode) &&	    (sp = get_smap_by_dev(vp->v_sdev, NULL)) != NULL &&	    sp->smap_endpt == who_e
(vp = rfilp->filp_vno) != NULL && S_ISSOCK(vp->v_mode) &&	    (sp = get_smap_by_dev(vp->v_sdev, NULL)) != NULL
(vp = rfilp->filp_vno) != NULL && S_ISSOCK(vp->v_mode)
(vp = rfilp->filp_vno) != NULL
(vp = rfilp->filp_vno)
vp = rfilp->filp_vno
vp
vp
rfilp->filp_vno
rfilp
rfilp
filp_vno
NULL
NULL
S_ISSOCK(vp->v_mode)
S_ISSOCK
S_ISSOCK
vp->v_mode
vp
vp
v_mode
(sp = get_smap_by_dev(vp->v_sdev, NULL)) != NULL
(sp = get_smap_by_dev(vp->v_sdev, NULL))
sp = get_smap_by_dev(vp->v_sdev, NULL)
sp
sp
get_smap_by_dev(vp->v_sdev, NULL)
get_smap_by_dev
get_smap_by_dev
vp->v_sdev
vp
vp
v_sdev
NULL
NULL
NULL
NULL
sp->smap_endpt == who_e
sp->smap_endpt
sp
sp
smap_endpt
who_e
who_e
{		r = EDEADLK;		break;	}
r = EDEADLK;
r = EDEADLK
r
r
EDEADLK
EDEADLK
break;
rfp = fp;
rfp = fp
rfp
rfp
fp
fp
case COPYFD_TO:
COPYFD_TO
COPYFD_TO
for (fd = 0; fd < OPEN_MAX; fd++)		if (rfp->fp_filp[fd] == NULL)			break;
fd = 0;
fd = 0
fd
fd
0
fd < OPEN_MAX
fd
fd
OPEN_MAX
OPEN_MAX
fd++
fd
fd
if (rfp->fp_filp[fd] == NULL)			break;
rfp->fp_filp[fd] == NULL
rfp->fp_filp[fd]
rfp->fp_filp
rfp
rfp
fp_filp
fd
fd
NULL
NULL
break;
if (fd < OPEN_MAX) {		rfp->fp_filp[fd] = rfilp;		rfilp->filp_count++;		r = fd;	} else		r = EMFILE;
fd < OPEN_MAX
fd
fd
OPEN_MAX
OPEN_MAX
{		rfp->fp_filp[fd] = rfilp;		rfilp->filp_count++;		r = fd;	}
rfp->fp_filp[fd] = rfilp;
rfp->fp_filp[fd] = rfilp
rfp->fp_filp[fd]
rfp->fp_filp
rfp
rfp
fp_filp
fd
fd
rfilp
rfilp
rfilp->filp_count++;
rfilp->filp_count++
rfilp->filp_count
rfilp
rfilp
filp_count
r = fd;
r = fd
r
r
fd
fd
r = EMFILE;
r = EMFILE
r
r
EMFILE
EMFILE
break;
case COPYFD_CLOSE:
COPYFD_CLOSE
COPYFD_CLOSE
if (rfilp->filp_count > 1) {		rfilp->filp_count--;		rfp->fp_filp[fd] = NULL;		r = OK;	} else		r = EBADF;
rfilp->filp_count > 1
rfilp->filp_count
rfilp
rfilp
filp_count
1
{		rfilp->filp_count--;		rfp->fp_filp[fd] = NULL;		r = OK;	}
rfilp->filp_count--;
rfilp->filp_count--
rfilp->filp_count
rfilp
rfilp
filp_count
rfp->fp_filp[fd] = NULL;
rfp->fp_filp[fd] = NULL
rfp->fp_filp[fd]
rfp->fp_filp
rfp
rfp
fp_filp
fd
fd
NULL
NULL
r = OK;
r = OK
r
r
OK
OK
r = EBADF;
r = EBADF
r
r
EBADF
EBADF
break;
default:
r = EINVAL;
r = EINVAL
r
r
EINVAL
EINVAL
unlock_filp(rfilp);
unlock_filp(rfilp)
unlock_filp
unlock_filp
rfilp
rfilp
return(r);
(r)
r
r
-----joern-----
(130,177,0)
(173,132,0)
(38,67,0)
(104,55,0)
(117,118,0)
(24,177,0)
(13,91,0)
(8,59,0)
(41,187,0)
(146,92,0)
(172,3,0)
(23,120,0)
(21,183,0)
(140,121,0)
(80,190,0)
(129,113,0)
(36,65,0)
(92,187,0)
(132,190,0)
(73,67,0)
(144,52,0)
(79,121,0)
(162,13,0)
(47,118,0)
(105,176,0)
(143,194,0)
(138,0,0)
(64,0,0)
(45,0,0)
(57,109,0)
(188,49,0)
(94,64,0)
(71,96,0)
(95,52,0)
(6,141,0)
(52,177,0)
(99,103,0)
(27,64,0)
(107,65,0)
(77,103,0)
(190,78,0)
(188,0,0)
(2,176,0)
(159,7,0)
(195,1,0)
(166,1,0)
(40,3,0)
(26,98,0)
(103,177,0)
(78,103,0)
(145,121,0)
(30,139,0)
(42,93,0)
(6,39,0)
(149,49,0)
(192,177,0)
(156,177,0)
(175,166,0)
(184,176,0)
(147,36,0)
(119,121,0)
(165,177,0)
(100,188,0)
(49,188,0)
(115,7,0)
(15,23,0)
(56,140,0)
(154,80,0)
(98,95,0)
(91,13,0)
(161,4,0)
(13,147,0)
(74,108,0)
(60,189,0)
(126,172,0)
(176,103,0)
(63,123,0)
(195,116,0)
(166,104,0)
(124,141,0)
(158,140,0)
(4,97,0)
(171,121,0)
(114,99,0)
(86,183,0)
(70,177,0)
(1,59,0)
(1,166,0)
(89,170,0)
(138,57,0)
(23,189,0)
(49,97,0)
(120,19,0)
(160,189,0)
(182,91,0)
(167,155,0)
(28,98,0)
(9,155,0)
(92,59,0)
(108,103,0)
(65,36,0)
(81,133,0)
(69,50,0)
(136,78,0)
(174,9,0)
(45,113,0)
(3,103,0)
(99,114,0)
(189,97,0)
(57,138,0)
(84,121,0)
(155,167,0)
(187,92,0)
(168,78,0)
(104,166,0)
(188,140,0)
(147,177,0)
(53,138,0)
(59,1,0)
(6,93,0)
(52,95,0)
(58,132,0)
(66,121,0)
(135,152,0)
(54,45,0)
(150,118,0)
(68,13,0)
(108,51,0)
(59,92,0)
(3,172,0)
(148,97,0)
(138,140,0)
(111,167,0)
(167,177,0)
(43,147,0)
(29,65,0)
(90,155,0)
(113,52,0)
(137,99,0)
(95,98,0)
(176,2,0)
(123,97,0)
(187,132,0)
(23,50,0)
(133,194,0)
(12,177,0)
(23,133,0)
(20,139,0)
(163,0,0)
(135,19,0)
(0,150,0)
(164,133,0)
(191,36,0)
(109,57,0)
(155,9,0)
(183,167,0)
(36,147,0)
(103,113,0)
(113,103,0)
(10,177,0)
(122,121,0)
(82,18,0)
(189,51,0)
(178,80,0)
(112,45,0)
(186,152,0)
(131,109,0)
(17,177,0)
(170,103,0)
(49,108,0)
(180,3,0)
(101,195,0)
(102,116,0)
(150,0,0)
(106,190,0)
(118,150,0)
(157,177,0)
(64,94,0)
(142,120,0)
(85,116,0)
(114,51,0)
(14,127,0)
(151,9,0)
(179,55,0)
(6,18,0)
(96,19,0)
(25,177,0)
(23,177,0)
(77,177,0)
(183,45,0)
(78,190,0)
(94,96,0)
(16,39,0)
(125,113,0)
(152,135,0)
(190,55,0)
(55,190,0)
(87,64,0)
(50,121,0)
(1,195,0)
(76,50,0)
(2,0,0)
(32,57,0)
(152,103,0)
(193,177,0)
(35,127,0)
(175,80,0)
(45,183,0)
(6,23,0)
(34,95,0)
(23,127,0)
(166,175,0)
(61,97,0)
(185,2,0)
(37,77,0)
(94,52,0)
(0,177,0)
(83,188,0)
(5,120,0)
(7,103,0)
(134,121,0)
(57,97,0)
(153,177,0)
(72,177,0)
(62,121,0)
(80,175,0)
(170,177,0)
(44,152,0)
(46,123,0)
(67,97,0)
(75,33,0)
(128,103,0)
(116,92,0)
(22,94,0)
(181,121,0)
(31,138,0)
(116,195,0)
(113,45,0)
(13,162,0)
(132,187,0)
(169,170,0)
(55,104,0)
(110,162,0)
(11,99,0)
(23,139,0)
(117,163,1)
(124,33,1)
(6,39,1)
(138,31,1)
(178,55,1)
(91,182,1)
(189,160,1)
(129,45,1)
(21,86,1)
(77,37,1)
(166,1,1)
(132,58,1)
(189,97,1)
(191,65,1)
(98,28,1)
(1,195,1)
(166,175,1)
(183,167,1)
(63,4,1)
(65,29,1)
(86,128,1)
(82,2,1)
(36,65,1)
(113,52,1)
(23,120,1)
(163,91,1)
(7,159,1)
(92,187,1)
(23,50,1)
(56,104,1)
(67,73,1)
(154,178,1)
(97,148,1)
(186,44,1)
(90,9,1)
(99,103,1)
(115,103,1)
(38,123,1)
(161,109,1)
(145,120,1)
(108,74,1)
(179,190,1)
(138,140,1)
(30,67,1)
(147,36,1)
(5,142,1)
(42,91,1)
(123,97,1)
(45,112,1)
(61,88,1)
(184,7,1)
(118,47,1)
(141,124,1)
(170,103,1)
(9,151,1)
(116,85,1)
(22,64,1)
(7,103,1)
(6,141,1)
(136,106,1)
(8,92,1)
(46,63,1)
(91,13,1)
(32,138,1)
(45,183,1)
(187,41,1)
(78,168,1)
(152,103,1)
(52,95,1)
(43,33,1)
(110,68,1)
(55,179,1)
(37,143,1)
(113,125,1)
(85,102,1)
(104,166,1)
(128,0,1)
(139,20,1)
(61,140,1)
(4,161,1)
(159,115,1)
(102,59,1)
(188,100,1)
(164,104,1)
(155,9,1)
(108,103,1)
(37,84,1)
(106,88,1)
(172,3,1)
(76,88,1)
(188,0,1)
(138,0,1)
(170,169,1)
(57,97,1)
(125,129,1)
(53,123,1)
(185,176,1)
(13,147,1)
(195,101,1)
(49,97,1)
(155,90,1)
(168,136,1)
(169,89,1)
(145,127,1)
(152,186,1)
(148,61,1)
(11,137,1)
(135,152,1)
(183,21,1)
(40,180,1)
(67,97,1)
(6,18,1)
(14,35,1)
(23,127,1)
(187,132,1)
(137,108,1)
(95,98,1)
(131,57,1)
(103,113,1)
(87,27,1)
(23,139,1)
(74,49,1)
(47,117,1)
(18,82,1)
(64,87,1)
(101,116,1)
(23,189,1)
(45,0,1)
(64,0,1)
(4,97,1)
(23,15,1)
(39,16,1)
(144,147,1)
(29,107,1)
(49,149,1)
(116,92,1)
(94,52,1)
(37,50,1)
(176,103,1)
(146,175,1)
(133,81,1)
(45,54,1)
(111,52,1)
(140,158,1)
(172,126,1)
(0,150,1)
(84,189,1)
(34,98,1)
(20,30,1)
(132,190,1)
(60,114,1)
(59,8,1)
(89,2,1)
(120,5,1)
(123,46,1)
(49,188,1)
(84,139,1)
(94,64,1)
(28,26,1)
(23,133,1)
(26,144,1)
(44,172,1)
(180,88,1)
(63,97,1)
(3,40,1)
(195,116,1)
(96,71,1)
(142,96,1)
(112,183,1)
(174,111,1)
(3,103,1)
(36,191,1)
(55,190,1)
(94,22,1)
(58,173,1)
(162,110,1)
(73,38,1)
(71,94,1)
(143,133,1)
(80,190,1)
(149,188,1)
(31,53,1)
(1,59,1)
(59,92,1)
(105,184,1)
(6,93,1)
(126,3,1)
(68,167,1)
(78,103,1)
(16,7,1)
(182,13,1)
(88,170,1)
(190,78,1)
(38,48,1)
(37,145,1)
(109,57,1)
(2,0,1)
(107,43,1)
(99,11,1)
(104,55,1)
(176,105,1)
(113,45,1)
(27,135,1)
(114,99,1)
(95,34,1)
(175,80,1)
(2,176,1)
(54,183,1)
(50,69,1)
(77,103,1)
(93,42,1)
(81,164,1)
(109,131,1)
(83,67,1)
(33,75,1)
(48,109,1)
(127,14,1)
(151,174,1)
(57,138,1)
(13,162,1)
(41,132,1)
(160,60,1)
(69,76,1)
(173,146,1)
(2,185,1)
(188,140,1)
(15,77,1)
(57,32,1)
(35,172,1)
(80,154,1)
(6,23,1)
(100,83,1)
(167,155,1)
(150,118,1)
(158,56,1)
(57,123,2)
(154,55,2)
(138,123,2)
(143,104,2)
(99,67,2)
(13,162,2)
(21,91,2)
(37,2,2)
(106,88,2)
(184,7,2)
(172,88,2)
(137,67,2)
(128,91,2)
(3,88,2)
(49,97,2)
(63,109,2)
(78,103,2)
(92,187,2)
(163,91,2)
(41,175,2)
(195,59,2)
(55,88,2)
(52,95,2)
(144,33,2)
(99,103,2)
(152,103,2)
(187,132,2)
(43,33,2)
(23,2,2)
(67,97,2)
(39,7,2)
(132,175,2)
(173,175,2)
(57,138,2)
(63,88,2)
(35,172,2)
(109,123,2)
(148,88,2)
(104,88,2)
(27,172,2)
(71,172,2)
(136,88,2)
(58,175,2)
(44,172,2)
(84,88,2)
(90,33,2)
(133,104,2)
(36,65,2)
(150,91,2)
(135,172,2)
(20,67,2)
(2,0,2)
(83,67,2)
(6,39,2)
(78,88,2)
(190,88,2)
(91,13,2)
(34,33,2)
(179,88,2)
(9,33,2)
(80,55,2)
(185,7,2)
(108,67,2)
(3,103,2)
(7,91,2)
(65,33,2)
(73,88,2)
(6,141,2)
(131,123,2)
(135,152,2)
(92,175,2)
(22,172,2)
(16,7,2)
(13,147,2)
(188,140,2)
(147,33,2)
(141,33,2)
(82,2,2)
(109,57,2)
(61,88,2)
(29,33,2)
(175,80,2)
(104,55,2)
(64,172,2)
(113,91,2)
(111,33,2)
(187,175,2)
(73,104,2)
(89,2,2)
(151,33,2)
(42,91,2)
(23,127,2)
(123,109,2)
(170,103,2)
(166,55,2)
(23,139,2)
(81,104,2)
(0,150,2)
(87,172,2)
(97,104,2)
(146,175,2)
(77,2,2)
(101,59,2)
(166,175,2)
(46,88,2)
(169,2,2)
(116,59,2)
(178,55,2)
(46,109,2)
(63,104,2)
(145,88,2)
(36,33,2)
(55,190,2)
(64,0,2)
(60,67,2)
(45,91,2)
(123,97,2)
(0,91,2)
(93,91,2)
(30,67,2)
(80,190,2)
(103,91,2)
(112,183,2)
(189,97,2)
(103,113,2)
(94,64,2)
(139,67,2)
(67,104,2)
(15,2,2)
(191,33,2)
(180,88,2)
(11,67,2)
(38,88,2)
(95,33,2)
(188,67,2)
(102,59,2)
(53,123,2)
(38,104,2)
(6,23,2)
(1,195,2)
(176,103,2)
(183,91,2)
(5,172,2)
(132,190,2)
(86,91,2)
(74,67,2)
(56,104,2)
(161,109,2)
(18,2,2)
(23,133,2)
(118,91,2)
(13,33,2)
(45,183,2)
(190,78,2)
(188,0,2)
(26,33,2)
(52,33,2)
(114,99,2)
(50,88,2)
(97,88,2)
(123,104,2)
(23,189,2)
(6,93,2)
(167,155,2)
(94,172,2)
(77,103,2)
(57,97,2)
(7,103,2)
(98,33,2)
(168,88,2)
(105,7,2)
(150,118,2)
(14,172,2)
(110,33,2)
(49,188,2)
(138,140,2)
(85,59,2)
(76,88,2)
(167,33,2)
(166,1,2)
(175,55,2)
(84,104,2)
(142,172,2)
(159,91,2)
(124,33,2)
(164,104,2)
(49,67,2)
(148,104,2)
(45,0,2)
(114,67,2)
(126,88,2)
(96,172,2)
(160,67,2)
(104,166,2)
(125,91,2)
(100,67,2)
(129,91,2)
(46,104,2)
(91,33,2)
(23,120,2)
(183,167,2)
(176,7,2)
(162,33,2)
(23,50,2)
(170,2,2)
(147,36,2)
(195,116,2)
(120,172,2)
(69,88,2)
(88,2,2)
(95,98,2)
(4,97,2)
(113,45,2)
(117,91,2)
(31,123,2)
(1,59,2)
(2,176,2)
(54,183,2)
(123,88,2)
(40,88,2)
(107,33,2)
(8,175,2)
(1,175,2)
(115,91,2)
(113,52,2)
(138,0,2)
(149,67,2)
(189,67,2)
(116,92,2)
(6,18,2)
(68,33,2)
(108,103,2)
(59,92,2)
(155,9,2)
(152,172,2)
(186,172,2)
(67,88,2)
(47,91,2)
(28,33,2)
(182,33,2)
(2,7,2)
(127,172,2)
(174,33,2)
(155,33,2)
(61,104,2)
(48,109,2)
(140,104,2)
(59,175,2)
(158,104,2)
(172,3,2)
(94,52,2)
(32,123,2)
(4,109,2)
-----------------------------------
(0,rfp = &fproc[slot])
(1,(sp = get_smap_by_dev(vp->v_sdev, NULL)
(2,rfilp->filp_ioctl_fp == rfp)
(3,rfilp->filp_count)
(4,fd++)
(5,OK)
(6,RET)
(7,rfilp == NULL)
(8,NULL)
(9,job_m_in.m_lsys_vfs_copyfd)
(10,if (rfilp->filp_ioctl_fp == rfp)
(11,filp_count)
(12,if (rfilp == NULL)
(13,isokendpt(endpt, &slot)
(14,EBADF)
(15,r)
(16,err_code)
(17,if (isokendpt(endpt, &slot)
(18,return(EBADF)
(19,)
(20,EMFILE)
(21,COPYFD_TO)
(22,fd)
(23,return(r)
(24,sp)
(25,rfp)
(26,job_m_in)
(27,rfp)
(28,m_lsys_vfs_copyfd)
(29,m_lsys_vfs_copyfd)
(30,r)
(31,fp_filp)
(32,fd)
(33,!super_user)
(34,fd)
(35,r)
(36,job_m_in.m_lsys_vfs_copyfd.endpt)
(37,rfilp)
(38,fd)
(39,return(err_code)
(40,filp_count)
(41,NULL)
(42,EINVAL)
(43,endpt)
(44,rfilp)
(45,(what == COPYFD_TO)
(46,OPEN_MAX)
(47,slot)
(48,break;)
(49,rfp->fp_filp[fd])
(50,r = EINVAL)
(51,)
(52,fd = job_m_in.m_lsys_vfs_copyfd.fd)
(53,rfp)
(54,rfp)
(55,(vp = rfilp->filp_vno)
(56,rfp)
(57,rfp->fp_filp[fd])
(58,v_sdev)
(59,(sp = get_smap_by_dev(vp->v_sdev, NULL)
(60,r)
(61,fd)
(62,if (rfilp->filp_count > 1)
(63,fd)
(64,rfp->fp_filp)
(65,job_m_in.m_lsys_vfs_copyfd)
(66,case COPYFD_CLOSE:)
(67,fd < OPEN_MAX)
(68,endpt)
(69,EINVAL)
(70,r)
(71,NULL)
(72,if (!super_user)
(73,OPEN_MAX)
(74,rfilp)
(75,super_user)
(76,r)
(77,unlock_filp(rfilp)
(78,rfilp->filp_vno)
(79,case COPYFD_FROM:)
(80,vp->v_mode)
(81,EDEADLK)
(82,EBADF)
(83,rfp)
(84,break;)
(85,smap_endpt)
(86,what)
(87,fp_filp)
(88,what)
(89,rfilp)
(90,what)
(91,isokendpt(endpt, &slot)
(92,sp = get_smap_by_dev(vp->v_sdev, NULL)
(93,return(EINVAL)
(94,rfp->fp_filp[fd])
(95,job_m_in.m_lsys_vfs_copyfd.fd)
(96,rfp->fp_filp[fd] = NULL)
(97,fd = 0)
(98,job_m_in.m_lsys_vfs_copyfd)
(99,rfilp->filp_count)
(100,fp_filp)
(101,who_e)
(102,sp)
(103,rfilp = get_filp2((what == COPYFD_TO)
(104,(vp = rfilp->filp_vno)
(105,filp_ioctl_fp)
(106,vp)
(107,job_m_in)
(108,rfp->fp_filp[fd] = rfilp)
(109,rfp->fp_filp[fd] == NULL)
(110,slot)
(111,what)
(112,fp)
(113,get_filp2((what == COPYFD_TO)
(114,rfilp->filp_count++)
(115,rfilp)
(116,sp->smap_endpt)
(117,fproc)
(118,fproc[slot])
(119,if (fd < OPEN_MAX)
(120,r = OK)
(121,)
(122,default:)
(123,fd < OPEN_MAX)
(124,EPERM)
(125,VNODE_NONE)
(126,1)
(127,r = EBADF)
(128,rfilp)
(129,fd)
(130,switch (what)
(131,NULL)
(132,vp->v_sdev)
(133,r = EDEADLK)
(134,for (fd = 0; fd < OPEN_MAX; fd++)
(135,rfilp->filp_count--)
(136,rfilp)
(137,rfilp)
(138,rfp->fp_filp)
(139,r = EMFILE)
(140,rfp = fp)
(141,return(EPERM)
(142,r)
(143,break;)
(144,fd)
(145,break;)
(146,sp)
(147,endpt = job_m_in.m_lsys_vfs_copyfd.endpt)
(148,0)
(149,fd)
(150,&fproc[slot])
(151,m_lsys_vfs_copyfd)
(152,rfilp->filp_count)
(153,slot)
(154,v_mode)
(155,job_m_in.m_lsys_vfs_copyfd.what)
(156,rfilp)
(157,fd)
(158,fp)
(159,NULL)
(160,fd)
(161,fd)
(162,&slot)
(163,rfp)
(164,r)
(165,endpt)
(166,S_ISSOCK(vp->v_mode)
(167,what = job_m_in.m_lsys_vfs_copyfd.what)
(168,filp_vno)
(169,VNODE_READ)
(170,lock_filp(rfilp, VNODE_READ)
(171,if ((vp = rfilp->filp_vno)
(172,rfilp->filp_count > 1)
(173,vp)
(174,job_m_in)
(175,S_ISSOCK(vp->v_mode)
(176,rfilp->filp_ioctl_fp)
(177,)
(178,vp)
(179,NULL)
(180,rfilp)
(181,case COPYFD_TO:)
(182,OK)
(183,what == COPYFD_TO)
(184,rfilp)
(185,rfp)
(186,filp_count)
(187,get_smap_by_dev(vp->v_sdev, NULL)
(188,rfp->fp_filp)
(189,r = fd)
(190,vp = rfilp->filp_vno)
(191,endpt)
(192,vp)
(193,what)
(194,)
(195,sp->smap_endpt == who_e)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^