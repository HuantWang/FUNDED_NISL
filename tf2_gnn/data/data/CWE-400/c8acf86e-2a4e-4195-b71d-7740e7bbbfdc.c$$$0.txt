-----label-----
0
-----code-----
static void leave_queue(struct queue_ent *qe)
{
	struct call_queue *q;
	struct queue_ent *current, *prev = NULL;
	struct penalty_rule *pr_iter;
	int pos = 0;

	if (!(q = qe->parent)) {
		return;
	}
	queue_t_ref(q, "Copy queue pointer from queue entry");
	ao2_lock(q);

	prev = NULL;
	for (current = q->head; current; current = current->next) {
		if (current == qe) {
			char posstr[20];
			q->count--;
			if (!q->count) {
				ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s", q->name);
			}

			/* Take us out of the queue */
			/*** DOCUMENTATION
			<managerEventInstance>
				<synopsis>Raised when a channel leaves a Queue.</synopsis>
				<syntax>
					<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />
					<xi:include xpointer="xpointer(/docs/managerEvent[@name='Join']/managerEventInstance/syntax/parameter[@name='Count'])" />
					<xi:include xpointer="xpointer(/docs/managerEvent[@name='Join']/managerEventInstance/syntax/parameter[@name='Position'])" />
				</syntax>
				<see-also>
					<ref type="managerEvent">Join</ref>
				</see-also>
			</managerEventInstance>
			***/
			ast_manager_event(qe->chan, EVENT_FLAG_CALL, "Leave",
				"Channel: %s\r\nQueue: %s\r\nCount: %d\r\nPosition: %d\r\nUniqueid: %s\r\n",
				ast_channel_name(qe->chan), q->name,  q->count, qe->pos, ast_channel_uniqueid(qe->chan));
			ast_debug(1, "Queue '%s' Leave, Channel '%s'\n", q->name, ast_channel_name(qe->chan));
			/* Take us out of the queue */
			if (prev) {
				prev->next = current->next;
			} else {
				q->head = current->next;
			}
			/* Free penalty rules */
			while ((pr_iter = AST_LIST_REMOVE_HEAD(&qe->qe_rules, list))) {
				ast_free(pr_iter);
			}
			snprintf(posstr, sizeof(posstr), "%d", qe->pos);
			pbx_builtin_setvar_helper(qe->chan, "QUEUEPOSITION", posstr);
		} else {
			/* Renumber the people after us in the queue based on a new count */
			current->pos = ++pos;
			prev = current;
		}
	}
	ao2_unlock(q);

	/*If the queue is a realtime queue, check to see if it's still defined in real time*/
	if (q->realtime) {
		struct ast_variable *var;
		if (!(var = ast_load_realtime("queues", "name", q->name, SENTINEL))) {
			q->dead = 1;
		} else {
			ast_variables_destroy(var);
		}
	}

	if (q->dead) {
		/* It's dead and nobody is in it, so kill it */
		queues_t_unlink(queues, q, "Queue is now dead; remove it from the container");
	}
	/* unref the explicit ref earlier in the function */
	queue_t_unref(q, "Expire copied reference");
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
6,7
8,9
8,10
11,12
11,13
11,14
11,15
11,16
11,17
11,18
11,19
11,20
11,21
11,22
11,23
11,24
12,13
13,14
13,15
14,15
16,17
16,18
19,20
20,21
20,22
20,23
21,22
23,24
23,25
26,27
26,28
26,29
29,30
30,31
32,33
33,34
33,35
34,35
36,37
36,38
39,40
40,41
40,42
42,43
42,44
44,45
46,47
46,48
47,48
48,49
49,50
49,51
50,51
52,53
52,54
53,54
56,57
58,59
59,60
59,61
59,62
60,61
62,63
65,66
66,67
66,68
67,68
69,70
71,72
72,73
72,74
73,74
75,76
77,78
77,79
77,80
77,81
78,79
79,80
79,81
80,81
82,83
82,84
83,84
86,87
88,89
88,90
89,90
91,92
91,93
92,93
95,96
96,97
96,98
96,99
97,98
97,99
98,99
100,101
102,103
102,104
102,105
102,106
102,107
102,108
102,109
102,110
102,111
103,104
104,105
104,106
106,107
106,108
108,109
110,111
111,112
112,113
112,114
113,114
116,117
116,118
117,118
118,119
118,120
119,120
122,123
123,124
124,125
124,126
124,127
124,128
125,126
127,128
130,131
130,132
131,132
134,135
135,136
135,137
135,138
135,139
135,140
135,141
135,142
135,143
135,144
135,145
136,137
138,139
138,140
139,140
142,143
146,147
146,148
147,148
149,150
149,151
150,151
153,154
153,155
154,155
157,158
157,159
158,159
161,162
161,163
162,163
165,166
165,167
166,167
168,169
168,170
169,170
172,173
173,174
173,175
173,176
173,177
173,178
174,175
178,179
178,180
179,180
182,183
182,184
183,184
185,186
185,187
186,187
189,190
189,191
189,192
190,191
192,193
193,194
194,195
194,196
195,196
195,197
196,197
199,200
199,201
200,201
203,204
204,205
205,206
205,207
206,207
206,208
207,208
210,211
210,212
211,212
214,215
214,216
215,216
216,217
216,218
217,218
219,220
219,221
219,222
220,221
222,223
223,224
223,225
224,225
227,228
229,230
230,231
231,232
231,233
232,233
234,235
236,237
237,238
237,239
237,240
237,241
237,242
238,239
240,241
242,243
243,244
244,245
247,248
247,249
248,249
251,252
252,253
252,254
252,255
252,256
253,254
255,256
255,257
256,257
260,261
262,263
262,264
263,264
264,265
264,266
265,266
265,267
266,267
269,270
270,271
272,273
273,274
273,275
274,275
276,277
278,279
279,280
279,281
280,281
282,283
284,285
284,286
285,286
285,287
286,287
289,290
289,291
290,291
291,292
291,293
292,293
294,295
294,296
297,298
297,299
297,300
298,299
299,300
300,301
300,302
301,302
303,304
303,305
303,306
303,307
303,308
304,305
308,309
308,310
309,310
312,313
314,315
315,316
316,317
316,318
317,318
317,319
318,319
322,323
323,324
324,325
324,326
325,326
327,328
329,330
329,331
330,331
330,332
331,332
334,335
335,336
336,337
336,338
336,339
336,340
337,338
339,340
341,342
344,345
345,346
345,347
345,348
346,347
348,349
-----nextToken-----
2,4,7,9,10,15,17,18,22,24,25,27,28,31,35,37,38,41,43,45,51,54,55,57,61,63,64,68,70,74,76,81,84,85,87,90,93,94,99,101,105,107,109,114,115,120,121,126,128,129,132,133,137,140,141,143,144,145,148,151,152,155,156,159,160,163,164,167,170,171,175,176,177,180,181,184,187,188,191,197,198,201,202,208,209,212,213,218,221,225,226,228,233,235,239,241,245,246,249,250,254,257,258,259,261,267,268,271,275,277,281,283,287,288,293,295,296,302,305,306,307,310,311,313,319,320,321,326,328,332,333,338,340,342,343,347,349,350
-----computeFrom-----
49,50
49,51
72,73
72,74
79,80
79,81
88,89
88,90
97,98
97,99
194,195
194,196
205,206
205,207
216,217
216,218
264,265
264,266
273,274
273,275
300,301
300,302
316,317
316,318
-----guardedBy-----
99,212
101,257
-----guardedByNegation-----
99,277
-----lastLexicalUse-----
99,277
-----jump-----
99,277
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ReturnStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;ExpressionStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;WhileStatement;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;IfStatement;UnaryExpression;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;
-----ast_node-----
static void leave_queue(struct queue_ent *qe){	struct call_queue *q;	struct queue_ent *current, *prev = NULL;	struct penalty_rule *pr_iter;	int pos = 0;	if (!(q = qe->parent)) {		return;	}	queue_t_ref(q, "Copy queue pointer from queue entry");	ao2_lock(q);	prev = NULL;	for (current = q->head; current; current = current->next) {		if (current == qe) {			char posstr[20];			q->count--;			if (!q->count) {				ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s", q->name);			}			/* Take us out of the queue */			/*** DOCUMENTATION			<managerEventInstance>				<synopsis>Raised when a channel leaves a Queue.</synopsis>				<syntax>					<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />					<xi:include xpointer="xpointer(/docs/managerEvent[@name='Join']/managerEventInstance/syntax/parameter[@name='Count'])" />					<xi:include xpointer="xpointer(/docs/managerEvent[@name='Join']/managerEventInstance/syntax/parameter[@name='Position'])" />				</syntax>				<see-also>					<ref type="managerEvent">Join</ref>				</see-also>			</managerEventInstance>			***/			ast_manager_event(qe->chan, EVENT_FLAG_CALL, "Leave",				"Channel: %s\r\nQueue: %s\r\nCount: %d\r\nPosition: %d\r\nUniqueid: %s\r\n",				ast_channel_name(qe->chan), q->name,  q->count, qe->pos, ast_channel_uniqueid(qe->chan));			ast_debug(1, "Queue '%s' Leave, Channel '%s'\n", q->name, ast_channel_name(qe->chan));			/* Take us out of the queue */			if (prev) {				prev->next = current->next;			} else {				q->head = current->next;			}			/* Free penalty rules */			while ((pr_iter = AST_LIST_REMOVE_HEAD(&qe->qe_rules, list))) {				ast_free(pr_iter);			}			snprintf(posstr, sizeof(posstr), "%d", qe->pos);			pbx_builtin_setvar_helper(qe->chan, "QUEUEPOSITION", posstr);		} else {			/* Renumber the people after us in the queue based on a new count */			current->pos = ++pos;			prev = current;		}	}	ao2_unlock(q);	/*If the queue is a realtime queue, check to see if it's still defined in real time*/	if (q->realtime) {		struct ast_variable *var;		if (!(var = ast_load_realtime("queues", "name", q->name, SENTINEL))) {			q->dead = 1;		} else {			ast_variables_destroy(var);		}	}	if (q->dead) {		/* It's dead and nobody is in it, so kill it */		queues_t_unlink(queues, q, "Queue is now dead; remove it from the container");	}	/* unref the explicit ref earlier in the function */	queue_t_unref(q, "Expire copied reference");}
static void
leave_queue(struct queue_ent *qe)
leave_queue
struct queue_ent *qe
struct queue_ent
queue_ent
*qe
*
qe
{	struct call_queue *q;	struct queue_ent *current, *prev = NULL;	struct penalty_rule *pr_iter;	int pos = 0;	if (!(q = qe->parent)) {		return;	}	queue_t_ref(q, "Copy queue pointer from queue entry");	ao2_lock(q);	prev = NULL;	for (current = q->head; current; current = current->next) {		if (current == qe) {			char posstr[20];			q->count--;			if (!q->count) {				ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s", q->name);			}			/* Take us out of the queue */			/*** DOCUMENTATION			<managerEventInstance>				<synopsis>Raised when a channel leaves a Queue.</synopsis>				<syntax>					<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />					<xi:include xpointer="xpointer(/docs/managerEvent[@name='Join']/managerEventInstance/syntax/parameter[@name='Count'])" />					<xi:include xpointer="xpointer(/docs/managerEvent[@name='Join']/managerEventInstance/syntax/parameter[@name='Position'])" />				</syntax>				<see-also>					<ref type="managerEvent">Join</ref>				</see-also>			</managerEventInstance>			***/			ast_manager_event(qe->chan, EVENT_FLAG_CALL, "Leave",				"Channel: %s\r\nQueue: %s\r\nCount: %d\r\nPosition: %d\r\nUniqueid: %s\r\n",				ast_channel_name(qe->chan), q->name,  q->count, qe->pos, ast_channel_uniqueid(qe->chan));			ast_debug(1, "Queue '%s' Leave, Channel '%s'\n", q->name, ast_channel_name(qe->chan));			/* Take us out of the queue */			if (prev) {				prev->next = current->next;			} else {				q->head = current->next;			}			/* Free penalty rules */			while ((pr_iter = AST_LIST_REMOVE_HEAD(&qe->qe_rules, list))) {				ast_free(pr_iter);			}			snprintf(posstr, sizeof(posstr), "%d", qe->pos);			pbx_builtin_setvar_helper(qe->chan, "QUEUEPOSITION", posstr);		} else {			/* Renumber the people after us in the queue based on a new count */			current->pos = ++pos;			prev = current;		}	}	ao2_unlock(q);	/*If the queue is a realtime queue, check to see if it's still defined in real time*/	if (q->realtime) {		struct ast_variable *var;		if (!(var = ast_load_realtime("queues", "name", q->name, SENTINEL))) {			q->dead = 1;		} else {			ast_variables_destroy(var);		}	}	if (q->dead) {		/* It's dead and nobody is in it, so kill it */		queues_t_unlink(queues, q, "Queue is now dead; remove it from the container");	}	/* unref the explicit ref earlier in the function */	queue_t_unref(q, "Expire copied reference");}
struct call_queue *q;
struct call_queue *q;
struct call_queue
call_queue
*q
*
q
struct queue_ent *current, *prev = NULL;
struct queue_ent *current, *prev = NULL;
struct queue_ent
queue_ent
*current
*
current
*prev = NULL
*
prev
= NULL
NULL
NULL
struct penalty_rule *pr_iter;
struct penalty_rule *pr_iter;
struct penalty_rule
penalty_rule
*pr_iter
*
pr_iter
int pos = 0;
int pos = 0;
int
pos = 0
pos
= 0
0
if (!(q = qe->parent)) {		return;	}
!(q = qe->parent)
(q = qe->parent)
q = qe->parent
q
q
qe->parent
qe
qe
parent
{		return;	}
return;
queue_t_ref(q, "Copy queue pointer from queue entry");
queue_t_ref(q, "Copy queue pointer from queue entry")
queue_t_ref
queue_t_ref
q
q
"Copy queue pointer from queue entry"
ao2_lock(q);
ao2_lock(q)
ao2_lock
ao2_lock
q
q
prev = NULL;
prev = NULL
prev
prev
NULL
NULL
for (current = q->head; current; current = current->next) {		if (current == qe) {			char posstr[20];			q->count--;			if (!q->count) {				ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s", q->name);			}			/* Take us out of the queue */			/*** DOCUMENTATION			<managerEventInstance>				<synopsis>Raised when a channel leaves a Queue.</synopsis>				<syntax>					<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />					<xi:include xpointer="xpointer(/docs/managerEvent[@name='Join']/managerEventInstance/syntax/parameter[@name='Count'])" />					<xi:include xpointer="xpointer(/docs/managerEvent[@name='Join']/managerEventInstance/syntax/parameter[@name='Position'])" />				</syntax>				<see-also>					<ref type="managerEvent">Join</ref>				</see-also>			</managerEventInstance>			***/			ast_manager_event(qe->chan, EVENT_FLAG_CALL, "Leave",				"Channel: %s\r\nQueue: %s\r\nCount: %d\r\nPosition: %d\r\nUniqueid: %s\r\n",				ast_channel_name(qe->chan), q->name,  q->count, qe->pos, ast_channel_uniqueid(qe->chan));			ast_debug(1, "Queue '%s' Leave, Channel '%s'\n", q->name, ast_channel_name(qe->chan));			/* Take us out of the queue */			if (prev) {				prev->next = current->next;			} else {				q->head = current->next;			}			/* Free penalty rules */			while ((pr_iter = AST_LIST_REMOVE_HEAD(&qe->qe_rules, list))) {				ast_free(pr_iter);			}			snprintf(posstr, sizeof(posstr), "%d", qe->pos);			pbx_builtin_setvar_helper(qe->chan, "QUEUEPOSITION", posstr);		} else {			/* Renumber the people after us in the queue based on a new count */			current->pos = ++pos;			prev = current;		}	}
current = q->head;
current = q->head
current
current
q->head
q
q
head
current
current
current = current->next
current
current
current->next
current
current
next
{		if (current == qe) {			char posstr[20];			q->count--;			if (!q->count) {				ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s", q->name);			}			/* Take us out of the queue */			/*** DOCUMENTATION			<managerEventInstance>				<synopsis>Raised when a channel leaves a Queue.</synopsis>				<syntax>					<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />					<xi:include xpointer="xpointer(/docs/managerEvent[@name='Join']/managerEventInstance/syntax/parameter[@name='Count'])" />					<xi:include xpointer="xpointer(/docs/managerEvent[@name='Join']/managerEventInstance/syntax/parameter[@name='Position'])" />				</syntax>				<see-also>					<ref type="managerEvent">Join</ref>				</see-also>			</managerEventInstance>			***/			ast_manager_event(qe->chan, EVENT_FLAG_CALL, "Leave",				"Channel: %s\r\nQueue: %s\r\nCount: %d\r\nPosition: %d\r\nUniqueid: %s\r\n",				ast_channel_name(qe->chan), q->name,  q->count, qe->pos, ast_channel_uniqueid(qe->chan));			ast_debug(1, "Queue '%s' Leave, Channel '%s'\n", q->name, ast_channel_name(qe->chan));			/* Take us out of the queue */			if (prev) {				prev->next = current->next;			} else {				q->head = current->next;			}			/* Free penalty rules */			while ((pr_iter = AST_LIST_REMOVE_HEAD(&qe->qe_rules, list))) {				ast_free(pr_iter);			}			snprintf(posstr, sizeof(posstr), "%d", qe->pos);			pbx_builtin_setvar_helper(qe->chan, "QUEUEPOSITION", posstr);		} else {			/* Renumber the people after us in the queue based on a new count */			current->pos = ++pos;			prev = current;		}	}
if (current == qe) {			char posstr[20];			q->count--;			if (!q->count) {				ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s", q->name);			}			/* Take us out of the queue */			/*** DOCUMENTATION			<managerEventInstance>				<synopsis>Raised when a channel leaves a Queue.</synopsis>				<syntax>					<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />					<xi:include xpointer="xpointer(/docs/managerEvent[@name='Join']/managerEventInstance/syntax/parameter[@name='Count'])" />					<xi:include xpointer="xpointer(/docs/managerEvent[@name='Join']/managerEventInstance/syntax/parameter[@name='Position'])" />				</syntax>				<see-also>					<ref type="managerEvent">Join</ref>				</see-also>			</managerEventInstance>			***/			ast_manager_event(qe->chan, EVENT_FLAG_CALL, "Leave",				"Channel: %s\r\nQueue: %s\r\nCount: %d\r\nPosition: %d\r\nUniqueid: %s\r\n",				ast_channel_name(qe->chan), q->name,  q->count, qe->pos, ast_channel_uniqueid(qe->chan));			ast_debug(1, "Queue '%s' Leave, Channel '%s'\n", q->name, ast_channel_name(qe->chan));			/* Take us out of the queue */			if (prev) {				prev->next = current->next;			} else {				q->head = current->next;			}			/* Free penalty rules */			while ((pr_iter = AST_LIST_REMOVE_HEAD(&qe->qe_rules, list))) {				ast_free(pr_iter);			}			snprintf(posstr, sizeof(posstr), "%d", qe->pos);			pbx_builtin_setvar_helper(qe->chan, "QUEUEPOSITION", posstr);		} else {			/* Renumber the people after us in the queue based on a new count */			current->pos = ++pos;			prev = current;		}
current == qe
current
current
qe
qe
{			char posstr[20];			q->count--;			if (!q->count) {				ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s", q->name);			}			/* Take us out of the queue */			/*** DOCUMENTATION			<managerEventInstance>				<synopsis>Raised when a channel leaves a Queue.</synopsis>				<syntax>					<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />					<xi:include xpointer="xpointer(/docs/managerEvent[@name='Join']/managerEventInstance/syntax/parameter[@name='Count'])" />					<xi:include xpointer="xpointer(/docs/managerEvent[@name='Join']/managerEventInstance/syntax/parameter[@name='Position'])" />				</syntax>				<see-also>					<ref type="managerEvent">Join</ref>				</see-also>			</managerEventInstance>			***/			ast_manager_event(qe->chan, EVENT_FLAG_CALL, "Leave",				"Channel: %s\r\nQueue: %s\r\nCount: %d\r\nPosition: %d\r\nUniqueid: %s\r\n",				ast_channel_name(qe->chan), q->name,  q->count, qe->pos, ast_channel_uniqueid(qe->chan));			ast_debug(1, "Queue '%s' Leave, Channel '%s'\n", q->name, ast_channel_name(qe->chan));			/* Take us out of the queue */			if (prev) {				prev->next = current->next;			} else {				q->head = current->next;			}			/* Free penalty rules */			while ((pr_iter = AST_LIST_REMOVE_HEAD(&qe->qe_rules, list))) {				ast_free(pr_iter);			}			snprintf(posstr, sizeof(posstr), "%d", qe->pos);			pbx_builtin_setvar_helper(qe->chan, "QUEUEPOSITION", posstr);		}
char posstr[20];
char posstr[20];
char
posstr[20]
posstr
[20]
20
q->count--;
q->count--
q->count
q
q
count
if (!q->count) {				ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s", q->name);			}
!q->count
q->count
q
q
count
{				ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s", q->name);			}
ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s", q->name);
ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s", q->name)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_NOT_INUSE
AST_DEVICE_NOT_INUSE
"Queue:%s"
q->name
q
q
name
ast_manager_event(qe->chan, EVENT_FLAG_CALL, "Leave",				"Channel: %s\r\nQueue: %s\r\nCount: %d\r\nPosition: %d\r\nUniqueid: %s\r\n",				ast_channel_name(qe->chan), q->name,  q->count, qe->pos, ast_channel_uniqueid(qe->chan));
ast_manager_event(qe->chan, EVENT_FLAG_CALL, "Leave",				"Channel: %s\r\nQueue: %s\r\nCount: %d\r\nPosition: %d\r\nUniqueid: %s\r\n",				ast_channel_name(qe->chan), q->name,  q->count, qe->pos, ast_channel_uniqueid(qe->chan))
ast_manager_event
ast_manager_event
qe->chan
qe
qe
chan
EVENT_FLAG_CALL
EVENT_FLAG_CALL
"Leave"
"Channel: %s\r\nQueue: %s\r\nCount: %d\r\nPosition: %d\r\nUniqueid: %s\r\n"
ast_channel_name(qe->chan)
ast_channel_name
ast_channel_name
qe->chan
qe
qe
chan
q->name
q
q
name
q->count
q
q
count
qe->pos
qe
qe
pos
ast_channel_uniqueid(qe->chan)
ast_channel_uniqueid
ast_channel_uniqueid
qe->chan
qe
qe
chan
ast_debug(1, "Queue '%s' Leave, Channel '%s'\n", q->name, ast_channel_name(qe->chan));
ast_debug(1, "Queue '%s' Leave, Channel '%s'\n", q->name, ast_channel_name(qe->chan))
ast_debug
ast_debug
1
"Queue '%s' Leave, Channel '%s'\n"
q->name
q
q
name
ast_channel_name(qe->chan)
ast_channel_name
ast_channel_name
qe->chan
qe
qe
chan
if (prev) {				prev->next = current->next;			} else {				q->head = current->next;			}
prev
prev
{				prev->next = current->next;			}
prev->next = current->next;
prev->next = current->next
prev->next
prev
prev
next
current->next
current
current
next
{				q->head = current->next;			}
q->head = current->next;
q->head = current->next
q->head
q
q
head
current->next
current
current
next
while ((pr_iter = AST_LIST_REMOVE_HEAD(&qe->qe_rules, list))) {				ast_free(pr_iter);			}
(pr_iter = AST_LIST_REMOVE_HEAD(&qe->qe_rules, list))
pr_iter = AST_LIST_REMOVE_HEAD(&qe->qe_rules, list)
pr_iter
pr_iter
AST_LIST_REMOVE_HEAD(&qe->qe_rules, list)
AST_LIST_REMOVE_HEAD
AST_LIST_REMOVE_HEAD
&qe->qe_rules
qe->qe_rules
qe
qe
qe_rules
list
list
{				ast_free(pr_iter);			}
ast_free(pr_iter);
ast_free(pr_iter)
ast_free
ast_free
pr_iter
pr_iter
snprintf(posstr, sizeof(posstr), "%d", qe->pos);
snprintf(posstr, sizeof(posstr), "%d", qe->pos)
snprintf
snprintf
posstr
posstr
sizeof(posstr)
(posstr)
posstr
posstr
"%d"
qe->pos
qe
qe
pos
pbx_builtin_setvar_helper(qe->chan, "QUEUEPOSITION", posstr);
pbx_builtin_setvar_helper(qe->chan, "QUEUEPOSITION", posstr)
pbx_builtin_setvar_helper
pbx_builtin_setvar_helper
qe->chan
qe
qe
chan
"QUEUEPOSITION"
posstr
posstr
{			/* Renumber the people after us in the queue based on a new count */			current->pos = ++pos;			prev = current;		}
current->pos = ++pos;
current->pos = ++pos
current->pos
current
current
pos
++pos
pos
pos
prev = current;
prev = current
prev
prev
current
current
ao2_unlock(q);
ao2_unlock(q)
ao2_unlock
ao2_unlock
q
q
if (q->realtime) {		struct ast_variable *var;		if (!(var = ast_load_realtime("queues", "name", q->name, SENTINEL))) {			q->dead = 1;		} else {			ast_variables_destroy(var);		}	}
q->realtime
q
q
realtime
{		struct ast_variable *var;		if (!(var = ast_load_realtime("queues", "name", q->name, SENTINEL))) {			q->dead = 1;		} else {			ast_variables_destroy(var);		}	}
struct ast_variable *var;
struct ast_variable *var;
struct ast_variable
ast_variable
*var
*
var
if (!(var = ast_load_realtime("queues", "name", q->name, SENTINEL))) {			q->dead = 1;		} else {			ast_variables_destroy(var);		}
!(var = ast_load_realtime("queues", "name", q->name, SENTINEL))
(var = ast_load_realtime("queues", "name", q->name, SENTINEL))
var = ast_load_realtime("queues", "name", q->name, SENTINEL)
var
var
ast_load_realtime("queues", "name", q->name, SENTINEL)
ast_load_realtime
ast_load_realtime
"queues"
"name"
q->name
q
q
name
SENTINEL
SENTINEL
{			q->dead = 1;		}
q->dead = 1;
q->dead = 1
q->dead
q
q
dead
1
{			ast_variables_destroy(var);		}
ast_variables_destroy(var);
ast_variables_destroy(var)
ast_variables_destroy
ast_variables_destroy
var
var
if (q->dead) {		/* It's dead and nobody is in it, so kill it */		queues_t_unlink(queues, q, "Queue is now dead; remove it from the container");	}
q->dead
q
q
dead
{		/* It's dead and nobody is in it, so kill it */		queues_t_unlink(queues, q, "Queue is now dead; remove it from the container");	}
queues_t_unlink(queues, q, "Queue is now dead; remove it from the container");
queues_t_unlink(queues, q, "Queue is now dead; remove it from the container")
queues_t_unlink
queues_t_unlink
queues
queues
q
q
"Queue is now dead; remove it from the container"
queue_t_unref(q, "Expire copied reference");
queue_t_unref(q, "Expire copied reference")
queue_t_unref
queue_t_unref
q
q
"Expire copied reference"
-----joern-----
(192,28,0)
(136,111,0)
(139,64,0)
(34,154,0)
(145,87,0)
(122,168,0)
(22,177,0)
(160,41,0)
(142,193,0)
(135,95,0)
(4,127,0)
(2,185,0)
(79,95,0)
(110,189,0)
(26,152,0)
(116,189,0)
(11,23,0)
(38,116,0)
(8,111,0)
(111,89,0)
(120,193,0)
(148,22,0)
(84,69,0)
(20,24,0)
(175,18,0)
(188,162,0)
(64,184,0)
(178,189,0)
(60,163,0)
(193,120,0)
(167,10,0)
(104,136,0)
(165,145,0)
(90,189,0)
(152,137,0)
(127,108,0)
(162,15,0)
(151,27,0)
(10,95,0)
(146,141,0)
(58,25,0)
(0,167,0)
(141,34,0)
(100,80,0)
(46,5,0)
(24,190,0)
(75,76,0)
(23,34,0)
(5,37,0)
(82,63,0)
(63,160,0)
(99,69,0)
(57,4,0)
(67,34,0)
(176,175,0)
(154,34,0)
(21,97,0)
(149,117,0)
(111,95,0)
(172,193,0)
(92,176,0)
(111,87,0)
(10,167,0)
(180,189,0)
(51,151,0)
(98,18,0)
(22,15,0)
(3,136,0)
(33,149,0)
(180,34,0)
(193,95,0)
(27,151,0)
(60,91,0)
(108,127,0)
(103,108,0)
(111,39,0)
(183,5,0)
(137,152,0)
(143,27,0)
(155,98,0)
(89,18,0)
(144,159,0)
(129,34,0)
(97,112,0)
(185,120,0)
(111,19,0)
(66,98,0)
(185,18,0)
(181,78,0)
(97,116,0)
(64,159,0)
(127,4,0)
(123,189,0)
(157,92,0)
(23,189,0)
(138,69,0)
(89,111,0)
(110,34,0)
(168,160,0)
(34,98,0)
(152,95,0)
(52,144,0)
(109,189,0)
(1,189,0)
(12,116,0)
(162,184,0)
(158,45,0)
(40,189,0)
(106,168,0)
(87,111,0)
(164,4,0)
(167,34,0)
(85,111,0)
(53,185,0)
(92,76,0)
(147,18,0)
(119,60,0)
(74,177,0)
(114,89,0)
(177,184,0)
(22,28,0)
(193,25,0)
(73,6,0)
(173,25,0)
(107,180,0)
(162,160,0)
(120,185,0)
(28,189,0)
(102,28,0)
(27,18,0)
(96,89,0)
(170,177,0)
(49,91,0)
(7,127,0)
(150,60,0)
(55,153,0)
(39,34,0)
(71,158,0)
(59,23,0)
(147,160,0)
(141,149,0)
(19,111,0)
(134,189,0)
(130,64,0)
(184,168,0)
(16,189,0)
(86,118,0)
(41,160,0)
(151,95,0)
(15,162,0)
(101,39,0)
(14,118,0)
(124,184,0)
(25,193,0)
(43,100,0)
(140,6,0)
(9,175,0)
(72,19,0)
(19,34,0)
(108,103,0)
(36,111,0)
(29,147,0)
(161,175,0)
(176,92,0)
(177,113,0)
(88,189,0)
(177,160,0)
(61,41,0)
(182,153,0)
(56,141,0)
(112,113,0)
(171,144,0)
(91,60,0)
(111,136,0)
(15,187,0)
(144,34,0)
(6,18,0)
(6,152,0)
(94,145,0)
(105,67,0)
(31,189,0)
(69,99,0)
(63,112,0)
(145,18,0)
(131,127,0)
(191,31,0)
(54,67,0)
(159,64,0)
(132,110,0)
(65,22,0)
(50,153,0)
(136,18,0)
(186,93,0)
(50,111,0)
(81,40,0)
(153,18,0)
(69,34,0)
(98,34,0)
(41,34,0)
(42,5,0)
(47,41,0)
(32,95,0)
(30,108,0)
(152,6,0)
(78,34,0)
(115,91,0)
(83,127,0)
(153,50,0)
(70,151,0)
(100,108,0)
(147,184,0)
(111,50,0)
(64,160,0)
(121,27,0)
(112,97,0)
(31,34,0)
(91,34,0)
(4,34,0)
(133,147,0)
(175,176,0)
(76,92,0)
(158,76,0)
(179,189,0)
(87,145,0)
(5,34,0)
(125,152,0)
(159,17,0)
(39,111,0)
(166,162,0)
(68,31,0)
(168,184,0)
(156,95,0)
(63,184,0)
(62,137,0)
(25,34,0)
(13,160,0)
(35,40,0)
(174,63,0)
(126,39,0)
(169,78,0)
(44,167,0)
(48,19,0)
(5,46,1)
(139,144,1)
(147,18,1)
(132,77,1)
(126,87,1)
(74,112,1)
(13,28,1)
(75,15,1)
(141,34,1)
(158,76,1)
(83,30,1)
(147,133,1)
(78,181,1)
(162,184,1)
(110,34,1)
(141,146,1)
(68,154,1)
(193,25,1)
(170,74,1)
(162,160,1)
(147,184,1)
(63,184,1)
(167,34,1)
(28,192,1)
(22,65,1)
(182,55,1)
(160,41,1)
(185,2,1)
(76,92,1)
(20,23,1)
(175,18,1)
(66,129,1)
(127,4,1)
(122,124,1)
(125,76,1)
(36,136,1)
(4,57,1)
(157,176,1)
(22,28,1)
(87,145,1)
(64,160,1)
(168,106,1)
(147,160,1)
(59,78,1)
(183,78,1)
(89,114,1)
(124,151,1)
(23,11,1)
(77,160,1)
(60,91,1)
(112,97,1)
(121,143,1)
(58,173,1)
(4,34,1)
(102,180,1)
(40,35,1)
(168,184,1)
(176,175,1)
(175,161,1)
(64,130,1)
(54,110,1)
(111,19,1)
(82,147,1)
(78,34,1)
(168,160,1)
(69,138,1)
(30,67,1)
(3,104,1)
(7,4,1)
(188,166,1)
(6,18,1)
(6,73,1)
(62,125,1)
(143,152,1)
(96,19,1)
(159,64,1)
(138,84,1)
(172,142,1)
(162,188,1)
(35,81,1)
(33,141,1)
(11,59,1)
(22,177,1)
(50,153,1)
(173,172,1)
(75,158,1)
(177,184,1)
(19,34,1)
(67,34,1)
(136,18,1)
(108,127,1)
(39,101,1)
(42,183,1)
(120,185,1)
(89,18,1)
(149,33,1)
(111,87,1)
(192,102,1)
(53,25,1)
(64,184,1)
(165,94,1)
(73,140,1)
(98,155,1)
(59,5,1)
(151,27,1)
(169,67,1)
(44,0,1)
(61,47,1)
(191,68,1)
(181,169,1)
(65,148,1)
(25,58,1)
(5,34,1)
(140,26,1)
(10,167,1)
(84,10,1)
(63,174,1)
(169,100,1)
(27,18,1)
(155,66,1)
(136,3,1)
(48,39,1)
(51,70,1)
(92,176,1)
(91,34,1)
(166,22,1)
(94,85,1)
(119,150,1)
(100,108,1)
(177,160,1)
(104,99,1)
(29,77,1)
(8,36,1)
(31,191,1)
(101,126,1)
(174,82,1)
(154,34,1)
(41,34,1)
(27,121,1)
(71,76,1)
(104,60,1)
(184,168,1)
(142,111,1)
(137,62,1)
(171,128,1)
(63,160,1)
(46,42,1)
(152,137,1)
(26,137,1)
(127,7,1)
(47,13,1)
(180,34,1)
(158,71,1)
(111,89,1)
(151,51,1)
(150,99,1)
(70,27,1)
(56,103,1)
(146,56,1)
(107,31,1)
(130,139,1)
(24,154,1)
(161,9,1)
(128,193,1)
(41,61,1)
(9,75,1)
(92,157,1)
(193,120,1)
(103,108,1)
(110,132,1)
(12,40,1)
(100,43,1)
(23,34,1)
(15,162,1)
(145,165,1)
(69,34,1)
(129,116,1)
(72,48,1)
(75,159,1)
(180,107,1)
(98,18,1)
(52,171,1)
(131,83,1)
(153,18,1)
(67,105,1)
(49,119,1)
(57,164,1)
(105,54,1)
(39,34,1)
(99,69,1)
(85,8,1)
(19,72,1)
(167,44,1)
(145,18,1)
(21,63,1)
(152,6,1)
(97,21,1)
(43,103,1)
(111,50,1)
(185,18,1)
(91,115,1)
(31,34,1)
(114,96,1)
(116,38,1)
(148,128,1)
(38,12,1)
(34,98,1)
(25,34,1)
(177,170,1)
(2,53,1)
(111,136,1)
(106,122,1)
(124,177,1)
(144,52,1)
(133,29,1)
(97,116,1)
(20,24,1)
(111,39,1)
(0,147,1)
(115,49,1)
(169,149,1)
(144,34,1)
(153,182,1)
(164,131,1)
(55,89,1)
(77,184,1)
(120,185,2)
(89,147,2)
(2,147,2)
(63,160,2)
(152,137,2)
(153,18,2)
(9,76,2)
(19,147,2)
(160,154,2)
(10,147,2)
(31,34,2)
(111,87,2)
(136,147,2)
(150,99,2)
(141,34,2)
(151,27,2)
(49,99,2)
(173,147,2)
(23,154,2)
(127,67,2)
(60,91,2)
(188,128,2)
(94,147,2)
(151,147,2)
(158,76,2)
(131,67,2)
(193,120,2)
(84,147,2)
(22,177,2)
(43,103,2)
(33,103,2)
(119,99,2)
(5,34,2)
(46,78,2)
(64,160,2)
(137,147,2)
(91,34,2)
(3,147,2)
(27,18,2)
(60,99,2)
(175,18,2)
(183,78,2)
(170,147,2)
(62,147,2)
(44,147,2)
(175,147,2)
(148,128,2)
(174,147,2)
(191,154,2)
(63,184,2)
(97,147,2)
(36,147,2)
(144,128,2)
(41,154,2)
(48,147,2)
(105,154,2)
(61,154,2)
(175,76,2)
(85,147,2)
(181,154,2)
(76,147,2)
(70,147,2)
(54,154,2)
(24,154,2)
(52,128,2)
(177,184,2)
(149,103,2)
(167,34,2)
(101,147,2)
(15,162,2)
(7,67,2)
(136,18,2)
(4,67,2)
(128,147,2)
(78,154,2)
(176,147,2)
(39,34,2)
(172,147,2)
(122,77,2)
(9,147,2)
(82,147,2)
(145,18,2)
(51,147,2)
(72,147,2)
(6,18,2)
(77,77,2)
(26,147,2)
(99,69,2)
(58,147,2)
(102,154,2)
(154,34,2)
(83,67,2)
(140,147,2)
(6,147,2)
(87,147,2)
(107,154,2)
(75,76,2)
(31,154,2)
(11,154,2)
(157,76,2)
(50,153,2)
(71,76,2)
(143,147,2)
(167,147,2)
(124,77,2)
(177,160,2)
(22,28,2)
(111,147,2)
(144,34,2)
(89,18,2)
(185,18,2)
(112,97,2)
(169,154,2)
(34,98,2)
(67,154,2)
(180,34,2)
(65,128,2)
(96,147,2)
(184,77,2)
(184,168,2)
(159,64,2)
(53,147,2)
(161,76,2)
(92,176,2)
(152,6,2)
(171,128,2)
(42,78,2)
(21,147,2)
(147,77,2)
(111,39,2)
(111,50,2)
(162,128,2)
(192,154,2)
(146,103,2)
(133,77,2)
(39,147,2)
(141,103,2)
(111,89,2)
(75,147,2)
(159,128,2)
(69,147,2)
(161,147,2)
(168,160,2)
(185,147,2)
(92,76,2)
(168,184,2)
(22,128,2)
(110,154,2)
(76,76,2)
(115,99,2)
(162,160,2)
(114,147,2)
(27,147,2)
(68,154,2)
(166,128,2)
(74,147,2)
(164,67,2)
(63,147,2)
(138,147,2)
(99,147,2)
(103,67,2)
(145,147,2)
(77,154,2)
(147,160,2)
(168,77,2)
(193,147,2)
(165,147,2)
(120,147,2)
(25,34,2)
(69,34,2)
(87,145,2)
(147,18,2)
(78,34,2)
(13,154,2)
(57,67,2)
(8,147,2)
(92,147,2)
(157,147,2)
(28,154,2)
(176,76,2)
(30,67,2)
(64,184,2)
(177,147,2)
(111,136,2)
(176,175,2)
(25,147,2)
(126,147,2)
(182,147,2)
(130,128,2)
(180,154,2)
(108,127,2)
(108,67,2)
(0,147,2)
(19,34,2)
(110,34,2)
(100,103,2)
(59,154,2)
(55,147,2)
(142,147,2)
(139,128,2)
(103,108,2)
(162,184,2)
(147,184,2)
(152,147,2)
(23,34,2)
(104,147,2)
(73,147,2)
(132,154,2)
(100,108,2)
(121,147,2)
(106,77,2)
(29,77,2)
(15,128,2)
(91,99,2)
(98,18,2)
(111,19,2)
(5,78,2)
(67,34,2)
(64,128,2)
(50,147,2)
(97,116,2)
(125,147,2)
(56,103,2)
(153,147,2)
(41,34,2)
(160,41,2)
(127,4,2)
(112,147,2)
(193,25,2)
(47,154,2)
(4,34,2)
(76,92,2)
(20,24,2)
(10,167,2)
-----------------------------------
(0,q)
(1,if (q->realtime)
(2,chan)
(3,chan)
(4,q->name)
(5,queues_t_unlink(queues, q, "Queue is now dead; remove it from the container")
(6,qe->pos)
(7,SENTINEL)
(8,"Leave")
(9,qe)
(10,q->count--)
(11,"Expire copied reference")
(12,pos)
(13,current)
(14,if (!(var = ast_load_realtime("queues", "name", q->name, SENTINEL)
(15,prev->next = current->next)
(16,for (current = q->head; current; current = current->next)
(17,)
(18,struct queue_ent *qe)
(19,q->count)
(20,RET)
(21,pos)
(22,prev->next)
(23,queue_t_unref(q, "Expire copied reference")
(24,return;)
(25,q->name)
(26,"%d")
(27,qe->chan)
(28,prev = NULL)
(29,current)
(30,var)
(31,queue_t_ref(q, "Copy queue pointer from queue entry")
(32,while ((pr_iter = AST_LIST_REMOVE_HEAD(&qe->qe_rules, list)
(33,1)
(34,q = qe->parent)
(35,NULL)
(36,EVENT_FLAG_CALL)
(37,)
(38,0)
(39,q->name)
(40,*prev = NULL)
(41,q->head)
(42,q)
(43,var)
(44,count)
(45,)
(46,"Queue is now dead; remove it from the container")
(47,q)
(48,q)
(49,q)
(50,ast_channel_uniqueid(qe->chan)
(51,posstr)
(52,head)
(53,qe)
(54,q)
(55,qe)
(56,q)
(57,name)
(58,name)
(59,q)
(60,ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s", q->name)
(61,head)
(62,posstr)
(63,current->pos)
(64,current->next)
(65,next)
(66,qe)
(67,q->realtime)
(68,q)
(69,q->count)
(70,"QUEUEPOSITION")
(71,pr_iter)
(72,count)
(73,pos)
(74,prev)
(75,pr_iter)
(76,pr_iter = AST_LIST_REMOVE_HEAD(&qe->qe_rules, list)
(77,current)
(78,q->dead)
(79,if (!q->count)
(80,)
(81,prev)
(82,current)
(83,"queues")
(84,q)
(85,"Channel: %s\\r\\nQueue: %s\\r\\nCount: %d\\r\\nPosition: %d\\r\\nUniqueid: %s\\r\\n")
(86,var)
(87,ast_channel_name(qe->chan)
(88,current)
(89,qe->pos)
(90,if (!(q = qe->parent)
(91,q->name)
(92,AST_LIST_REMOVE_HEAD(&qe->qe_rules, list)
(93,)
(94,qe)
(95,)
(96,qe)
(97,++pos)
(98,qe->parent)
(99,!q->count)
(100,ast_variables_destroy(var)
(101,name)
(102,prev)
(103,!(var = ast_load_realtime("queues", "name", q->name, SENTINEL)
(104,qe)
(105,realtime)
(106,next)
(107,q)
(108,var = ast_load_realtime("queues", "name", q->name, SENTINEL)
(109,if (q->dead)
(110,ao2_unlock(q)
(111,ast_manager_event(qe->chan, EVENT_FLAG_CALL, "Leave",\n\\n\\t\\t\\t\\t"Channel: %s\\r\\nQueue: %s\\r\\nCount: %d\\r\\nPosition: %d\\r\\nUniqueid: %s\\r\\n",\n\\n\\t\\t\\t\\tast_channel_name(qe->chan)
(112,current->pos = ++pos)
(113,)
(114,pos)
(115,name)
(116,pos = 0)
(117,)
(118,)
(119,"Queue:%s")
(120,ast_channel_name(qe->chan)
(121,chan)
(122,current)
(123,pr_iter)
(124,current)
(125,posstr)
(126,q)
(127,ast_load_realtime("queues", "name", q->name, SENTINEL)
(128,prev)
(129,q)
(130,next)
(131,"name")
(132,q)
(133,qe)
(134,pos)
(135,if (prev)
(136,qe->chan)
(137,sizeof(posstr)
(138,count)
(139,current)
(140,qe)
(141,q->dead)
(142,1)
(143,qe)
(144,q->head)
(145,qe->chan)
(146,dead)
(147,current == qe)
(148,prev)
(149,q->dead = 1)
(150,AST_DEVICE_NOT_INUSE)
(151,pbx_builtin_setvar_helper(qe->chan, "QUEUEPOSITION", posstr)
(152,snprintf(posstr, sizeof(posstr)
(153,qe->chan)
(154,!(q = qe->parent)
(155,parent)
(156,posstr)
(157,list)
(158,ast_free(pr_iter)
(159,q->head = current->next)
(160,current = q->head)
(161,qe_rules)
(162,current->next)
(163,)
(164,q)
(165,chan)
(166,current)
(167,q->count)
(168,current->next)
(169,q)
(170,current)
(171,q)
(172,"Queue \'%s\' Leave, Channel \'%s\'\\n")
(173,q)
(174,pos)
(175,qe->qe_rules)
(176,&qe->qe_rules)
(177,prev = current)
(178,prev)
(179,q)
(180,ao2_lock(q)
(181,dead)
(182,chan)
(183,queues)
(184,current = current->next)
(185,qe->chan)
(186,if (current == qe)
(187,)
(188,next)
(189,)
(190,)
(191,"Copy queue pointer from queue entry")
(192,NULL)
(193,ast_debug(1, "Queue \'%s\' Leave, Channel \'%s\'\\n", q->name, ast_channel_name(qe->chan)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^