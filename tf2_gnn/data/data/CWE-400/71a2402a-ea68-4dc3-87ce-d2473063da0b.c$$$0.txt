-----label-----
0
-----code-----
int
main (int argc, char **argv)
{
  enum header_mode header_mode = multiple_files;
  bool ok = true;
  /* If from_start, the number of items to skip before printing; otherwise,
     the number of items at the end of the file to print.  Although the type
     is signed, the value is never negative.  */
  uintmax_t n_units = DEFAULT_N_LINES;
  size_t n_files;
  char **file;
  struct File_spec *F;
  size_t i;
  bool obsolete_option;

  /* The number of seconds to sleep between iterations.
     During one iteration, every file name or descriptor is checked to
     see if it has changed.  */
  double sleep_interval = 1.0;

  initialize_main (&argc, &argv);
  set_program_name (argv[0]);
  setlocale (LC_ALL, "");
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  atexit (close_stdout);

  have_read_stdin = false;

  count_lines = true;
  forever = from_start = print_headers = false;
  obsolete_option = parse_obsolete_option (argc, argv, &n_units);
  argc -= obsolete_option;
  argv += obsolete_option;
  parse_options (argc, argv, &n_units, &header_mode, &sleep_interval);

  /* To start printing with item N_UNITS from the start of the file, skip
     N_UNITS - 1 items.  'tail -n +0' is actually meaningless, but for Unix
     compatibility it's treated the same as 'tail -n +1'.  */
  if (from_start)
    {
      if (n_units)
        --n_units;
    }

  if (optind < argc)
    {
      n_files = argc - optind;
      file = argv + optind;
    }
  else
    {
      static char *dummy_stdin = (char *) "-";
      n_files = 1;
      file = &dummy_stdin;
    }

  {
    bool found_hyphen = false;

    for (i = 0; i < n_files; i++)
      if (STREQ (file[i], "-"))
        found_hyphen = true;

    /* When following by name, there must be a name.  */
    if (found_hyphen && follow_mode == Follow_name)
      error (EXIT_FAILURE, 0, _("cannot follow %s by name"), quote ("-"));

    /* When following forever, warn if any file is '-'.
       This is only a warning, since tail's output (before a failing seek,
       and that from any non-stdin files) might still be useful.  */
    if (forever && found_hyphen && isatty (STDIN_FILENO))
      error (0, 0, _("warning: following standard input"
                     " indefinitely is ineffective"));
  }

  /* Don't read anything if we'll never output anything.  */
  if (! n_units && ! forever && ! from_start)
    return EXIT_SUCCESS;

  F = xnmalloc (n_files, sizeof *F);
  for (i = 0; i < n_files; i++)
    F[i].name = file[i];

  if (header_mode == always
      || (header_mode == multiple_files && n_files > 1))
    print_headers = true;

  if (O_BINARY && ! isatty (STDOUT_FILENO))
    xfreopen (NULL, "wb", stdout);

  for (i = 0; i < n_files; i++)
    ok &= tail_file (&F[i], n_units);

  if (forever && ignore_fifo_and_pipe (F, n_files))
    {
#if HAVE_INOTIFY
      /* tailable_stdin() checks if the user specifies stdin via  "-",
         or implicitly by providing no arguments. If so, we won't use inotify.
         Technically, on systems with a working /dev/stdin, we *could*,
         but would it be worth it?  Verifying that it's a real device
         and hooked up to stdin is not trivial, while reverting to
         non-inotify-based tail_forever is easy and portable.

         any_remote_file() checks if the user has specified any
         files that reside on remote file systems.  inotify is not used
         in this case because it would miss any updates to the file
         that were not initiated from the local system.

         any_symlinks() checks if the user has specified any symbolic links.
         inotify is not used in this case because it returns updated _targets_
         which would not match the specified names.  If we tried to always
         use the target names, then we would miss changes to the symlink itself.

         ok is false when one of the files specified could not be opened for
         reading.  In this case and when following by descriptor,
         tail_forever_inotify() cannot be used (in its current implementation).

         FIXME: inotify doesn't give any notification when a new
         (remote) file or directory is mounted on top a watched file.
         When follow_mode == Follow_name we would ideally like to detect that.
         Note if there is a change to the original file then we'll
         recheck it and follow the new file, or ignore it if the
         file has changed to being remote.

         FIXME: when using inotify, and a directory for a watched file
         is recreated, then we don't recheck any new file when
         follow_mode == Follow_name  */
      if (!disable_inotify && (tailable_stdin (F, n_files)
                               || any_remote_file (F, n_files)
                               || any_symlinks (F, n_files)
                               || (!ok && follow_mode == Follow_descriptor)))
        disable_inotify = true;

      if (!disable_inotify)
        {
          int wd = inotify_init ();
          if (0 <= wd)
            {
              /* Flush any output from tail_file, now, since
                 tail_forever_inotify flushes only after writing,
                 not before reading.  */
              if (fflush (stdout) != 0)
                error (EXIT_FAILURE, errno, _("write error"));

              if (!tail_forever_inotify (wd, F, n_files, sleep_interval))
                return EXIT_FAILURE;
            }
          error (0, errno, _("inotify cannot be used, reverting to polling"));

          /* Free resources as this process can be long lived,
            and we may have exhausted system resources above.  */

          for (i = 0; i < n_files; i++)
            {
              /* It's OK to remove the same watch multiple times,
                ignoring the EINVAL from redundant calls.  */
              if (F[i].wd != -1)
                inotify_rm_watch (wd, F[i].wd);
              if (F[i].parent_wd != -1)
                inotify_rm_watch (wd, F[i].parent_wd);
            }
        }
#endif
      disable_inotify = true;
      tail_forever (F, n_files, sleep_interval);
    }

  if (have_read_stdin && close (STDIN_FILENO) < 0)
    error (EXIT_FAILURE, errno, "-");
  return ok ? EXIT_SUCCESS : EXIT_FAILURE;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
5,6
5,7
7,8
9,10
9,11
11,12
11,13
11,14
15,16
15,17
15,18
15,19
15,20
15,21
15,22
15,23
15,24
15,25
15,26
15,27
15,28
15,29
15,30
15,31
15,32
15,33
15,34
15,35
15,36
15,37
15,38
15,39
15,40
15,41
15,42
15,43
15,44
15,45
15,46
15,47
15,48
15,49
16,17
17,18
17,19
18,19
20,21
20,22
22,23
23,24
25,26
26,27
26,28
28,29
28,30
30,31
32,33
33,34
33,35
34,35
36,37
36,38
38,39
39,40
41,42
42,43
42,44
43,44
45,46
47,48
48,49
48,50
50,51
50,52
50,53
54,55
55,56
55,57
56,57
58,59
58,60
61,62
62,63
62,64
63,64
65,66
67,68
68,69
68,70
70,71
72,73
73,74
73,75
75,76
75,77
77,78
79,80
80,81
80,82
80,83
81,82
83,84
84,85
86,87
87,88
89,90
90,91
90,92
91,92
93,94
93,95
94,95
97,98
98,99
98,100
98,101
99,100
101,102
104,105
105,106
105,107
105,108
106,107
108,109
110,111
112,113
113,114
113,115
114,115
116,117
117,118
119,120
120,121
120,122
121,122
123,124
124,125
126,127
127,128
127,129
128,129
131,132
132,133
132,134
133,134
136,137
137,138
137,139
138,139
140,141
140,142
141,142
143,144
143,145
144,145
147,148
148,149
148,150
149,150
151,152
151,153
151,154
151,155
152,153
154,155
156,157
158,159
159,160
161,162
162,163
162,164
163,164
165,166
167,168
168,169
168,170
169,170
171,172
173,174
174,175
174,176
174,177
174,178
174,179
174,180
175,176
177,178
179,180
181,182
182,183
184,185
185,186
187,188
188,189
190,191
190,192
191,192
193,194
194,195
194,196
195,196
197,198
198,199
199,200
201,202
201,203
201,204
202,203
202,204
203,204
205,206
207,208
207,209
208,209
209,210
209,211
210,211
212,213
212,214
213,214
215,216
217,218
218,219
218,220
219,220
221,222
221,223
222,223
224,225
226,227
226,228
226,229
227,228
228,229
228,230
230,231
230,232
230,233
233,234
234,235
234,236
235,236
235,237
237,238
240,241
241,242
241,243
242,243
245,246
246,247
246,248
247,248
249,250
250,251
252,253
252,254
252,255
252,256
253,254
254,255
254,256
256,257
256,258
258,259
260,261
260,262
260,263
260,264
261,262
262,263
262,264
263,264
266,267
266,268
267,268
269,270
271,272
272,273
274,275
274,276
275,276
275,277
275,278
276,277
278,279
278,280
279,280
281,282
284,285
285,286
285,287
286,287
289,290
289,291
290,291
290,292
291,292
293,294
293,295
294,295
296,297
298,299
299,300
299,301
299,302
299,303
299,304
300,301
302,303
305,306
305,307
306,307
309,310
309,311
310,311
313,314
313,315
314,315
314,316
315,316
315,317
316,317
318,319
320,321
320,322
321,322
323,324
325,326
326,327
326,328
326,329
326,330
327,328
331,332
331,333
332,333
335,336
335,337
336,337
336,338
337,338
337,339
338,339
339,340
341,342
342,343
344,345
345,346
347,348
348,349
350,351
351,352
351,353
352,353
354,355
354,356
354,357
355,356
357,358
359,360
360,361
361,362
363,364
363,365
363,366
363,367
364,365
365,366
365,367
366,367
369,370
369,371
370,371
372,373
374,375
375,376
377,378
378,379
378,380
379,380
379,381
380,381
380,382
381,382
383,384
386,387
386,388
387,388
389,390
391,392
391,393
392,393
392,394
393,394
393,395
394,395
396,397
398,399
399,400
399,401
400,401
400,402
401,402
403,404
405,406
405,407
406,407
409,410
410,411
410,412
411,412
414,415
414,416
415,416
415,417
416,417
418,419
419,420
419,421
420,421
422,423
424,425
425,426
425,427
425,428
425,429
426,427
428,429
431,432
433,434
433,435
433,436
433,437
434,435
435,436
435,437
436,437
439,440
439,441
440,441
442,443
444,445
445,446
447,448
448,449
448,450
449,450
451,452
451,453
451,454
452,453
454,455
455,456
455,457
456,457
458,459
460,461
462,463
462,464
463,464
463,465
464,465
466,467
466,468
466,469
467,468
469,470
471,472
473,474
473,475
474,475
475,476
475,477
476,477
479,480
480,481
480,482
480,483
480,484
481,482
483,484
485,486
487,488
489,490
489,491
490,491
490,492
491,492
493,494
493,495
494,495
494,496
495,496
497,498
500,501
501,502
501,503
501,504
501,505
502,503
504,505
506,507
509,510
510,511
510,512
510,513
511,512
513,514
515,516
-----nextToken-----
2,4,6,8,10,12,13,14,19,21,24,27,29,31,35,37,40,44,46,49,51,52,53,57,59,60,64,66,69,71,74,76,78,82,85,88,92,95,96,100,102,103,107,109,111,115,118,122,125,129,130,134,135,139,142,145,146,150,153,155,157,160,164,166,170,172,176,178,180,183,186,189,192,196,200,204,206,211,214,216,220,223,225,229,231,232,236,238,239,243,244,248,251,255,257,259,264,265,268,270,273,277,280,282,283,287,288,292,295,297,301,303,304,307,308,311,312,317,319,322,324,328,329,330,333,334,340,343,346,349,353,356,358,362,367,368,371,373,376,382,384,385,388,390,395,397,402,404,407,408,412,413,417,421,423,427,429,430,432,437,438,441,443,446,450,453,457,459,461,465,468,470,472,477,478,482,484,486,488,492,496,498,499,503,505,507,508,512,514,516
-----computeFrom-----
127,128
127,129
132,133
132,134
137,138
137,139
140,141
140,142
143,144
143,145
148,149
148,150
162,163
162,164
168,169
168,170
202,203
202,204
209,210
209,211
212,213
212,214
218,219
218,220
221,222
221,223
241,242
241,243
246,247
246,248
262,263
262,264
266,267
266,268
285,286
285,287
290,291
290,292
293,294
293,295
314,315
314,316
315,316
315,317
336,337
336,338
337,338
337,339
351,352
351,353
365,366
365,367
369,370
369,371
378,379
378,380
392,393
392,394
393,394
393,395
399,400
399,401
400,401
400,402
405,406
405,407
410,411
410,412
415,416
415,417
435,436
435,437
439,440
439,441
448,449
448,450
463,464
463,465
475,476
475,477
490,491
490,492
493,494
493,495
-----guardedBy-----
206,214
204,225
470,484
472,486
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;IfStatement;IdExpression;Name;ExpressionStatement;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;EqualsInitializer;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;BinaryExpression;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ReturnStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;UnaryExpression;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;Name;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;BinaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;BinaryExpression;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IdExpression;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;ReturnStatement;ConditionalExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;
-----ast_node-----
intmain (int argc, char **argv){  enum header_mode header_mode = multiple_files;  bool ok = true;  /* If from_start, the number of items to skip before printing; otherwise,     the number of items at the end of the file to print.  Although the type     is signed, the value is never negative.  */  uintmax_t n_units = DEFAULT_N_LINES;  size_t n_files;  char **file;  struct File_spec *F;  size_t i;  bool obsolete_option;  /* The number of seconds to sleep between iterations.     During one iteration, every file name or descriptor is checked to     see if it has changed.  */  double sleep_interval = 1.0;  initialize_main (&argc, &argv);  set_program_name (argv[0]);  setlocale (LC_ALL, "");  bindtextdomain (PACKAGE, LOCALEDIR);  textdomain (PACKAGE);  atexit (close_stdout);  have_read_stdin = false;  count_lines = true;  forever = from_start = print_headers = false;  obsolete_option = parse_obsolete_option (argc, argv, &n_units);  argc -= obsolete_option;  argv += obsolete_option;  parse_options (argc, argv, &n_units, &header_mode, &sleep_interval);  /* To start printing with item N_UNITS from the start of the file, skip     N_UNITS - 1 items.  'tail -n +0' is actually meaningless, but for Unix     compatibility it's treated the same as 'tail -n +1'.  */  if (from_start)    {      if (n_units)        --n_units;    }  if (optind < argc)    {      n_files = argc - optind;      file = argv + optind;    }  else    {      static char *dummy_stdin = (char *) "-";      n_files = 1;      file = &dummy_stdin;    }  {    bool found_hyphen = false;    for (i = 0; i < n_files; i++)      if (STREQ (file[i], "-"))        found_hyphen = true;    /* When following by name, there must be a name.  */    if (found_hyphen && follow_mode == Follow_name)      error (EXIT_FAILURE, 0, _("cannot follow %s by name"), quote ("-"));    /* When following forever, warn if any file is '-'.       This is only a warning, since tail's output (before a failing seek,       and that from any non-stdin files) might still be useful.  */    if (forever && found_hyphen && isatty (STDIN_FILENO))      error (0, 0, _("warning: following standard input"                     " indefinitely is ineffective"));  }  /* Don't read anything if we'll never output anything.  */  if (! n_units && ! forever && ! from_start)    return EXIT_SUCCESS;  F = xnmalloc (n_files, sizeof *F);  for (i = 0; i < n_files; i++)    F[i].name = file[i];  if (header_mode == always      || (header_mode == multiple_files && n_files > 1))    print_headers = true;  if (O_BINARY && ! isatty (STDOUT_FILENO))    xfreopen (NULL, "wb", stdout);  for (i = 0; i < n_files; i++)    ok &= tail_file (&F[i], n_units);  if (forever && ignore_fifo_and_pipe (F, n_files))    {#if HAVE_INOTIFY      /* tailable_stdin() checks if the user specifies stdin via  "-",         or implicitly by providing no arguments. If so, we won't use inotify.         Technically, on systems with a working /dev/stdin, we *could*,         but would it be worth it?  Verifying that it's a real device         and hooked up to stdin is not trivial, while reverting to         non-inotify-based tail_forever is easy and portable.         any_remote_file() checks if the user has specified any         files that reside on remote file systems.  inotify is not used         in this case because it would miss any updates to the file         that were not initiated from the local system.         any_symlinks() checks if the user has specified any symbolic links.         inotify is not used in this case because it returns updated _targets_         which would not match the specified names.  If we tried to always         use the target names, then we would miss changes to the symlink itself.         ok is false when one of the files specified could not be opened for         reading.  In this case and when following by descriptor,         tail_forever_inotify() cannot be used (in its current implementation).         FIXME: inotify doesn't give any notification when a new         (remote) file or directory is mounted on top a watched file.         When follow_mode == Follow_name we would ideally like to detect that.         Note if there is a change to the original file then we'll         recheck it and follow the new file, or ignore it if the         file has changed to being remote.         FIXME: when using inotify, and a directory for a watched file         is recreated, then we don't recheck any new file when         follow_mode == Follow_name  */      if (!disable_inotify && (tailable_stdin (F, n_files)                               || any_remote_file (F, n_files)                               || any_symlinks (F, n_files)                               || (!ok && follow_mode == Follow_descriptor)))        disable_inotify = true;      if (!disable_inotify)        {          int wd = inotify_init ();          if (0 <= wd)            {              /* Flush any output from tail_file, now, since                 tail_forever_inotify flushes only after writing,                 not before reading.  */              if (fflush (stdout) != 0)                error (EXIT_FAILURE, errno, _("write error"));              if (!tail_forever_inotify (wd, F, n_files, sleep_interval))                return EXIT_FAILURE;            }          error (0, errno, _("inotify cannot be used, reverting to polling"));          /* Free resources as this process can be long lived,            and we may have exhausted system resources above.  */          for (i = 0; i < n_files; i++)            {              /* It's OK to remove the same watch multiple times,                ignoring the EINVAL from redundant calls.  */              if (F[i].wd != -1)                inotify_rm_watch (wd, F[i].wd);              if (F[i].parent_wd != -1)                inotify_rm_watch (wd, F[i].parent_wd);            }        }#endif      disable_inotify = true;      tail_forever (F, n_files, sleep_interval);    }  if (have_read_stdin && close (STDIN_FILENO) < 0)    error (EXIT_FAILURE, errno, "-");  return ok ? EXIT_SUCCESS : EXIT_FAILURE;}
int
main (int argc, char **argv)
main
int argc
int
argc
argc
char **argv
char
**argv
*
*
argv
{  enum header_mode header_mode = multiple_files;  bool ok = true;  /* If from_start, the number of items to skip before printing; otherwise,     the number of items at the end of the file to print.  Although the type     is signed, the value is never negative.  */  uintmax_t n_units = DEFAULT_N_LINES;  size_t n_files;  char **file;  struct File_spec *F;  size_t i;  bool obsolete_option;  /* The number of seconds to sleep between iterations.     During one iteration, every file name or descriptor is checked to     see if it has changed.  */  double sleep_interval = 1.0;  initialize_main (&argc, &argv);  set_program_name (argv[0]);  setlocale (LC_ALL, "");  bindtextdomain (PACKAGE, LOCALEDIR);  textdomain (PACKAGE);  atexit (close_stdout);  have_read_stdin = false;  count_lines = true;  forever = from_start = print_headers = false;  obsolete_option = parse_obsolete_option (argc, argv, &n_units);  argc -= obsolete_option;  argv += obsolete_option;  parse_options (argc, argv, &n_units, &header_mode, &sleep_interval);  /* To start printing with item N_UNITS from the start of the file, skip     N_UNITS - 1 items.  'tail -n +0' is actually meaningless, but for Unix     compatibility it's treated the same as 'tail -n +1'.  */  if (from_start)    {      if (n_units)        --n_units;    }  if (optind < argc)    {      n_files = argc - optind;      file = argv + optind;    }  else    {      static char *dummy_stdin = (char *) "-";      n_files = 1;      file = &dummy_stdin;    }  {    bool found_hyphen = false;    for (i = 0; i < n_files; i++)      if (STREQ (file[i], "-"))        found_hyphen = true;    /* When following by name, there must be a name.  */    if (found_hyphen && follow_mode == Follow_name)      error (EXIT_FAILURE, 0, _("cannot follow %s by name"), quote ("-"));    /* When following forever, warn if any file is '-'.       This is only a warning, since tail's output (before a failing seek,       and that from any non-stdin files) might still be useful.  */    if (forever && found_hyphen && isatty (STDIN_FILENO))      error (0, 0, _("warning: following standard input"                     " indefinitely is ineffective"));  }  /* Don't read anything if we'll never output anything.  */  if (! n_units && ! forever && ! from_start)    return EXIT_SUCCESS;  F = xnmalloc (n_files, sizeof *F);  for (i = 0; i < n_files; i++)    F[i].name = file[i];  if (header_mode == always      || (header_mode == multiple_files && n_files > 1))    print_headers = true;  if (O_BINARY && ! isatty (STDOUT_FILENO))    xfreopen (NULL, "wb", stdout);  for (i = 0; i < n_files; i++)    ok &= tail_file (&F[i], n_units);  if (forever && ignore_fifo_and_pipe (F, n_files))    {#if HAVE_INOTIFY      /* tailable_stdin() checks if the user specifies stdin via  "-",         or implicitly by providing no arguments. If so, we won't use inotify.         Technically, on systems with a working /dev/stdin, we *could*,         but would it be worth it?  Verifying that it's a real device         and hooked up to stdin is not trivial, while reverting to         non-inotify-based tail_forever is easy and portable.         any_remote_file() checks if the user has specified any         files that reside on remote file systems.  inotify is not used         in this case because it would miss any updates to the file         that were not initiated from the local system.         any_symlinks() checks if the user has specified any symbolic links.         inotify is not used in this case because it returns updated _targets_         which would not match the specified names.  If we tried to always         use the target names, then we would miss changes to the symlink itself.         ok is false when one of the files specified could not be opened for         reading.  In this case and when following by descriptor,         tail_forever_inotify() cannot be used (in its current implementation).         FIXME: inotify doesn't give any notification when a new         (remote) file or directory is mounted on top a watched file.         When follow_mode == Follow_name we would ideally like to detect that.         Note if there is a change to the original file then we'll         recheck it and follow the new file, or ignore it if the         file has changed to being remote.         FIXME: when using inotify, and a directory for a watched file         is recreated, then we don't recheck any new file when         follow_mode == Follow_name  */      if (!disable_inotify && (tailable_stdin (F, n_files)                               || any_remote_file (F, n_files)                               || any_symlinks (F, n_files)                               || (!ok && follow_mode == Follow_descriptor)))        disable_inotify = true;      if (!disable_inotify)        {          int wd = inotify_init ();          if (0 <= wd)            {              /* Flush any output from tail_file, now, since                 tail_forever_inotify flushes only after writing,                 not before reading.  */              if (fflush (stdout) != 0)                error (EXIT_FAILURE, errno, _("write error"));              if (!tail_forever_inotify (wd, F, n_files, sleep_interval))                return EXIT_FAILURE;            }          error (0, errno, _("inotify cannot be used, reverting to polling"));          /* Free resources as this process can be long lived,            and we may have exhausted system resources above.  */          for (i = 0; i < n_files; i++)            {              /* It's OK to remove the same watch multiple times,                ignoring the EINVAL from redundant calls.  */              if (F[i].wd != -1)                inotify_rm_watch (wd, F[i].wd);              if (F[i].parent_wd != -1)                inotify_rm_watch (wd, F[i].parent_wd);            }        }#endif      disable_inotify = true;      tail_forever (F, n_files, sleep_interval);    }  if (have_read_stdin && close (STDIN_FILENO) < 0)    error (EXIT_FAILURE, errno, "-");  return ok ? EXIT_SUCCESS : EXIT_FAILURE;}
enum header_mode header_mode = multiple_files;
enum header_mode header_mode = multiple_files;
enum header_mode
header_mode
header_mode = multiple_files
header_mode
= multiple_files
multiple_files
multiple_files
bool ok = true;
bool ok = true;
bool
ok = true
ok
= true
true
uintmax_t n_units = DEFAULT_N_LINES;
uintmax_t n_units = DEFAULT_N_LINES;
uintmax_t
uintmax_t
n_units = DEFAULT_N_LINES
n_units
= DEFAULT_N_LINES
DEFAULT_N_LINES
DEFAULT_N_LINES
size_t n_files;
size_t n_files;
size_t
size_t
n_files
n_files
char **file;
char **file;
char
**file
*
*
file
struct File_spec *F;
struct File_spec *F;
struct File_spec
File_spec
*F
*
F
size_t i;
size_t i;
size_t
size_t
i
i
bool obsolete_option;
bool obsolete_option;
bool
obsolete_option
obsolete_option
double sleep_interval = 1.0;
double sleep_interval = 1.0;
double
sleep_interval = 1.0
sleep_interval
= 1.0
1.0
initialize_main (&argc, &argv);
initialize_main (&argc, &argv)
initialize_main
initialize_main
&argc
argc
argc
&argv
argv
argv
set_program_name (argv[0]);
set_program_name (argv[0])
set_program_name
set_program_name
argv[0]
argv
argv
0
setlocale (LC_ALL, "");
setlocale (LC_ALL, "")
setlocale
setlocale
LC_ALL
LC_ALL
""
bindtextdomain (PACKAGE, LOCALEDIR);
bindtextdomain (PACKAGE, LOCALEDIR)
bindtextdomain
bindtextdomain
PACKAGE
PACKAGE
LOCALEDIR
LOCALEDIR
textdomain (PACKAGE);
textdomain (PACKAGE);
textdomain
textdomain
(PACKAGE)
PACKAGE
PACKAGE
atexit (close_stdout);
atexit (close_stdout);
atexit
atexit
(close_stdout)
close_stdout
close_stdout
have_read_stdin = false;
have_read_stdin = false
have_read_stdin
have_read_stdin
false
count_lines = true;
count_lines = true
count_lines
count_lines
true
forever = from_start = print_headers = false;
forever = from_start = print_headers = false
forever
forever
from_start = print_headers = false
from_start
from_start
print_headers = false
print_headers
print_headers
false
obsolete_option = parse_obsolete_option (argc, argv, &n_units);
obsolete_option = parse_obsolete_option (argc, argv, &n_units)
obsolete_option
obsolete_option
parse_obsolete_option (argc, argv, &n_units)
parse_obsolete_option
parse_obsolete_option
argc
argc
argv
argv
&n_units
n_units
n_units
argc -= obsolete_option;
argc -= obsolete_option
argc
argc
obsolete_option
obsolete_option
argv += obsolete_option;
argv += obsolete_option
argv
argv
obsolete_option
obsolete_option
parse_options (argc, argv, &n_units, &header_mode, &sleep_interval);
parse_options (argc, argv, &n_units, &header_mode, &sleep_interval)
parse_options
parse_options
argc
argc
argv
argv
&n_units
n_units
n_units
&header_mode
header_mode
header_mode
&sleep_interval
sleep_interval
sleep_interval
if (from_start)    {      if (n_units)        --n_units;    }
from_start
from_start
{      if (n_units)        --n_units;    }
if (n_units)        --n_units;
n_units
n_units
--n_units;
--n_units
n_units
n_units
if (optind < argc)    {      n_files = argc - optind;      file = argv + optind;    }  else    {      static char *dummy_stdin = (char *) "-";      n_files = 1;      file = &dummy_stdin;    }
optind < argc
optind
optind
argc
argc
{      n_files = argc - optind;      file = argv + optind;    }
n_files = argc - optind;
n_files = argc - optind
n_files
n_files
argc - optind
argc
argc
optind
optind
file = argv + optind;
file = argv + optind
file
file
argv + optind
argv
argv
optind
optind
{      static char *dummy_stdin = (char *) "-";      n_files = 1;      file = &dummy_stdin;    }
static char *dummy_stdin = (char *) "-";
static char *dummy_stdin = (char *) "-";
static char
*dummy_stdin = (char *) "-"
*
dummy_stdin
= (char *) "-"
(char *) "-"
char *
char
*
*
"-"
n_files = 1;
n_files = 1
n_files
n_files
1
file = &dummy_stdin;
file = &dummy_stdin
file
file
&dummy_stdin
dummy_stdin
dummy_stdin
{    bool found_hyphen = false;    for (i = 0; i < n_files; i++)      if (STREQ (file[i], "-"))        found_hyphen = true;    /* When following by name, there must be a name.  */    if (found_hyphen && follow_mode == Follow_name)      error (EXIT_FAILURE, 0, _("cannot follow %s by name"), quote ("-"));    /* When following forever, warn if any file is '-'.       This is only a warning, since tail's output (before a failing seek,       and that from any non-stdin files) might still be useful.  */    if (forever && found_hyphen && isatty (STDIN_FILENO))      error (0, 0, _("warning: following standard input"                     " indefinitely is ineffective"));  }
bool found_hyphen = false;
bool found_hyphen = false;
bool
found_hyphen = false
found_hyphen
= false
false
for (i = 0; i < n_files; i++)      if (STREQ (file[i], "-"))        found_hyphen = true;
i = 0;
i = 0
i
i
0
i < n_files
i
i
n_files
n_files
i++
i
i
if (STREQ (file[i], "-"))        found_hyphen = true;
STREQ (file[i], "-")
STREQ
STREQ
file[i]
file
file
i
i
"-"
found_hyphen = true;
found_hyphen = true
found_hyphen
found_hyphen
true
if (found_hyphen && follow_mode == Follow_name)      error (EXIT_FAILURE, 0, _("cannot follow %s by name"), quote ("-"));
found_hyphen && follow_mode == Follow_name
found_hyphen
found_hyphen
follow_mode == Follow_name
follow_mode
follow_mode
Follow_name
Follow_name
error (EXIT_FAILURE, 0, _("cannot follow %s by name"), quote ("-"));
error (EXIT_FAILURE, 0, _("cannot follow %s by name"), quote ("-"))
error
error
EXIT_FAILURE
EXIT_FAILURE
0
_("cannot follow %s by name")
_
_
"cannot follow %s by name"
quote ("-")
quote
quote
"-"
if (forever && found_hyphen && isatty (STDIN_FILENO))      error (0, 0, _("warning: following standard input"                     " indefinitely is ineffective"));
forever && found_hyphen && isatty (STDIN_FILENO)
forever && found_hyphen
forever
forever
found_hyphen
found_hyphen
isatty (STDIN_FILENO)
isatty
isatty
STDIN_FILENO
STDIN_FILENO
error (0, 0, _("warning: following standard input"                     " indefinitely is ineffective"));
error (0, 0, _("warning: following standard input"                     " indefinitely is ineffective"))
error
error
0
0
_("warning: following standard input"                     " indefinitely is ineffective")
_
_
"warning: following standard input"                     " indefinitely is ineffective"
if (! n_units && ! forever && ! from_start)    return EXIT_SUCCESS;
! n_units && ! forever && ! from_start
! n_units && ! forever
! n_units
n_units
n_units
! forever
forever
forever
! from_start
from_start
from_start
return EXIT_SUCCESS;
EXIT_SUCCESS
EXIT_SUCCESS
F = xnmalloc (n_files, sizeof *F);
F = xnmalloc (n_files, sizeof *F)
F
F
xnmalloc (n_files, sizeof *F)
xnmalloc
xnmalloc
n_files
n_files
sizeof *F
*F
F
F
for (i = 0; i < n_files; i++)    F[i].name = file[i];
i = 0;
i = 0
i
i
0
i < n_files
i
i
n_files
n_files
i++
i
i
F[i].name = file[i];
F[i].name = file[i]
F[i].name
F[i]
F
F
i
i
name
file[i]
file
file
i
i
if (header_mode == always      || (header_mode == multiple_files && n_files > 1))    print_headers = true;
header_mode == always      || (header_mode == multiple_files && n_files > 1)
header_mode == always
header_mode
header_mode
always
always
(header_mode == multiple_files && n_files > 1)
header_mode == multiple_files && n_files > 1
header_mode == multiple_files
header_mode
header_mode
multiple_files
multiple_files
n_files > 1
n_files
n_files
1
print_headers = true;
print_headers = true
print_headers
print_headers
true
if (O_BINARY && ! isatty (STDOUT_FILENO))    xfreopen (NULL, "wb", stdout);
O_BINARY && ! isatty (STDOUT_FILENO)
O_BINARY
O_BINARY
! isatty (STDOUT_FILENO)
isatty (STDOUT_FILENO)
isatty
isatty
STDOUT_FILENO
STDOUT_FILENO
xfreopen (NULL, "wb", stdout);
xfreopen (NULL, "wb", stdout)
xfreopen
xfreopen
NULL
NULL
"wb"
stdout
stdout
for (i = 0; i < n_files; i++)    ok &= tail_file (&F[i], n_units);
i = 0;
i = 0
i
i
0
i < n_files
i
i
n_files
n_files
i++
i
i
ok &= tail_file (&F[i], n_units);
ok &= tail_file (&F[i], n_units)
ok
ok
tail_file (&F[i], n_units)
tail_file
tail_file
&F[i]
F[i]
F
F
i
i
n_units
n_units
if (forever && ignore_fifo_and_pipe (F, n_files))    {#if HAVE_INOTIFY      /* tailable_stdin() checks if the user specifies stdin via  "-",         or implicitly by providing no arguments. If so, we won't use inotify.         Technically, on systems with a working /dev/stdin, we *could*,         but would it be worth it?  Verifying that it's a real device         and hooked up to stdin is not trivial, while reverting to         non-inotify-based tail_forever is easy and portable.         any_remote_file() checks if the user has specified any         files that reside on remote file systems.  inotify is not used         in this case because it would miss any updates to the file         that were not initiated from the local system.         any_symlinks() checks if the user has specified any symbolic links.         inotify is not used in this case because it returns updated _targets_         which would not match the specified names.  If we tried to always         use the target names, then we would miss changes to the symlink itself.         ok is false when one of the files specified could not be opened for         reading.  In this case and when following by descriptor,         tail_forever_inotify() cannot be used (in its current implementation).         FIXME: inotify doesn't give any notification when a new         (remote) file or directory is mounted on top a watched file.         When follow_mode == Follow_name we would ideally like to detect that.         Note if there is a change to the original file then we'll         recheck it and follow the new file, or ignore it if the         file has changed to being remote.         FIXME: when using inotify, and a directory for a watched file         is recreated, then we don't recheck any new file when         follow_mode == Follow_name  */      if (!disable_inotify && (tailable_stdin (F, n_files)                               || any_remote_file (F, n_files)                               || any_symlinks (F, n_files)                               || (!ok && follow_mode == Follow_descriptor)))        disable_inotify = true;      if (!disable_inotify)        {          int wd = inotify_init ();          if (0 <= wd)            {              /* Flush any output from tail_file, now, since                 tail_forever_inotify flushes only after writing,                 not before reading.  */              if (fflush (stdout) != 0)                error (EXIT_FAILURE, errno, _("write error"));              if (!tail_forever_inotify (wd, F, n_files, sleep_interval))                return EXIT_FAILURE;            }          error (0, errno, _("inotify cannot be used, reverting to polling"));          /* Free resources as this process can be long lived,            and we may have exhausted system resources above.  */          for (i = 0; i < n_files; i++)            {              /* It's OK to remove the same watch multiple times,                ignoring the EINVAL from redundant calls.  */              if (F[i].wd != -1)                inotify_rm_watch (wd, F[i].wd);              if (F[i].parent_wd != -1)                inotify_rm_watch (wd, F[i].parent_wd);            }        }#endif      disable_inotify = true;      tail_forever (F, n_files, sleep_interval);    }
forever && ignore_fifo_and_pipe (F, n_files)
forever
forever
ignore_fifo_and_pipe (F, n_files)
ignore_fifo_and_pipe
ignore_fifo_and_pipe
F
F
n_files
n_files
{#if HAVE_INOTIFY      /* tailable_stdin() checks if the user specifies stdin via  "-",         or implicitly by providing no arguments. If so, we won't use inotify.         Technically, on systems with a working /dev/stdin, we *could*,         but would it be worth it?  Verifying that it's a real device         and hooked up to stdin is not trivial, while reverting to         non-inotify-based tail_forever is easy and portable.         any_remote_file() checks if the user has specified any         files that reside on remote file systems.  inotify is not used         in this case because it would miss any updates to the file         that were not initiated from the local system.         any_symlinks() checks if the user has specified any symbolic links.         inotify is not used in this case because it returns updated _targets_         which would not match the specified names.  If we tried to always         use the target names, then we would miss changes to the symlink itself.         ok is false when one of the files specified could not be opened for         reading.  In this case and when following by descriptor,         tail_forever_inotify() cannot be used (in its current implementation).         FIXME: inotify doesn't give any notification when a new         (remote) file or directory is mounted on top a watched file.         When follow_mode == Follow_name we would ideally like to detect that.         Note if there is a change to the original file then we'll         recheck it and follow the new file, or ignore it if the         file has changed to being remote.         FIXME: when using inotify, and a directory for a watched file         is recreated, then we don't recheck any new file when         follow_mode == Follow_name  */      if (!disable_inotify && (tailable_stdin (F, n_files)                               || any_remote_file (F, n_files)                               || any_symlinks (F, n_files)                               || (!ok && follow_mode == Follow_descriptor)))        disable_inotify = true;      if (!disable_inotify)        {          int wd = inotify_init ();          if (0 <= wd)            {              /* Flush any output from tail_file, now, since                 tail_forever_inotify flushes only after writing,                 not before reading.  */              if (fflush (stdout) != 0)                error (EXIT_FAILURE, errno, _("write error"));              if (!tail_forever_inotify (wd, F, n_files, sleep_interval))                return EXIT_FAILURE;            }          error (0, errno, _("inotify cannot be used, reverting to polling"));          /* Free resources as this process can be long lived,            and we may have exhausted system resources above.  */          for (i = 0; i < n_files; i++)            {              /* It's OK to remove the same watch multiple times,                ignoring the EINVAL from redundant calls.  */              if (F[i].wd != -1)                inotify_rm_watch (wd, F[i].wd);              if (F[i].parent_wd != -1)                inotify_rm_watch (wd, F[i].parent_wd);            }        }#endif      disable_inotify = true;      tail_forever (F, n_files, sleep_interval);    }
disable_inotify = true;
disable_inotify = true
disable_inotify
disable_inotify
true
tail_forever (F, n_files, sleep_interval);
tail_forever (F, n_files, sleep_interval)
tail_forever
tail_forever
F
F
n_files
n_files
sleep_interval
sleep_interval
if (have_read_stdin && close (STDIN_FILENO) < 0)    error (EXIT_FAILURE, errno, "-");
have_read_stdin && close (STDIN_FILENO) < 0
have_read_stdin
have_read_stdin
close (STDIN_FILENO) < 0
close (STDIN_FILENO)
close
close
STDIN_FILENO
STDIN_FILENO
0
error (EXIT_FAILURE, errno, "-");
error (EXIT_FAILURE, errno, "-")
error
error
EXIT_FAILURE
EXIT_FAILURE
errno
errno
"-"
return ok ? EXIT_SUCCESS : EXIT_FAILURE;
ok ? EXIT_SUCCESS : EXIT_FAILURE
ok
ok
EXIT_SUCCESS
EXIT_SUCCESS
EXIT_FAILURE
EXIT_FAILURE
-----joern-----
(153,197,0)
(156,234,0)
(289,286,0)
(74,220,0)
(224,178,0)
(171,129,0)
(270,47,0)
(153,301,0)
(285,57,0)
(188,200,0)
(121,107,0)
(79,197,0)
(31,33,0)
(158,228,0)
(127,160,0)
(134,10,0)
(306,178,0)
(187,245,0)
(287,20,0)
(168,129,0)
(32,342,0)
(16,190,0)
(240,197,0)
(162,153,0)
(4,45,0)
(215,121,0)
(150,245,0)
(16,228,0)
(294,369,0)
(117,116,0)
(4,194,0)
(146,34,0)
(340,278,0)
(339,288,0)
(103,247,0)
(57,193,0)
(291,305,0)
(304,174,0)
(153,188,0)
(172,21,0)
(286,289,0)
(59,373,0)
(360,97,0)
(107,121,0)
(28,54,0)
(171,367,0)
(309,129,0)
(309,194,0)
(324,34,0)
(156,113,0)
(289,242,0)
(373,59,0)
(73,220,0)
(229,148,0)
(37,16,0)
(216,182,0)
(45,273,0)
(347,269,0)
(33,129,0)
(178,15,0)
(171,194,0)
(121,68,0)
(72,217,0)
(2,134,0)
(245,40,0)
(370,194,0)
(330,286,0)
(22,197,0)
(77,6,0)
(299,255,0)
(323,277,0)
(114,44,0)
(33,194,0)
(180,181,0)
(164,116,0)
(357,154,0)
(153,248,0)
(364,367,0)
(204,50,0)
(149,216,0)
(347,303,0)
(183,156,0)
(53,158,0)
(78,275,0)
(365,247,0)
(278,154,0)
(68,121,0)
(343,253,0)
(68,154,0)
(103,331,0)
(15,197,0)
(42,369,0)
(260,74,0)
(261,288,0)
(361,258,0)
(97,367,0)
(182,216,0)
(317,74,0)
(155,200,0)
(122,342,0)
(82,162,0)
(369,42,0)
(11,171,0)
(327,367,0)
(148,229,0)
(101,59,0)
(311,113,0)
(49,258,0)
(162,20,0)
(336,18,0)
(358,196,0)
(129,113,0)
(252,20,0)
(331,103,0)
(245,150,0)
(362,160,0)
(327,129,0)
(262,227,0)
(328,364,0)
(70,252,0)
(229,200,0)
(255,29,0)
(284,55,0)
(46,197,0)
(27,96,0)
(107,370,0)
(363,251,0)
(57,255,0)
(165,197,0)
(207,197,0)
(241,255,0)
(259,265,0)
(41,197,0)
(233,129,0)
(100,197,0)
(188,197,0)
(217,255,0)
(296,226,0)
(28,265,0)
(92,227,0)
(335,168,0)
(36,369,0)
(206,291,0)
(74,194,0)
(253,197,0)
(184,188,0)
(126,171,0)
(288,261,0)
(363,226,0)
(109,370,0)
(21,148,0)
(59,275,0)
(145,309,0)
(16,194,0)
(150,42,0)
(148,21,0)
(342,32,0)
(372,161,0)
(329,129,0)
(321,251,0)
(47,204,0)
(352,15,0)
(205,24,0)
(107,126,0)
(237,52,0)
(120,194,0)
(108,103,0)
(28,52,0)
(265,50,0)
(191,83,0)
(369,156,0)
(329,58,0)
(196,75,0)
(47,269,0)
(9,161,0)
(326,75,0)
(138,66,0)
(247,103,0)
(51,52,0)
(1,253,0)
(208,97,0)
(94,357,0)
(344,182,0)
(327,119,0)
(220,74,0)
(272,303,0)
(180,242,0)
(364,129,0)
(325,204,0)
(351,58,0)
(128,261,0)
(65,323,0)
(255,251,0)
(58,351,0)
(43,251,0)
(370,367,0)
(87,40,0)
(203,196,0)
(105,311,0)
(334,275,0)
(249,40,0)
(180,174,0)
(97,188,0)
(287,373,0)
(84,6,0)
(24,298,0)
(178,195,0)
(142,329,0)
(111,33,0)
(222,233,0)
(0,47,0)
(71,141,0)
(305,145,0)
(143,292,0)
(194,329,0)
(35,197,0)
(180,371,0)
(216,83,0)
(345,25,0)
(89,367,0)
(50,265,0)
(212,228,0)
(274,141,0)
(211,50,0)
(199,284,0)
(239,129,0)
(230,370,0)
(5,197,0)
(220,32,0)
(128,252,0)
(287,357,0)
(202,248,0)
(47,50,0)
(329,367,0)
(4,228,0)
(64,229,0)
(90,197,0)
(170,371,0)
(293,347,0)
(75,196,0)
(349,20,0)
(348,15,0)
(283,278,0)
(47,141,0)
(273,45,0)
(18,250,0)
(178,200,0)
(346,197,0)
(190,299,0)
(309,367,0)
(61,228,0)
(69,269,0)
(121,215,0)
(284,228,0)
(75,13,0)
(139,331,0)
(359,255,0)
(244,277,0)
(126,107,0)
(227,129,0)
(311,24,0)
(308,292,0)
(193,57,0)
(137,176,0)
(148,197,0)
(310,245,0)
(168,367,0)
(192,84,0)
(154,197,0)
(178,302,0)
(284,194,0)
(269,197,0)
(39,349,0)
(28,150,0)
(157,4,0)
(196,195,0)
(276,155,0)
(76,4,0)
(52,123,0)
(28,197,0)
(86,201,0)
(186,364,0)
(302,20,0)
(6,84,0)
(234,156,0)
(130,309,0)
(115,234,0)
(26,20,0)
(185,197,0)
(97,200,0)
(153,348,0)
(45,4,0)
(134,77,0)
(104,110,0)
(320,16,0)
(44,261,0)
(248,153,0)
(10,197,0)
(216,156,0)
(210,129,0)
(369,75,0)
(370,107,0)
(227,367,0)
(261,44,0)
(12,190,0)
(347,204,0)
(297,303,0)
(196,348,0)
(226,363,0)
(28,303,0)
(214,85,0)
(245,194,0)
(56,164,0)
(153,200,0)
(188,15,0)
(348,195,0)
(314,55,0)
(322,9,0)
(135,158,0)
(300,54,0)
(7,198,0)
(47,265,0)
(166,154,0)
(125,197,0)
(238,123,0)
(248,10,0)
(55,241,0)
(353,181,0)
(93,251,0)
(356,241,0)
(23,253,0)
(347,50,0)
(301,153,0)
(219,147,0)
(144,134,0)
(329,194,0)
(266,9,0)
(289,174,0)
(273,25,0)
(373,287,0)
(216,75,0)
(279,30,0)
(277,323,0)
(236,301,0)
(38,140,0)
(315,30,0)
(348,197,0)
(367,13,0)
(364,83,0)
(175,40,0)
(278,28,0)
(57,119,0)
(257,155,0)
(29,255,0)
(116,164,0)
(99,228,0)
(341,34,0)
(263,299,0)
(281,59,0)
(126,145,0)
(136,103,0)
(282,217,0)
(91,84,0)
(57,367,0)
(318,327,0)
(33,147,0)
(160,362,0)
(233,367,0)
(163,45,0)
(110,197,0)
(368,3,0)
(57,194,0)
(102,66,0)
(233,40,0)
(261,128,0)
(256,197,0)
(225,10,0)
(15,178,0)
(30,195,0)
(47,150,0)
(119,197,0)
(298,24,0)
(20,197,0)
(204,197,0)
(319,171,0)
(354,174,0)
(171,126,0)
(47,54,0)
(161,9,0)
(327,123,0)
(25,273,0)
(213,153,0)
(24,311,0)
(332,269,0)
(305,291,0)
(347,265,0)
(371,180,0)
(145,305,0)
(145,126,0)
(355,197,0)
(264,327,0)
(179,363,0)
(307,119,0)
(218,197,0)
(309,145,0)
(59,194,0)
(152,83,0)
(95,123,0)
(98,351,0)
(362,176,0)
(337,363,0)
(231,292,0)
(168,275,0)
(74,228,0)
(153,195,0)
(267,197,0)
(357,287,0)
(169,302,0)
(350,287,0)
(158,367,0)
(14,113,0)
(370,129,0)
(147,33,0)
(58,329,0)
(227,77,0)
(198,197,0)
(254,242,0)
(50,204,0)
(194,197,0)
(47,303,0)
(28,204,0)
(190,16,0)
(234,311,0)
(174,253,0)
(55,284,0)
(80,327,0)
(106,201,0)
(32,220,0)
(28,50,0)
(153,162,0)
(60,168,0)
(28,141,0)
(235,96,0)
(207,30,0)
(131,57,0)
(63,249,0)
(290,54,0)
(280,250,0)
(223,316,0)
(88,153,0)
(367,97,0)
(33,367,0)
(159,215,0)
(189,348,0)
(81,278,0)
(3,275,0)
(232,250,0)
(173,57,0)
(270,347,0)
(221,10,0)
(295,188,0)
(77,227,0)
(124,57,0)
(312,233,0)
(333,83,0)
(57,129,0)
(67,309,0)
(209,242,0)
(96,197,0)
(270,28,0)
(303,197,0)
(241,55,0)
(84,10,0)
(313,216,0)
(366,152,0)
(21,195,0)
(176,362,0)
(252,128,0)
(19,61,0)
(62,286,0)
(246,348,0)
(177,253,0)
(28,269,0)
(77,134,0)
(327,194,0)
(258,197,0)
(250,18,0)
(48,150,0)
(167,289,0)
(268,20,0)
(155,188,0)
(271,119,0)
(8,68,0)
(112,180,0)
(133,215,0)
(151,154,0)
(243,265,0)
(158,129,0)
(302,178,0)
(301,119,0)
(6,77,0)
(299,190,0)
(17,284,0)
(132,197,0)
(164,85,0)
(181,180,0)
(369,40,0)
(85,164,0)
(30,207,0)
(88,348,1)
(329,129,1)
(59,194,1)
(171,129,1)
(19,32,1)
(65,217,1)
(327,264,1)
(188,295,1)
(228,212,1)
(258,361,1)
(287,350,1)
(363,226,1)
(281,94,1)
(24,298,1)
(74,317,1)
(145,309,1)
(190,12,1)
(91,192,1)
(94,168,1)
(192,233,1)
(47,303,1)
(26,268,1)
(57,367,1)
(261,44,1)
(297,272,1)
(73,74,1)
(148,229,1)
(320,37,1)
(129,210,1)
(84,10,1)
(326,367,1)
(282,72,1)
(364,367,1)
(176,362,1)
(231,85,1)
(153,162,1)
(305,291,1)
(147,219,1)
(188,15,1)
(289,242,1)
(60,3,1)
(99,363,1)
(83,333,1)
(131,285,1)
(270,28,1)
(74,228,1)
(174,354,1)
(272,198,1)
(155,276,1)
(301,119,1)
(28,54,1)
(15,178,1)
(284,199,1)
(55,314,1)
(80,318,1)
(311,24,1)
(278,154,1)
(336,232,1)
(224,352,1)
(296,337,1)
(241,255,1)
(278,340,1)
(279,148,1)
(360,89,1)
(153,248,1)
(342,122,1)
(292,308,1)
(121,215,1)
(250,18,1)
(4,194,1)
(347,303,1)
(153,200,1)
(307,20,1)
(143,231,1)
(92,134,1)
(108,289,1)
(78,34,1)
(252,20,1)
(293,128,1)
(319,11,1)
(184,15,1)
(181,353,1)
(47,150,1)
(341,146,1)
(101,281,1)
(31,111,1)
(327,119,1)
(338,153,1)
(324,176,1)
(28,265,1)
(152,83,1)
(168,129,1)
(33,367,1)
(176,137,1)
(70,371,1)
(223,141,1)
(217,255,1)
(313,364,1)
(283,81,1)
(142,120,1)
(179,217,1)
(115,183,1)
(286,330,1)
(366,242,1)
(246,188,1)
(358,326,1)
(158,367,1)
(237,316,1)
(309,130,1)
(369,40,1)
(210,239,1)
(63,42,1)
(74,194,1)
(242,254,1)
(227,262,1)
(133,159,1)
(128,261,1)
(216,75,1)
(301,236,1)
(235,27,1)
(259,211,1)
(369,156,1)
(371,180,1)
(105,155,1)
(284,228,1)
(153,348,1)
(58,351,1)
(47,265,1)
(104,258,1)
(25,345,1)
(241,55,1)
(208,360,1)
(333,191,1)
(6,84,1)
(215,133,1)
(245,194,1)
(153,195,1)
(262,92,1)
(260,241,1)
(28,50,1)
(322,371,1)
(212,99,1)
(120,128,1)
(280,277,1)
(135,61,1)
(124,131,1)
(126,107,1)
(18,336,1)
(270,347,1)
(158,53,1)
(347,269,1)
(89,155,1)
(314,284,1)
(4,157,1)
(4,228,1)
(370,367,1)
(61,19,1)
(213,88,1)
(57,129,1)
(47,141,1)
(233,40,1)
(359,316,1)
(226,296,1)
(271,307,1)
(61,228,1)
(327,129,1)
(156,234,1)
(164,116,1)
(289,174,1)
(136,108,1)
(111,219,1)
(110,104,1)
(179,193,1)
(233,312,1)
(309,194,1)
(56,116,1)
(276,257,1)
(76,158,1)
(40,87,1)
(289,167,1)
(3,368,1)
(69,303,1)
(9,161,1)
(175,194,1)
(189,246,1)
(28,141,1)
(268,154,1)
(219,168,1)
(117,214,1)
(370,194,1)
(29,359,1)
(316,223,1)
(16,320,1)
(243,259,1)
(205,105,1)
(368,357,1)
(270,47,1)
(305,145,1)
(214,327,1)
(227,367,1)
(163,4,1)
(287,20,1)
(28,204,1)
(351,98,1)
(167,364,1)
(344,216,1)
(236,248,1)
(248,10,1)
(328,83,1)
(348,15,1)
(300,290,1)
(254,209,1)
(261,288,1)
(71,274,1)
(266,322,1)
(357,287,1)
(372,266,1)
(51,237,1)
(48,245,1)
(247,365,1)
(248,202,1)
(154,166,1)
(8,370,1)
(11,309,1)
(187,310,1)
(81,85,1)
(302,169,1)
(327,194,1)
(3,275,1)
(20,26,1)
(39,118,1)
(67,291,1)
(153,301,1)
(162,20,1)
(128,252,1)
(145,126,1)
(289,286,1)
(49,96,1)
(225,221,1)
(348,195,1)
(304,75,1)
(148,21,1)
(170,289,1)
(365,136,1)
(182,344,1)
(84,91,1)
(146,324,1)
(230,171,1)
(152,366,1)
(47,54,1)
(373,59,1)
(96,235,1)
(116,117,1)
(160,127,1)
(264,80,1)
(203,358,1)
(137,6,1)
(54,300,1)
(64,119,1)
(193,57,1)
(112,170,1)
(356,273,1)
(162,82,1)
(98,142,1)
(233,129,1)
(273,45,1)
(126,171,1)
(362,160,1)
(245,40,1)
(371,170,1)
(202,162,1)
(97,188,1)
(229,200,1)
(332,69,1)
(168,275,1)
(370,109,1)
(168,367,1)
(220,74,1)
(82,213,1)
(329,367,1)
(77,134,1)
(222,40,1)
(306,224,1)
(222,249,1)
(32,342,1)
(19,299,1)
(257,118,1)
(134,10,1)
(147,33,1)
(158,129,1)
(12,16,1)
(17,356,1)
(315,279,1)
(180,174,1)
(364,83,1)
(85,164,1)
(59,101,1)
(47,50,1)
(257,349,1)
(7,110,1)
(370,129,1)
(81,292,1)
(211,325,1)
(252,70,1)
(121,68,1)
(274,305,1)
(194,329,1)
(33,129,1)
(109,230,1)
(325,269,1)
(327,367,1)
(47,0,1)
(28,269,1)
(186,328,1)
(287,373,1)
(188,200,1)
(57,255,1)
(27,207,1)
(33,31,1)
(249,63,1)
(302,20,1)
(150,48,1)
(52,51,1)
(118,338,1)
(366,182,1)
(150,245,1)
(364,186,1)
(159,68,1)
(171,319,1)
(196,348,1)
(318,52,1)
(16,194,1)
(171,367,1)
(151,10,1)
(178,302,1)
(334,78,1)
(357,154,1)
(47,204,1)
(349,39,1)
(28,150,1)
(367,97,1)
(75,196,1)
(196,203,1)
(232,280,1)
(182,216,1)
(216,156,1)
(10,225,1)
(42,369,1)
(85,214,1)
(191,174,1)
(87,175,1)
(144,84,1)
(265,243,1)
(21,195,1)
(285,277,1)
(339,252,1)
(33,194,1)
(309,129,1)
(119,271,1)
(134,2,1)
(190,16,1)
(32,220,1)
(364,129,1)
(127,137,1)
(245,187,1)
(304,156,1)
(30,195,1)
(309,367,1)
(180,181,1)
(57,194,1)
(234,311,1)
(130,67,1)
(161,372,1)
(170,103,1)
(273,25,1)
(0,193,1)
(223,305,1)
(299,255,1)
(183,129,1)
(257,338,1)
(157,76,1)
(135,228,1)
(180,112,1)
(30,315,1)
(329,58,1)
(216,149,1)
(178,200,1)
(303,297,1)
(275,334,1)
(310,233,1)
(337,179,1)
(16,228,1)
(103,331,1)
(233,367,1)
(244,323,1)
(2,144,1)
(114,288,1)
(47,269,1)
(21,172,1)
(347,265,1)
(164,56,1)
(288,339,1)
(171,194,1)
(70,9,1)
(277,244,1)
(328,152,1)
(107,121,1)
(57,119,1)
(207,30,1)
(97,200,1)
(285,250,1)
(284,194,1)
(216,83,1)
(155,188,1)
(255,29,1)
(45,4,1)
(331,139,1)
(361,49,1)
(345,45,1)
(173,124,1)
(340,81,1)
(103,247,1)
(158,228,1)
(107,370,1)
(352,204,1)
(168,335,1)
(178,195,1)
(323,65,1)
(229,64,1)
(36,294,1)
(155,200,1)
(308,143,1)
(37,263,1)
(335,60,1)
(234,115,1)
(172,229,1)
(198,7,1)
(347,293,1)
(153,188,1)
(330,62,1)
(299,190,1)
(57,173,1)
(206,147,1)
(269,332,1)
(28,303,1)
(68,154,1)
(24,205,1)
(350,373,1)
(62,167,1)
(291,206,1)
(60,275,1)
(45,163,1)
(137,54,1)
(237,158,1)
(59,275,1)
(260,273,1)
(277,323,1)
(290,6,1)
(139,247,1)
(263,32,1)
(55,284,1)
(50,265,1)
(249,40,1)
(317,260,1)
(169,306,1)
(239,311,1)
(122,220,1)
(28,52,1)
(6,77,1)
(141,71,1)
(196,195,1)
(227,129,1)
(349,20,1)
(68,8,1)
(53,135,1)
(166,151,1)
(28,278,1)
(353,112,1)
(295,184,1)
(294,150,1)
(77,227,1)
(347,50,1)
(220,73,1)
(354,304,1)
(34,341,1)
(78,176,1)
(312,222,1)
(97,208,1)
(369,36,1)
(369,75,1)
(348,189,1)
(347,204,1)
(217,282,1)
(209,182,1)
(214,147,1)
(72,255,1)
(44,114,1)
(204,50,1)
(199,17,1)
(180,242,1)
(149,313,1)
(278,283,1)
(74,158,2)
(248,10,2)
(188,200,2)
(176,362,2)
(337,217,2)
(363,226,2)
(370,194,2)
(12,32,2)
(115,155,2)
(370,129,2)
(345,158,2)
(223,147,2)
(373,59,2)
(54,6,2)
(74,228,2)
(214,316,2)
(369,75,2)
(171,309,2)
(347,50,2)
(57,255,2)
(351,128,2)
(21,195,2)
(84,10,2)
(301,119,2)
(287,373,2)
(342,158,2)
(208,155,2)
(77,134,2)
(0,193,2)
(337,193,2)
(245,40,2)
(327,367,2)
(116,214,2)
(369,233,2)
(180,174,2)
(164,214,2)
(255,29,2)
(28,265,2)
(312,128,2)
(278,193,2)
(28,52,2)
(231,85,2)
(47,204,2)
(85,217,2)
(84,128,2)
(289,286,2)
(329,367,2)
(359,316,2)
(363,217,2)
(214,193,2)
(136,289,2)
(327,129,2)
(186,364,2)
(171,129,2)
(318,316,2)
(348,195,2)
(53,217,2)
(217,316,2)
(347,303,2)
(327,194,2)
(364,83,2)
(42,369,2)
(80,193,2)
(287,20,2)
(192,128,2)
(357,154,2)
(4,158,2)
(357,168,2)
(292,85,2)
(28,150,2)
(126,171,2)
(180,181,2)
(168,128,2)
(98,128,2)
(32,158,2)
(45,158,2)
(193,217,2)
(29,316,2)
(144,84,2)
(347,265,2)
(270,47,2)
(24,298,2)
(327,316,2)
(220,158,2)
(228,193,2)
(81,193,2)
(309,367,2)
(9,161,2)
(367,97,2)
(339,252,2)
(179,193,2)
(326,155,2)
(249,233,2)
(178,200,2)
(134,84,2)
(216,75,2)
(175,128,2)
(81,316,2)
(364,364,2)
(28,141,2)
(273,158,2)
(33,129,2)
(103,247,2)
(77,227,2)
(275,128,2)
(48,233,2)
(373,168,2)
(68,154,2)
(305,291,2)
(28,193,2)
(109,171,2)
(59,168,2)
(273,45,2)
(237,193,2)
(59,194,2)
(121,68,2)
(187,233,2)
(188,15,2)
(233,233,2)
(155,200,2)
(58,128,2)
(233,128,2)
(152,83,2)
(9,371,2)
(179,217,2)
(34,176,2)
(55,284,2)
(52,217,2)
(28,204,2)
(233,40,2)
(282,316,2)
(59,275,2)
(142,128,2)
(335,128,2)
(290,6,2)
(36,233,2)
(199,273,2)
(168,168,2)
(212,217,2)
(135,217,2)
(145,126,2)
(358,155,2)
(278,316,2)
(168,129,2)
(364,129,2)
(19,158,2)
(114,288,2)
(305,147,2)
(28,50,2)
(212,193,2)
(122,158,2)
(85,147,2)
(220,74,2)
(228,217,2)
(252,20,2)
(229,200,2)
(89,155,2)
(285,217,2)
(244,217,2)
(372,371,2)
(4,228,2)
(349,20,2)
(33,367,2)
(327,119,2)
(196,155,2)
(353,112,2)
(145,291,2)
(284,194,2)
(347,269,2)
(288,252,2)
(362,137,2)
(362,160,2)
(157,158,2)
(81,217,2)
(97,155,2)
(158,193,2)
(47,54,2)
(203,155,2)
(33,219,2)
(57,119,2)
(118,338,2)
(2,84,2)
(33,194,2)
(309,194,2)
(121,370,2)
(216,156,2)
(148,229,2)
(194,329,2)
(47,141,2)
(239,155,2)
(133,68,2)
(344,364,2)
(156,155,2)
(85,316,2)
(291,147,2)
(51,316,2)
(155,188,2)
(206,147,2)
(143,85,2)
(103,331,2)
(25,158,2)
(284,273,2)
(6,84,2)
(287,168,2)
(3,168,2)
(162,20,2)
(205,155,2)
(15,178,2)
(348,15,2)
(28,54,2)
(53,193,2)
(159,68,2)
(3,275,2)
(128,252,2)
(65,217,2)
(357,287,2)
(72,316,2)
(217,255,2)
(207,30,2)
(87,128,2)
(289,242,2)
(322,371,2)
(327,193,2)
(124,217,2)
(47,303,2)
(317,158,2)
(153,301,2)
(57,194,2)
(28,316,2)
(233,129,2)
(171,194,2)
(137,128,2)
(234,155,2)
(76,158,2)
(278,154,2)
(318,217,2)
(180,242,2)
(222,233,2)
(28,217,2)
(153,200,2)
(278,147,2)
(299,190,2)
(60,168,2)
(293,128,2)
(347,204,2)
(178,195,2)
(127,137,2)
(316,147,2)
(47,193,2)
(204,50,2)
(158,217,2)
(369,40,2)
(278,217,2)
(227,129,2)
(196,195,2)
(181,112,2)
(280,277,2)
(11,309,2)
(237,217,2)
(277,217,2)
(126,309,2)
(226,193,2)
(77,84,2)
(305,145,2)
(281,168,2)
(313,364,2)
(260,158,2)
(270,347,2)
(330,167,2)
(129,155,2)
(158,129,2)
(31,219,2)
(309,129,2)
(250,18,2)
(47,265,2)
(241,273,2)
(50,265,2)
(312,233,2)
(214,217,2)
(367,155,2)
(277,323,2)
(75,196,2)
(141,305,2)
(73,158,2)
(42,233,2)
(314,273,2)
(152,364,2)
(274,305,2)
(8,370,2)
(294,233,2)
(103,289,2)
(196,348,2)
(99,217,2)
(237,316,2)
(146,176,2)
(350,168,2)
(51,217,2)
(134,10,2)
(283,81,2)
(147,33,2)
(340,81,2)
(190,16,2)
(182,216,2)
(255,316,2)
(17,273,2)
(266,371,2)
(328,364,2)
(363,193,2)
(249,40,2)
(80,217,2)
(94,168,2)
(356,273,2)
(210,155,2)
(273,25,2)
(233,367,2)
(242,182,2)
(368,168,2)
(324,176,2)
(149,364,2)
(309,291,2)
(147,128,2)
(261,288,2)
(130,291,2)
(222,128,2)
(168,275,2)
(308,85,2)
(75,155,2)
(284,228,2)
(128,261,2)
(250,277,2)
(329,58,2)
(126,107,2)
(37,32,2)
(51,193,2)
(40,128,2)
(148,21,2)
(55,273,2)
(32,220,2)
(78,128,2)
(117,214,2)
(262,134,2)
(180,170,2)
(245,233,2)
(245,194,2)
(16,228,2)
(28,303,2)
(108,289,2)
(39,118,2)
(6,128,2)
(63,233,2)
(139,289,2)
(296,217,2)
(234,311,2)
(56,214,2)
(57,217,2)
(311,155,2)
(111,219,2)
(310,233,2)
(80,316,2)
(264,193,2)
(67,291,2)
(365,289,2)
(57,129,2)
(145,309,2)
(6,77,2)
(71,305,2)
(99,193,2)
(370,171,2)
(364,367,2)
(227,134,2)
(158,228,2)
(366,364,2)
(193,57,2)
(47,150,2)
(335,168,2)
(171,367,2)
(230,171,2)
(97,188,2)
(299,32,2)
(247,289,2)
(299,255,2)
(120,128,2)
(121,215,2)
(215,68,2)
(135,158,2)
(18,277,2)
(241,55,2)
(311,24,2)
(85,164,2)
(44,288,2)
(160,137,2)
(296,193,2)
(286,167,2)
(85,193,2)
(112,170,2)
(156,234,2)
(232,277,2)
(135,193,2)
(300,6,2)
(74,194,2)
(327,217,2)
(24,155,2)
(173,217,2)
(107,121,2)
(209,182,2)
(30,195,2)
(16,194,2)
(329,128,2)
(107,171,2)
(176,128,2)
(107,370,2)
(261,44,2)
(61,158,2)
(319,309,2)
(347,128,2)
(320,32,2)
(16,32,2)
(153,348,2)
(214,147,2)
(91,128,2)
(61,228,2)
(153,195,2)
(190,32,2)
(336,277,2)
(371,180,2)
(57,367,2)
(334,128,2)
(264,217,2)
(47,269,2)
(161,371,2)
(263,32,2)
(183,155,2)
(261,252,2)
(241,255,2)
(264,316,2)
(360,155,2)
(45,4,2)
(168,367,2)
(318,193,2)
(150,245,2)
(341,176,2)
(216,364,2)
(28,147,2)
(329,129,2)
(28,269,2)
(150,233,2)
(219,128,2)
(52,316,2)
(58,351,2)
(153,162,2)
(182,364,2)
(158,367,2)
(101,168,2)
(105,155,2)
(68,370,2)
(369,156,2)
(158,158,2)
(52,193,2)
(216,83,2)
(153,188,2)
(370,367,2)
(226,217,2)
(62,167,2)
(60,128,2)
(47,50,2)
(163,158,2)
(131,217,2)
(153,248,2)
(32,342,2)
(323,217,2)
(302,20,2)
(81,147,2)
(194,128,2)
(164,116,2)
(178,302,2)
(92,134,2)
(289,174,2)
(97,200,2)
(270,28,2)
(53,158,2)
(4,194,2)
(254,182,2)
(331,289,2)
(349,118,2)
(227,367,2)
-----------------------------------
(0,EXIT_FAILURE)
(1,if (found_hyphen && follow_mode == Follow_name)
(2,multiple_files)
(3,i++)
(4,F[i])
(5,F)
(6,header_mode == always\n\\n      || (header_mode == multiple_files && n_files > 1)
(7,close_stdout)
(8,ok)
(9,error (0, 0, _("warning: following standard input"\n\\n                     " indefinitely is ineffective")
(10,header_mode = multiple_files)
(11,F)
(12,parent_wd)
(13,)
(14,dummy_stdin)
(15,obsolete_option = parse_obsolete_option (argc, argv, &n_units)
(16,F[i])
(17,F)
(18,_("write error")
(19,i)
(20,n_units = DEFAULT_N_LINES)
(21,&argv)
(22,if (! n_units && ! forever && ! from_start)
(23,if (forever && found_hyphen && isatty (STDIN_FILENO)
(24,(char *)
(25,-1)
(26,DEFAULT_N_LINES)
(27,LC_ALL)
(28,return ok ? EXIT_SUCCESS : EXIT_FAILURE;)
(29,inotify_init ()
(30,argv[0])
(31,n_files)
(32,F[i].parent_wd != -1)
(33,ignore_fifo_and_pipe (F, n_files)
(34,xfreopen (NULL, "wb", stdout)
(35,i)
(36,i)
(37,F)
(38,if (n_units)
(39,n_units)
(40,i = 0)
(41,if (O_BINARY && ! isatty (STDOUT_FILENO)
(42,F[i].name = file[i])
(43,wd)
(44,! from_start)
(45,F[i].wd)
(46,if (header_mode == always\n\\n      || (header_mode == multiple_files && n_files > 1)
(47,return EXIT_FAILURE;)
(48,name)
(49,PACKAGE)
(50,from_start = print_headers = false)
(51,true)
(52,disable_inotify = true)
(53,n_files)
(54,print_headers = true)
(55,F[i].wd)
(56,0)
(57,tail_forever_inotify (wd, F, n_files, sleep_interval)
(58,sizeof *F)
(59,F[i])
(60,i)
(61,i++)
(62,follow_mode)
(63,i)
(64,argc)
(65,stdout)
(66,)
(67,F)
(68,!ok)
(69,count_lines)
(70,n_units)
(71,true)
(72,0)
(73,parent_wd)
(74,F[i])
(75,file = argv + optind)
(76,F)
(77,header_mode == multiple_files && n_files > 1)
(78,i)
(79,n_units)
(80,n_files)
(81,ok)
(82,n_units)
(83,i = 0)
(84,header_mode == always)
(85,have_read_stdin && close (STDIN_FILENO)
(86,if (F[i].parent_wd != -1)
(87,0)
(88,argc)
(89,n_files)
(90,file)
(91,always)
(92,n_files)
(93,for (i = 0; i < n_files; i++)
(94,ok)
(95,if (!disable_inotify && (tailable_stdin (F, n_files)
(96,setlocale (LC_ALL, "")
(97,argc - optind)
(98,F)
(99,i)
(100,if (have_read_stdin && close (STDIN_FILENO)
(101,i)
(102,if (!tail_forever_inotify (wd, F, n_files, sleep_interval)
(103,error (EXIT_FAILURE, 0, _("cannot follow %s by name")
(104,PACKAGE)
(105,dummy_stdin)
(106,if (F[i].wd != -1)
(107,any_symlinks (F, n_files)
(108,EXIT_FAILURE)
(109,n_files)
(110,textdomain (PACKAGE)
(111,F)
(112,found_hyphen)
(113,)
(114,from_start)
(115,dummy_stdin)
(116,close (STDIN_FILENO)
(117,STDIN_FILENO)
(118,n_units)
(119,sleep_interval = 1.0)
(120,F)
(121,!ok && follow_mode == Follow_descriptor)
(122,1)
(123,)
(124,n_files)
(125,obsolete_option)
(126,any_remote_file (F, n_files)
(127,STDOUT_FILENO)
(128,! n_units && ! forever && ! from_start)
(129,n_files = 1)
(130,n_files)
(131,F)
(132,if (from_start)
(133,Follow_descriptor)
(134,header_mode == multiple_files)
(135,i)
(136,0)
(137,O_BINARY)
(138,if (fflush (stdout)
(139,"-")
(140,)
(141,disable_inotify = true)
(142,n_files)
(143,errno)
(144,header_mode)
(145,tailable_stdin (F, n_files)
(146,"wb")
(147,forever && ignore_fifo_and_pipe (F, n_files)
(148,initialize_main (&argc, &argv)
(149,i)
(150,F[i].name)
(151,ok)
(152,i++)
(153,parse_options (argc, argv, &n_units, &header_mode, &sleep_interval)
(154,ok = true)
(155,optind < argc)
(156,file = &dummy_stdin)
(157,i)
(158,i < n_files)
(159,follow_mode)
(160,isatty (STDOUT_FILENO)
(161,_("warning: following standard input"\n\\n                     " indefinitely is ineffective")
(162,&n_units)
(163,wd)
(164,close (STDIN_FILENO)
(165,if (forever && ignore_fifo_and_pipe (F, n_files)
(166,true)
(167,found_hyphen)
(168,i < n_files)
(169,n_units)
(170,forever)
(171,any_remote_file (F, n_files)
(172,argv)
(173,sleep_interval)
(174,found_hyphen = false)
(175,i)
(176,O_BINARY && ! isatty (STDOUT_FILENO)
(177,found_hyphen)
(178,parse_obsolete_option (argc, argv, &n_units)
(179,0)
(180,found_hyphen && isatty (STDIN_FILENO)
(181,isatty (STDIN_FILENO)
(182,STREQ (file[i], "-")
(183,file)
(184,argc)
(185,sleep_interval)
(186,n_files)
(187,i)
(188,argc -= obsolete_option)
(189,obsolete_option)
(190,F[i].parent_wd)
(191,i)
(192,header_mode)
(193,!tail_forever_inotify (wd, F, n_files, sleep_interval)
(194,F = xnmalloc (n_files, sizeof *F)
(195,char **argv)
(196,argv + optind)
(197,)
(198,atexit (close_stdout)
(199,i)
(200,int argc)
(201,)
(202,header_mode)
(203,optind)
(204,forever = from_start = print_headers = false)
(205,"-")
(206,disable_inotify)
(207,set_program_name (argv[0])
(208,optind)
(209,found_hyphen)
(210,1)
(211,from_start)
(212,0)
(213,argv)
(214,have_read_stdin)
(215,follow_mode == Follow_descriptor)
(216,file[i])
(217,0 <= wd)
(218,for (i = 0; i < n_files; i++)
(219,forever)
(220,F[i].parent_wd)
(221,header_mode)
(222,i)
(223,disable_inotify)
(224,argc)
(225,multiple_files)
(226,_("inotify cannot be used, reverting to polling")
(227,n_files > 1)
(228,i = 0)
(229,&argc)
(230,F)
(231,EXIT_FAILURE)
(232,errno)
(233,i < n_files)
(234,&dummy_stdin)
(235,"")
(236,sleep_interval)
(237,disable_inotify)
(238,if (!disable_inotify)
(239,n_files)
(240,ok)
(241,inotify_rm_watch (wd, F[i].wd)
(242,found_hyphen = true)
(243,false)
(244,0)
(245,F[i])
(246,argv)
(247,_("cannot follow %s by name")
(248,&header_mode)
(249,i++)
(250,error (EXIT_FAILURE, errno, _("write error")
(251,)
(252,! n_units)
(253,)
(254,true)
(255,wd = inotify_init ()
(256,header_mode)
(257,optind)
(258,bindtextdomain (PACKAGE, LOCALEDIR)
(259,print_headers)
(260,F)
(261,! forever && ! from_start)
(262,1)
(263,wd)
(264,sleep_interval)
(265,print_headers = false)
(266,0)
(267,for (i = 0; i < n_files; i++)
(268,n_units)
(269,count_lines = true)
(270,RET)
(271,1.0)
(272,have_read_stdin)
(273,F[i].wd != -1)
(274,disable_inotify)
(275,i = 0)
(276,argc)
(277,fflush (stdout)
(278,ok ? EXIT_SUCCESS : EXIT_FAILURE)
(279,argv)
(280,EXIT_FAILURE)
(281,F)
(282,wd)
(283,EXIT_SUCCESS)
(284,F[i])
(285,wd)
(286,follow_mode == Follow_name)
(287,tail_file (&F[i], n_units)
(288,! forever)
(289,found_hyphen && follow_mode == Follow_name)
(290,print_headers)
(291,!disable_inotify)
(292,error (EXIT_FAILURE, errno, "-")
(293,EXIT_SUCCESS)
(294,file)
(295,obsolete_option)
(296,"inotify cannot be used, reverting to polling")
(297,false)
(298,char *)
(299,inotify_rm_watch (wd, F[i].parent_wd)
(300,true)
(301,&sleep_interval)
(302,&n_units)
(303,have_read_stdin = false)
(304,found_hyphen)
(305,!disable_inotify && (tailable_stdin (F, n_files)
(306,argv)
(307,sleep_interval)
(308,"-")
(309,tailable_stdin (F, n_files)
(310,F)
(311,*dummy_stdin = (char *)
(312,n_files)
(313,file)
(314,wd)
(315,0)
(316,!disable_inotify)
(317,i)
(318,F)
(319,n_files)
(320,i)
(321,if (0 <= wd)
(322,0)
(323,fflush (stdout)
(324,NULL)
(325,forever)
(326,file)
(327,tail_forever (F, n_files, sleep_interval)
(328,i)
(329,xnmalloc (n_files, sizeof *F)
(330,Follow_name)
(331,quote ("-")
(332,true)
(333,0)
(334,0)
(335,n_files)
(336,"write error")
(337,errno)
(338,from_start)
(339,forever)
(340,EXIT_FAILURE)
(341,stdout)
(342,-1)
(343,for (i = 0; i < n_files; i++)
(344,"-")
(345,1)
(346,n_files)
(347,return EXIT_SUCCESS;)
(348,argv += obsolete_option)
(349,--n_units)
(350,n_units)
(351,*F)
(352,obsolete_option)
(353,STDIN_FILENO)
(354,false)
(355,if (optind < argc)
(356,wd)
(357,ok &= tail_file (&F[i], n_units)
(358,argv)
(359,wd)
(360,argc)
(361,LOCALEDIR)
(362,! isatty (STDOUT_FILENO)
(363,error (0, errno, _("inotify cannot be used, reverting to polling")
(364,i < n_files)
(365,"cannot follow %s by name")
(366,i)
(367,n_files = argc - optind)
(368,i)
(369,file[i])
(370,any_symlinks (F, n_files)
(371,forever && found_hyphen && isatty (STDIN_FILENO)
(372,"warning: following standard input"\n\\n                     " indefinitely is ineffective")
(373,&F[i])
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^