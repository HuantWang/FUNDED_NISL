-----label-----
0
-----code-----
static void backupPathInThread(NiBackup *ni, char *name, int source, int destDir)
{
    if (ni->threads == 1) {
        /* we don't need no stinkin' threads! */
        backupPath(ni, name, source, destDir);
        free(name);
        close(source);
        close(destDir);

    } else {
        int ti;
        BackupPathArgs *bpa = malloc(sizeof(BackupPathArgs));
        if (!bpa) {
            /* FIXME */
            close(source);
            close(destDir);
            return;
        }

        bpa->ni = ni;
        bpa->name = name;
        bpa->source = source;
        bpa->destDir = destDir;

        /* wait until a thread is free */
        sem_wait(&ni->bsem);

        /* and start it */
        for (ti = 0; ti < ni->threads; ti++) {
            pthread_mutex_lock(&ni->blocks[ti]);
            if (!ni->brunning[ti]) {
                /* not running, take it */
                ni->brunning[ti] = 1;
                bpa->ti = ti;
                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);
                pthread_mutex_unlock(&ni->blocks[ti]);
                break;
            }
            pthread_mutex_unlock(&ni->blocks[ti]);
        }

        if (ti == ni->threads) {
            /* FIXME: this should never happen */
            free(bpa);
            free(name);
            close(source);
            close(destDir);
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
13,15
16,17
16,18
18,19
20,21
20,22
22,23
24,25
25,26
25,27
25,28
26,27
26,28
27,28
27,29
28,29
32,33
32,34
32,35
32,36
33,34
34,35
34,36
34,37
34,38
34,39
35,36
37,38
39,40
41,42
43,44
45,46
46,47
46,48
47,48
49,50
51,52
52,53
52,54
53,54
55,56
57,58
58,59
58,60
59,60
61,62
63,64
63,65
63,66
63,67
63,68
63,69
63,70
63,71
63,72
63,73
64,65
65,66
65,67
67,68
69,70
70,71
70,72
71,72
73,74
73,75
73,76
76,77
77,78
77,79
78,79
80,81
81,82
81,83
82,83
85,86
85,87
86,87
87,88
89,90
89,91
89,92
90,91
91,92
91,93
92,93
94,95
96,97
97,98
97,99
98,99
100,101
103,104
104,105
104,106
105,106
105,107
106,107
109,110
111,112
112,113
112,114
113,114
113,115
114,115
117,118
119,120
120,121
120,122
121,122
121,123
122,123
125,126
127,128
128,129
128,130
129,130
129,131
130,131
133,134
135,136
136,137
136,138
137,138
139,140
140,141
140,142
141,142
144,145
144,146
144,147
144,148
145,146
146,147
146,148
147,148
150,151
150,152
151,152
153,154
153,155
154,155
157,158
158,159
160,161
160,162
160,163
161,162
162,163
162,164
163,164
165,166
166,167
166,168
167,168
167,169
168,169
171,172
173,174
173,175
174,175
175,176
175,177
176,177
176,178
177,178
180,181
182,183
182,184
182,185
182,186
182,187
183,184
184,185
184,186
185,186
185,187
186,187
186,188
187,188
190,191
193,194
194,195
194,196
195,196
195,197
196,197
199,200
201,202
202,203
202,204
202,205
202,206
202,207
203,204
205,206
206,207
206,208
207,208
207,209
208,209
211,212
213,214
215,216
217,218
219,220
220,221
220,222
221,222
223,224
224,225
224,226
225,226
225,227
226,227
229,230
232,233
233,234
233,235
234,235
236,237
237,238
237,239
238,239
238,240
239,240
242,243
244,245
244,246
245,246
245,247
246,247
248,249
248,250
249,250
252,253
252,254
252,255
252,256
253,254
254,255
254,256
255,256
257,258
259,260
260,261
260,262
261,262
263,264
265,266
266,267
266,268
267,268
269,270
271,272
272,273
272,274
273,274
275,276
-----nextToken-----
2,4,7,9,10,12,14,15,17,19,21,23,29,30,31,36,38,40,42,44,48,50,54,56,60,62,66,68,72,74,75,79,83,84,88,93,95,99,101,102,107,108,110,115,116,118,123,124,126,131,132,134,138,142,143,148,149,152,155,156,159,164,169,170,172,178,179,181,188,189,191,192,197,198,200,204,209,210,212,214,216,218,222,227,228,230,231,235,240,241,243,247,250,251,256,258,262,264,268,270,274,276
-----computeFrom-----
26,27
26,28
104,105
104,106
112,113
112,114
120,121
120,122
128,129
128,130
146,147
146,148
150,151
150,152
184,185
184,186
194,195
194,196
245,246
245,247
-----guardedBy-----
29,38
-----guardedByNegation-----
30,251
29,250
-----lastLexicalUse-----
29,250
-----jump-----
29,250
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
static void backupPathInThread(NiBackup *ni, char *name, int source, int destDir){    if (ni->threads == 1) {        /* we don't need no stinkin' threads! */        backupPath(ni, name, source, destDir);        free(name);        close(source);        close(destDir);    } else {        int ti;        BackupPathArgs *bpa = malloc(sizeof(BackupPathArgs));        if (!bpa) {            /* FIXME */            close(source);            close(destDir);            return;        }        bpa->ni = ni;        bpa->name = name;        bpa->source = source;        bpa->destDir = destDir;        /* wait until a thread is free */        sem_wait(&ni->bsem);        /* and start it */        for (ti = 0; ti < ni->threads; ti++) {            pthread_mutex_lock(&ni->blocks[ti]);            if (!ni->brunning[ti]) {                /* not running, take it */                ni->brunning[ti] = 1;                bpa->ti = ti;                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);                pthread_mutex_unlock(&ni->blocks[ti]);                break;            }            pthread_mutex_unlock(&ni->blocks[ti]);        }        if (ti == ni->threads) {            /* FIXME: this should never happen */            free(bpa);            free(name);            close(source);            close(destDir);        }    }}
static void
backupPathInThread(NiBackup *ni, char *name, int source, int destDir)
backupPathInThread
NiBackup *ni
NiBackup
NiBackup
*ni
*
ni
char *name
char
*name
*
name
int source
int
source
source
int destDir
int
destDir
destDir
{    if (ni->threads == 1) {        /* we don't need no stinkin' threads! */        backupPath(ni, name, source, destDir);        free(name);        close(source);        close(destDir);    } else {        int ti;        BackupPathArgs *bpa = malloc(sizeof(BackupPathArgs));        if (!bpa) {            /* FIXME */            close(source);            close(destDir);            return;        }        bpa->ni = ni;        bpa->name = name;        bpa->source = source;        bpa->destDir = destDir;        /* wait until a thread is free */        sem_wait(&ni->bsem);        /* and start it */        for (ti = 0; ti < ni->threads; ti++) {            pthread_mutex_lock(&ni->blocks[ti]);            if (!ni->brunning[ti]) {                /* not running, take it */                ni->brunning[ti] = 1;                bpa->ti = ti;                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);                pthread_mutex_unlock(&ni->blocks[ti]);                break;            }            pthread_mutex_unlock(&ni->blocks[ti]);        }        if (ti == ni->threads) {            /* FIXME: this should never happen */            free(bpa);            free(name);            close(source);            close(destDir);        }    }}
if (ni->threads == 1) {        /* we don't need no stinkin' threads! */        backupPath(ni, name, source, destDir);        free(name);        close(source);        close(destDir);    } else {        int ti;        BackupPathArgs *bpa = malloc(sizeof(BackupPathArgs));        if (!bpa) {            /* FIXME */            close(source);            close(destDir);            return;        }        bpa->ni = ni;        bpa->name = name;        bpa->source = source;        bpa->destDir = destDir;        /* wait until a thread is free */        sem_wait(&ni->bsem);        /* and start it */        for (ti = 0; ti < ni->threads; ti++) {            pthread_mutex_lock(&ni->blocks[ti]);            if (!ni->brunning[ti]) {                /* not running, take it */                ni->brunning[ti] = 1;                bpa->ti = ti;                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);                pthread_mutex_unlock(&ni->blocks[ti]);                break;            }            pthread_mutex_unlock(&ni->blocks[ti]);        }        if (ti == ni->threads) {            /* FIXME: this should never happen */            free(bpa);            free(name);            close(source);            close(destDir);        }    }
ni->threads == 1
ni->threads
ni
ni
threads
1
{        /* we don't need no stinkin' threads! */        backupPath(ni, name, source, destDir);        free(name);        close(source);        close(destDir);    }
backupPath(ni, name, source, destDir);
backupPath(ni, name, source, destDir)
backupPath
backupPath
ni
ni
name
name
source
source
destDir
destDir
free(name);
free(name)
free
free
name
name
close(source);
close(source)
close
close
source
source
close(destDir);
close(destDir)
close
close
destDir
destDir
{        int ti;        BackupPathArgs *bpa = malloc(sizeof(BackupPathArgs));        if (!bpa) {            /* FIXME */            close(source);            close(destDir);            return;        }        bpa->ni = ni;        bpa->name = name;        bpa->source = source;        bpa->destDir = destDir;        /* wait until a thread is free */        sem_wait(&ni->bsem);        /* and start it */        for (ti = 0; ti < ni->threads; ti++) {            pthread_mutex_lock(&ni->blocks[ti]);            if (!ni->brunning[ti]) {                /* not running, take it */                ni->brunning[ti] = 1;                bpa->ti = ti;                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);                pthread_mutex_unlock(&ni->blocks[ti]);                break;            }            pthread_mutex_unlock(&ni->blocks[ti]);        }        if (ti == ni->threads) {            /* FIXME: this should never happen */            free(bpa);            free(name);            close(source);            close(destDir);        }    }
int ti;
int ti;
int
ti
ti
BackupPathArgs *bpa = malloc(sizeof(BackupPathArgs));
BackupPathArgs *bpa = malloc(sizeof(BackupPathArgs));
BackupPathArgs
BackupPathArgs
*bpa = malloc(sizeof(BackupPathArgs))
*
bpa
= malloc(sizeof(BackupPathArgs))
malloc(sizeof(BackupPathArgs))
malloc
malloc
sizeof(BackupPathArgs)
BackupPathArgs
BackupPathArgs
BackupPathArgs

if (!bpa) {            /* FIXME */            close(source);            close(destDir);            return;        }
!bpa
bpa
bpa
{            /* FIXME */            close(source);            close(destDir);            return;        }
close(source);
close(source)
close
close
source
source
close(destDir);
close(destDir)
close
close
destDir
destDir
return;
bpa->ni = ni;
bpa->ni = ni
bpa->ni
bpa
bpa
ni
ni
ni
bpa->name = name;
bpa->name = name
bpa->name
bpa
bpa
name
name
name
bpa->source = source;
bpa->source = source
bpa->source
bpa
bpa
source
source
source
bpa->destDir = destDir;
bpa->destDir = destDir
bpa->destDir
bpa
bpa
destDir
destDir
destDir
sem_wait(&ni->bsem);
sem_wait(&ni->bsem)
sem_wait
sem_wait
&ni->bsem
ni->bsem
ni
ni
bsem
for (ti = 0; ti < ni->threads; ti++) {            pthread_mutex_lock(&ni->blocks[ti]);            if (!ni->brunning[ti]) {                /* not running, take it */                ni->brunning[ti] = 1;                bpa->ti = ti;                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);                pthread_mutex_unlock(&ni->blocks[ti]);                break;            }            pthread_mutex_unlock(&ni->blocks[ti]);        }
ti = 0;
ti = 0
ti
ti
0
ti < ni->threads
ti
ti
ni->threads
ni
ni
threads
ti++
ti
ti
{            pthread_mutex_lock(&ni->blocks[ti]);            if (!ni->brunning[ti]) {                /* not running, take it */                ni->brunning[ti] = 1;                bpa->ti = ti;                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);                pthread_mutex_unlock(&ni->blocks[ti]);                break;            }            pthread_mutex_unlock(&ni->blocks[ti]);        }
pthread_mutex_lock(&ni->blocks[ti]);
pthread_mutex_lock(&ni->blocks[ti])
pthread_mutex_lock
pthread_mutex_lock
&ni->blocks[ti]
ni->blocks[ti]
ni->blocks
ni
ni
blocks
ti
ti
if (!ni->brunning[ti]) {                /* not running, take it */                ni->brunning[ti] = 1;                bpa->ti = ti;                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);                pthread_mutex_unlock(&ni->blocks[ti]);                break;            }
!ni->brunning[ti]
ni->brunning[ti]
ni->brunning
ni
ni
brunning
ti
ti
{                /* not running, take it */                ni->brunning[ti] = 1;                bpa->ti = ti;                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);                pthread_mutex_unlock(&ni->blocks[ti]);                break;            }
ni->brunning[ti] = 1;
ni->brunning[ti] = 1
ni->brunning[ti]
ni->brunning
ni
ni
brunning
ti
ti
1
bpa->ti = ti;
bpa->ti = ti
bpa->ti
bpa
bpa
ti
ti
ti
pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);
pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa)
pthread_create
pthread_create
&ni->bth[ti]
ni->bth[ti]
ni->bth
ni
ni
bth
ti
ti
NULL
NULL
backupPathTh
backupPathTh
bpa
bpa
pthread_mutex_unlock(&ni->blocks[ti]);
pthread_mutex_unlock(&ni->blocks[ti])
pthread_mutex_unlock
pthread_mutex_unlock
&ni->blocks[ti]
ni->blocks[ti]
ni->blocks
ni
ni
blocks
ti
ti
break;
pthread_mutex_unlock(&ni->blocks[ti]);
pthread_mutex_unlock(&ni->blocks[ti])
pthread_mutex_unlock
pthread_mutex_unlock
&ni->blocks[ti]
ni->blocks[ti]
ni->blocks
ni
ni
blocks
ti
ti
if (ti == ni->threads) {            /* FIXME: this should never happen */            free(bpa);            free(name);            close(source);            close(destDir);        }
ti == ni->threads
ti
ti
ni->threads
ni
ni
threads
{            /* FIXME: this should never happen */            free(bpa);            free(name);            close(source);            close(destDir);        }
free(bpa);
free(bpa)
free
free
bpa
bpa
free(name);
free(name)
free
free
name
name
close(source);
close(source)
close
close
source
source
close(destDir);
close(destDir)
close
close
destDir
destDir
-----joern-----
(38,124,0)
(79,103,0)
(96,139,0)
(14,107,0)
(47,10,0)
(66,140,0)
(121,49,0)
(144,142,0)
(92,89,0)
(110,37,0)
(78,20,0)
(82,116,0)
(123,130,0)
(75,129,0)
(74,95,0)
(15,63,0)
(61,131,0)
(39,63,0)
(3,129,0)
(53,129,0)
(93,101,0)
(118,43,0)
(139,117,0)
(139,127,0)
(82,128,0)
(51,117,0)
(94,142,0)
(57,2,0)
(128,82,0)
(69,7,0)
(133,9,0)
(110,103,0)
(111,92,0)
(28,95,0)
(59,141,0)
(131,61,0)
(38,55,0)
(88,86,0)
(12,83,0)
(48,117,0)
(86,142,0)
(113,140,0)
(52,83,0)
(51,16,0)
(74,89,0)
(119,49,0)
(134,20,0)
(100,88,0)
(106,144,0)
(58,118,0)
(17,129,0)
(65,129,0)
(101,129,0)
(116,20,0)
(103,110,0)
(112,43,0)
(79,117,0)
(132,61,0)
(62,129,0)
(114,112,0)
(126,117,0)
(79,49,0)
(45,37,0)
(46,85,0)
(1,48,0)
(8,52,0)
(40,126,0)
(60,127,0)
(143,17,0)
(97,43,0)
(15,142,0)
(72,117,0)
(27,71,0)
(97,107,0)
(80,97,0)
(51,52,0)
(108,142,0)
(127,139,0)
(71,12,0)
(48,1,0)
(20,116,0)
(20,83,0)
(108,101,0)
(118,89,0)
(122,45,0)
(104,9,0)
(2,136,0)
(141,14,0)
(98,83,0)
(97,83,0)
(67,136,0)
(70,43,0)
(14,129,0)
(87,127,0)
(34,12,0)
(138,98,0)
(135,143,0)
(72,98,0)
(102,17,0)
(85,83,0)
(49,79,0)
(125,55,0)
(142,86,0)
(109,70,0)
(86,88,0)
(90,72,0)
(7,37,0)
(56,45,0)
(12,71,0)
(91,94,0)
(22,140,0)
(103,79,0)
(128,10,0)
(77,85,0)
(41,37,0)
(19,28,0)
(55,83,0)
(124,129,0)
(70,136,0)
(0,14,0)
(97,136,0)
(61,122,0)
(115,131,0)
(81,108,0)
(68,98,0)
(30,108,0)
(124,38,0)
(99,45,0)
(24,97,0)
(144,53,0)
(64,97,0)
(143,142,0)
(23,143,0)
(53,43,0)
(29,15,0)
(5,129,0)
(26,12,0)
(4,55,0)
(55,38,0)
(31,48,0)
(142,129,0)
(42,74,0)
(13,52,0)
(84,53,0)
(105,79,0)
(85,48,0)
(101,83,0)
(16,51,0)
(98,72,0)
(18,142,0)
(67,107,0)
(54,45,0)
(48,85,0)
(120,66,0)
(133,107,0)
(141,142,0)
(76,16,0)
(104,142,0)
(33,141,0)
(35,117,0)
(127,83,0)
(16,76,0)
(32,67,0)
(50,133,0)
(52,51,0)
(49,83,0)
(63,37,0)
(21,117,0)
(122,61,0)
(63,117,0)
(11,15,0)
(66,117,0)
(116,117,0)
(97,95,0)
(45,122,0)
(36,97,0)
(140,66,0)
(45,142,0)
(137,116,0)
(131,83,0)
(17,95,0)
(116,82,0)
(76,10,0)
(73,104,0)
(112,9,0)
(140,83,0)
(61,117,0)
(6,51,0)
(44,144,0)
(2,95,0)
(25,131,0)
(139,7,0)
(28,9,0)
(55,4,1)
(93,108,1)
(15,142,1)
(141,142,1)
(66,117,1)
(41,110,1)
(140,113,1)
(67,107,1)
(111,112,1)
(106,17,1)
(38,55,1)
(141,59,1)
(51,52,1)
(90,66,1)
(48,31,1)
(49,83,1)
(2,95,1)
(22,120,1)
(58,74,1)
(86,88,1)
(6,52,1)
(109,2,1)
(80,71,1)
(45,142,1)
(20,83,1)
(94,91,1)
(120,126,1)
(16,51,1)
(139,127,1)
(119,121,1)
(79,49,1)
(78,134,1)
(112,43,1)
(112,114,1)
(98,83,1)
(140,83,1)
(139,117,1)
(100,18,1)
(134,1,1)
(138,90,1)
(92,118,1)
(132,131,1)
(67,32,1)
(25,63,1)
(144,44,1)
(52,13,1)
(121,45,1)
(42,94,1)
(30,94,1)
(29,7,1)
(143,23,1)
(128,82,1)
(48,85,1)
(2,57,1)
(118,58,1)
(0,141,1)
(113,22,1)
(114,28,1)
(102,143,1)
(68,138,1)
(96,127,1)
(14,107,1)
(46,76,1)
(144,142,1)
(60,1,1)
(72,117,1)
(97,83,1)
(81,30,1)
(73,72,1)
(101,93,1)
(84,144,1)
(52,83,1)
(28,95,1)
(137,20,1)
(66,140,1)
(71,27,1)
(11,29,1)
(39,15,1)
(74,42,1)
(125,53,1)
(85,83,1)
(69,139,1)
(1,48,1)
(61,131,1)
(57,67,1)
(131,115,1)
(28,19,1)
(59,33,1)
(8,66,1)
(35,21,1)
(26,34,1)
(111,72,1)
(85,77,1)
(32,97,1)
(82,116,1)
(14,0,1)
(127,87,1)
(4,125,1)
(127,83,1)
(49,119,1)
(90,41,1)
(61,117,1)
(18,71,1)
(104,73,1)
(88,100,1)
(12,83,1)
(79,117,1)
(135,14,1)
(104,142,1)
(55,83,1)
(71,12,1)
(108,81,1)
(118,43,1)
(27,12,1)
(87,60,1)
(131,83,1)
(97,43,1)
(72,98,1)
(116,20,1)
(51,6,1)
(53,43,1)
(105,49,1)
(63,117,1)
(117,35,1)
(91,142,1)
(48,117,1)
(12,26,1)
(77,46,1)
(23,135,1)
(98,68,1)
(115,25,1)
(126,117,1)
(61,132,1)
(79,105,1)
(142,86,1)
(63,39,1)
(122,61,1)
(53,84,1)
(54,56,1)
(124,38,1)
(76,16,1)
(74,95,1)
(15,11,1)
(120,117,1)
(17,102,1)
(108,142,1)
(64,80,1)
(110,103,1)
(19,133,1)
(7,69,1)
(97,95,1)
(103,79,1)
(40,128,1)
(126,40,1)
(24,36,1)
(111,70,1)
(20,78,1)
(70,109,1)
(97,107,1)
(21,124,1)
(17,95,1)
(139,96,1)
(31,85,1)
(143,142,1)
(44,106,1)
(13,8,1)
(50,104,1)
(111,92,1)
(51,117,1)
(45,99,1)
(116,117,1)
(97,24,1)
(99,54,1)
(133,50,1)
(94,142,1)
(70,43,1)
(133,107,1)
(36,64,1)
(101,83,1)
(116,137,1)
(45,122,1)
(33,101,1)
(56,122,1)
(116,117,2)
(72,94,2)
(17,95,2)
(67,71,2)
(18,71,2)
(67,107,2)
(61,117,2)
(90,94,2)
(131,83,2)
(41,1,2)
(28,72,2)
(22,1,2)
(100,71,2)
(48,85,2)
(101,83,2)
(53,43,2)
(66,94,2)
(140,1,2)
(28,95,2)
(85,66,2)
(64,71,2)
(94,142,2)
(36,71,2)
(82,1,2)
(102,94,2)
(49,83,2)
(118,43,2)
(106,94,2)
(143,94,2)
(113,1,2)
(76,66,2)
(94,71,2)
(140,94,2)
(87,1,2)
(46,66,2)
(15,142,2)
(121,1,2)
(112,43,2)
(45,142,2)
(7,1,2)
(50,72,2)
(103,79,2)
(48,66,2)
(38,55,2)
(22,94,2)
(97,107,2)
(135,94,2)
(80,71,2)
(140,83,2)
(51,117,2)
(40,1,2)
(56,1,2)
(120,1,2)
(55,94,2)
(48,117,2)
(58,94,2)
(134,1,2)
(68,94,2)
(25,1,2)
(115,1,2)
(44,94,2)
(73,72,2)
(122,1,2)
(96,1,2)
(45,122,2)
(103,1,2)
(69,1,2)
(0,94,2)
(132,1,2)
(2,71,2)
(30,94,2)
(66,117,2)
(98,83,2)
(86,88,2)
(79,49,2)
(85,83,2)
(11,1,2)
(125,94,2)
(118,94,2)
(104,142,2)
(20,1,2)
(126,1,2)
(6,66,2)
(82,116,2)
(60,1,2)
(137,1,2)
(114,72,2)
(32,71,2)
(124,38,2)
(35,94,2)
(14,107,2)
(29,1,2)
(61,131,2)
(111,92,2)
(97,95,2)
(52,66,2)
(72,117,2)
(92,94,2)
(101,94,2)
(99,1,2)
(131,1,2)
(108,142,2)
(4,94,2)
(54,1,2)
(81,94,2)
(128,82,2)
(127,1,2)
(144,142,2)
(128,1,2)
(78,1,2)
(59,94,2)
(108,94,2)
(49,1,2)
(57,71,2)
(61,1,2)
(139,117,2)
(122,61,2)
(112,72,2)
(70,71,2)
(51,52,2)
(16,66,2)
(38,94,2)
(1,66,2)
(98,94,2)
(2,95,2)
(72,98,2)
(116,20,2)
(55,83,2)
(21,94,2)
(109,71,2)
(76,16,2)
(120,94,2)
(12,83,2)
(113,94,2)
(20,83,2)
(142,71,2)
(86,71,2)
(124,94,2)
(74,95,2)
(142,86,2)
(8,66,2)
(31,66,2)
(42,94,2)
(127,83,2)
(24,71,2)
(141,94,2)
(33,94,2)
(39,1,2)
(15,1,2)
(19,72,2)
(63,117,2)
(97,71,2)
(97,83,2)
(53,94,2)
(97,43,2)
(93,94,2)
(138,94,2)
(17,94,2)
(133,72,2)
(23,94,2)
(110,103,2)
(119,1,2)
(66,1,2)
(66,140,2)
(105,1,2)
(51,66,2)
(116,1,2)
(71,12,2)
(88,71,2)
(52,83,2)
(141,142,2)
(74,94,2)
(117,94,2)
(126,117,2)
(70,43,2)
(139,127,2)
(77,66,2)
(104,72,2)
(45,1,2)
(79,1,2)
(139,1,2)
(14,94,2)
(16,51,2)
(84,94,2)
(143,142,2)
(133,107,2)
(63,1,2)
(110,1,2)
(1,48,2)
(144,94,2)
(13,66,2)
(91,71,2)
(79,117,2)
-----------------------------------
(0,name)
(1,!ni->brunning[ti])
(2,close(source)
(3,if (ti == ni->threads)
(4,bsem)
(5,bpa)
(6,ti)
(7,ni->brunning[ti] = 1)
(8,ni)
(9,)
(10,)
(11,ti)
(12,ni->threads)
(13,blocks)
(14,bpa->name = name)
(15,bpa->ti)
(16,&ni->blocks[ti])
(17,bpa->source = source)
(18,bpa)
(19,source)
(20,ni->blocks)
(21,ti)
(22,ni)
(23,source)
(24,destDir)
(25,ni)
(26,threads)
(27,1)
(28,close(source)
(29,bpa)
(30,bpa)
(31,ti)
(32,name)
(33,bpa)
(34,ni)
(35,0)
(36,source)
(37,)
(38,&ni->bsem)
(39,ti)
(40,ti)
(41,break;)
(42,source)
(43,int destDir)
(44,destDir)
(45,pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa)
(46,ni)
(47,if (!ni->brunning[ti])
(48,ni->brunning[ti])
(49,ni->blocks)
(50,name)
(51,ni->blocks[ti])
(52,ni->blocks)
(53,bpa->destDir = destDir)
(54,backupPathTh)
(55,ni->bsem)
(56,NULL)
(57,source)
(58,destDir)
(59,name)
(60,ni)
(61,ni->bth[ti])
(62,for (ti = 0; ti < ni->threads; ti++)
(63,bpa->ti = ti)
(64,name)
(65,ti)
(66,ti < ni->threads)
(67,free(name)
(68,threads)
(69,1)
(70,close(destDir)
(71,ni->threads == 1)
(72,ti == ni->threads)
(73,bpa)
(74,close(source)
(75,if (!bpa)
(76,pthread_mutex_lock(&ni->blocks[ti])
(77,brunning)
(78,blocks)
(79,ni->blocks[ti])
(80,ni)
(81,ni)
(82,&ni->blocks[ti])
(83,NiBackup *ni)
(84,destDir)
(85,ni->brunning)
(86,malloc(sizeof(BackupPathArgs)
(87,brunning)
(88,sizeof(BackupPathArgs)
(89,)
(90,ti)
(91,bpa)
(92,return;)
(93,ni)
(94,!bpa)
(95,int source)
(96,ti)
(97,backupPath(ni, name, source, destDir)
(98,ni->threads)
(99,bpa)
(100,BackupPathArgs)
(101,bpa->ni = ni)
(102,source)
(103,&ni->blocks[ti])
(104,free(bpa)
(105,ti)
(106,bpa)
(107,char *name)
(108,bpa->ni)
(109,destDir)
(110,pthread_mutex_unlock(&ni->blocks[ti])
(111,RET)
(112,close(destDir)
(113,threads)
(114,destDir)
(115,bth)
(116,ni->blocks[ti])
(117,ti = 0)
(118,close(destDir)
(119,blocks)
(120,ti)
(121,ni)
(122,&ni->bth[ti])
(123,if (ni->threads == 1)
(124,sem_wait(&ni->bsem)
(125,ni)
(126,ti++)
(127,ni->brunning)
(128,pthread_mutex_unlock(&ni->blocks[ti])
(129,)
(130,)
(131,ni->bth)
(132,ti)
(133,free(name)
(134,ni)
(135,bpa)
(136,)
(137,ti)
(138,ni)
(139,ni->brunning[ti])
(140,ni->threads)
(141,bpa->name)
(142,*bpa = malloc(sizeof(BackupPathArgs)
(143,bpa->source)
(144,bpa->destDir)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^