-----label-----
0
-----code-----
static void goodB2G1()
{
    size_t data;
    /* Initialize data */
    data = 0;
    switch(6)
    {
    case 6:
        /* POTENTIAL FLAW: Set data to a random value */
        data = rand();
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine("Benign, fixed string");
        break;
    }
    switch(8)
    {
    case 7:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine("Benign, fixed string");
        break;
    default:
    {
        wchar_t * myString;
        /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough
         * for the wcscpy() function to not cause a buffer overflow */
        /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */
        if (data > wcslen(HELLO_STRING) && data < 100)
        {
            myString = (wchar_t *)malloc(data*sizeof(wchar_t));
            if (myString == NULL) {exit(-1);}
            /* Copy a small string into myString */
            wcscpy(myString, HELLO_STRING);
            printWLine(myString);
            free(myString);
        }
        else
        {
            printLine("Input is less than the length of the source string or too large");
        }
    }
    break;
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
6,7
7,8
7,9
8,9
10,11
12,13
13,14
13,15
14,15
17,18
17,19
19,20
19,21
19,22
19,23
19,24
19,25
20,21
22,23
23,24
23,25
24,25
26,27
27,28
31,32
32,33
32,34
33,34
37,38
37,39
39,40
39,41
39,42
39,43
39,44
39,45
40,41
42,43
43,44
43,45
44,45
49,50
49,51
50,51
51,52
51,53
53,54
53,55
56,57
56,58
56,59
57,58
57,59
58,59
58,60
59,60
61,62
61,63
62,63
64,65
66,67
66,68
67,68
70,71
70,72
70,73
70,74
70,75
71,72
72,73
72,74
73,74
75,76
75,77
76,77
76,78
78,79
80,81
80,82
81,82
83,84
83,85
84,85
86,87
87,88
87,89
90,91
90,92
91,92
91,93
92,93
94,95
96,97
97,98
98,99
98,100
99,100
101,102
103,104
104,105
104,106
104,107
105,106
107,108
109,110
111,112
112,113
112,114
113,114
115,116
117,118
118,119
118,120
119,120
121,122
123,124
124,125
125,126
125,127
126,127
-----nextToken-----
2,4,9,11,15,16,18,21,25,28,29,30,34,35,36,38,41,45,46,47,48,52,54,55,60,63,65,68,69,74,77,79,82,85,88,89,93,95,100,102,106,108,110,114,116,120,122,127,128,129
-----computeFrom-----
13,14
13,15
23,24
23,25
57,58
57,59
58,59
58,60
66,67
66,68
72,73
72,74
83,84
83,85
91,92
91,93
-----guardedBy-----
65,110
68,85
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;SwitchStatement;LiteralExpression;CompoundStatement;CaseStatement;LiteralExpression;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;BreakStatement;DefaultStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;BreakStatement;SwitchStatement;LiteralExpression;CompoundStatement;CaseStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;BreakStatement;DefaultStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;BreakStatement;
-----ast_node-----
static void goodB2G1(){    size_t data;    /* Initialize data */    data = 0;    switch(6)    {    case 6:        /* POTENTIAL FLAW: Set data to a random value */        data = rand();        break;    default:        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */        printLine("Benign, fixed string");        break;    }    switch(8)    {    case 7:        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */        printLine("Benign, fixed string");        break;    default:    {        wchar_t * myString;        /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough         * for the wcscpy() function to not cause a buffer overflow */        /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */        if (data > wcslen(HELLO_STRING) && data < 100)        {            myString = (wchar_t *)malloc(data*sizeof(wchar_t));            if (myString == NULL) {exit(-1);}            /* Copy a small string into myString */            wcscpy(myString, HELLO_STRING);            printWLine(myString);            free(myString);        }        else        {            printLine("Input is less than the length of the source string or too large");        }    }    break;    }}
static void
goodB2G1()
goodB2G1
{    size_t data;    /* Initialize data */    data = 0;    switch(6)    {    case 6:        /* POTENTIAL FLAW: Set data to a random value */        data = rand();        break;    default:        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */        printLine("Benign, fixed string");        break;    }    switch(8)    {    case 7:        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */        printLine("Benign, fixed string");        break;    default:    {        wchar_t * myString;        /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough         * for the wcscpy() function to not cause a buffer overflow */        /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */        if (data > wcslen(HELLO_STRING) && data < 100)        {            myString = (wchar_t *)malloc(data*sizeof(wchar_t));            if (myString == NULL) {exit(-1);}            /* Copy a small string into myString */            wcscpy(myString, HELLO_STRING);            printWLine(myString);            free(myString);        }        else        {            printLine("Input is less than the length of the source string or too large");        }    }    break;    }}
size_t data;
size_t data;
size_t
size_t
data
data
data = 0;
data = 0
data
data
0
switch(6)    {    case 6:        /* POTENTIAL FLAW: Set data to a random value */        data = rand();        break;    default:        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */        printLine("Benign, fixed string");        break;    }
6
{    case 6:        /* POTENTIAL FLAW: Set data to a random value */        data = rand();        break;    default:        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */        printLine("Benign, fixed string");        break;    }
case 6:
6
data = rand();
data = rand()
data
data
rand()
rand
rand
break;
default:
printLine("Benign, fixed string");
printLine("Benign, fixed string")
printLine
printLine
"Benign, fixed string"
break;
switch(8)    {    case 7:        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */        printLine("Benign, fixed string");        break;    default:    {        wchar_t * myString;        /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough         * for the wcscpy() function to not cause a buffer overflow */        /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */        if (data > wcslen(HELLO_STRING) && data < 100)        {            myString = (wchar_t *)malloc(data*sizeof(wchar_t));            if (myString == NULL) {exit(-1);}            /* Copy a small string into myString */            wcscpy(myString, HELLO_STRING);            printWLine(myString);            free(myString);        }        else        {            printLine("Input is less than the length of the source string or too large");        }    }    break;    }
8
{    case 7:        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */        printLine("Benign, fixed string");        break;    default:    {        wchar_t * myString;        /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough         * for the wcscpy() function to not cause a buffer overflow */        /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */        if (data > wcslen(HELLO_STRING) && data < 100)        {            myString = (wchar_t *)malloc(data*sizeof(wchar_t));            if (myString == NULL) {exit(-1);}            /* Copy a small string into myString */            wcscpy(myString, HELLO_STRING);            printWLine(myString);            free(myString);        }        else        {            printLine("Input is less than the length of the source string or too large");        }    }    break;    }
case 7:
7
printLine("Benign, fixed string");
printLine("Benign, fixed string")
printLine
printLine
"Benign, fixed string"
break;
default:
{        wchar_t * myString;        /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough         * for the wcscpy() function to not cause a buffer overflow */        /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */        if (data > wcslen(HELLO_STRING) && data < 100)        {            myString = (wchar_t *)malloc(data*sizeof(wchar_t));            if (myString == NULL) {exit(-1);}            /* Copy a small string into myString */            wcscpy(myString, HELLO_STRING);            printWLine(myString);            free(myString);        }        else        {            printLine("Input is less than the length of the source string or too large");        }    }
wchar_t * myString;
wchar_t * myString;
wchar_t
* myString
*
myString
if (data > wcslen(HELLO_STRING) && data < 100)        {            myString = (wchar_t *)malloc(data*sizeof(wchar_t));            if (myString == NULL) {exit(-1);}            /* Copy a small string into myString */            wcscpy(myString, HELLO_STRING);            printWLine(myString);            free(myString);        }        else        {            printLine("Input is less than the length of the source string or too large");        }
data > wcslen(HELLO_STRING) && data < 100
data > wcslen(HELLO_STRING)
data
data
wcslen(HELLO_STRING)
wcslen
wcslen
HELLO_STRING
HELLO_STRING
data < 100
data
data
100
{            myString = (wchar_t *)malloc(data*sizeof(wchar_t));            if (myString == NULL) {exit(-1);}            /* Copy a small string into myString */            wcscpy(myString, HELLO_STRING);            printWLine(myString);            free(myString);        }
myString = (wchar_t *)malloc(data*sizeof(wchar_t));
myString = (wchar_t *)malloc(data*sizeof(wchar_t))
myString
myString
(wchar_t *)malloc(data*sizeof(wchar_t))
wchar_t *
wchar_t
*
*
malloc(data*sizeof(wchar_t))
malloc
malloc
data*sizeof(wchar_t)
data
data
sizeof(wchar_t)
wchar_t
wchar_t

if (myString == NULL) {exit(-1);}
myString == NULL
myString
myString
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
wcscpy(myString, HELLO_STRING);
wcscpy(myString, HELLO_STRING)
wcscpy
wcscpy
myString
myString
HELLO_STRING
HELLO_STRING
printWLine(myString);
printWLine(myString)
printWLine
printWLine
myString
myString
free(myString);
free(myString)
free
free
myString
myString
{            printLine("Input is less than the length of the source string or too large");        }
printLine("Input is less than the length of the source string or too large");
printLine("Input is less than the length of the source string or too large")
printLine
printLine
"Input is less than the length of the source string or too large"
break;
-----joern-----
(47,40,0)
(57,60,0)
(3,40,0)
(54,30,0)
(10,63,0)
(40,47,0)
(38,22,0)
(21,53,0)
(22,38,0)
(34,65,0)
(38,65,0)
(15,26,0)
(58,65,0)
(43,5,0)
(25,27,0)
(28,47,0)
(52,26,0)
(58,30,0)
(18,33,0)
(0,33,0)
(6,33,0)
(47,28,0)
(49,58,0)
(9,47,0)
(59,30,0)
(30,54,0)
(47,9,0)
(24,33,0)
(17,63,0)
(26,40,0)
(59,49,0)
(29,48,0)
(28,38,0)
(40,63,0)
(38,30,0)
(1,63,0)
(49,59,0)
(46,10,0)
(45,12,0)
(10,40,0)
(58,49,0)
(61,30,0)
(2,12,0)
(64,58,0)
(23,38,0)
(55,17,0)
(19,65,0)
(32,0,0)
(41,12,0)
(59,65,0)
(4,12,0)
(8,5,0)
(48,42,0)
(60,63,0)
(53,11,0)
(14,21,0)
(13,36,0)
(59,27,0)
(35,17,0)
(17,40,0)
(7,33,0)
(20,5,0)
(36,12,0)
(60,40,0)
(27,59,0)
(65,5,0)
(30,33,0)
(56,58,0)
(44,59,0)
(38,28,0)
(37,16,0)
(53,21,0)
(50,22,0)
(51,16,0)
(16,12,0)
(49,58,1)
(29,49,1)
(65,34,1)
(41,36,1)
(54,61,1)
(10,40,1)
(7,30,1)
(62,4,1)
(55,35,1)
(27,25,1)
(4,10,1)
(58,30,1)
(31,65,1)
(39,24,1)
(38,30,1)
(64,59,1)
(40,47,1)
(52,15,1)
(13,39,1)
(0,32,1)
(50,23,1)
(62,41,1)
(17,40,1)
(35,53,1)
(14,26,1)
(3,49,1)
(49,59,1)
(17,55,1)
(39,7,1)
(21,14,1)
(58,65,1)
(25,44,1)
(53,21,1)
(15,40,1)
(26,40,1)
(36,13,1)
(10,46,1)
(23,3,1)
(61,31,1)
(24,0,1)
(30,54,1)
(59,65,1)
(32,31,1)
(38,22,1)
(47,9,1)
(58,56,1)
(26,52,1)
(60,40,1)
(35,26,1)
(60,57,1)
(56,64,1)
(47,28,1)
(22,50,1)
(38,65,1)
(28,38,1)
(57,17,1)
(59,30,1)
(46,60,1)
(48,29,1)
(59,27,1)
(4,48,1)
(34,19,1)
(44,39,1)
(4,39,2)
(50,49,2)
(29,49,2)
(59,30,2)
(56,59,2)
(55,49,2)
(46,49,2)
(58,59,2)
(61,31,2)
(36,39,2)
(22,49,2)
(10,49,2)
(13,39,2)
(10,40,2)
(26,40,2)
(14,26,2)
(15,49,2)
(47,9,2)
(28,38,2)
(59,65,2)
(60,49,2)
(17,49,2)
(59,39,2)
(38,22,2)
(60,40,2)
(58,30,2)
(40,47,2)
(26,49,2)
(47,28,2)
(52,49,2)
(25,39,2)
(17,40,2)
(27,39,2)
(41,39,2)
(58,65,2)
(21,26,2)
(49,59,2)
(28,49,2)
(48,49,2)
(38,30,2)
(0,31,2)
(54,31,2)
(57,49,2)
(64,59,2)
(3,49,2)
(59,27,2)
(23,49,2)
(35,49,2)
(32,31,2)
(38,65,2)
(40,49,2)
(30,54,2)
(53,21,2)
(53,26,2)
(7,31,2)
(38,49,2)
(49,39,2)
(24,31,2)
(44,39,2)
(49,58,2)
(30,31,2)
(47,49,2)
-----------------------------------
(0,printLine("Benign, fixed string")
(1,if (myString == NULL)
(2,case 7:)
(3,myString)
(4,break;)
(5,)
(6,case 6:)
(7,break;)
(8,data)
(9,wchar_t *)
(10,free(myString)
(11,)
(12,)
(13,"Benign, fixed string")
(14,1)
(15,myString)
(16,)
(17,wcscpy(myString, HELLO_STRING)
(18,default:)
(19,data)
(20,switch(6)
(21,-1)
(22,sizeof(wchar_t)
(23,data)
(24,break;)
(25,HELLO_STRING)
(26,myString == NULL)
(27,wcslen(HELLO_STRING)
(28,malloc(data*sizeof(wchar_t)
(29,"Input is less than the length of the source string or too large")
(30,data = rand()
(31,6)
(32,"Benign, fixed string")
(33,)
(34,0)
(35,myString)
(36,printLine("Benign, fixed string")
(37,myString)
(38,data*sizeof(wchar_t)
(39,8)
(40,myString = (wchar_t *)
(41,break;)
(42,)
(43,switch(8)
(44,data)
(45,default:)
(46,myString)
(47,(wchar_t *)
(48,printLine("Input is less than the length of the source string or too large")
(49,data > wcslen(HELLO_STRING)
(50,wchar_t)
(51,if (data > wcslen(HELLO_STRING)
(52,NULL)
(53,exit(-1)
(54,rand()
(55,HELLO_STRING)
(56,100)
(57,myString)
(58,data < 100)
(59,data > wcslen(HELLO_STRING)
(60,printWLine(myString)
(61,data)
(62,RET)
(63,)
(64,data)
(65,data = 0)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^