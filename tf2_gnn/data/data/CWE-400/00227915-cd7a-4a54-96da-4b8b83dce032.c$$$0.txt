-----label-----
1
-----code-----
static int set_member_paused(const char *queuename, const char *interface, const char *reason, int paused)
{
	int found = 0;
	struct call_queue *q;
	struct member *mem;
	struct ao2_iterator queue_iter;
	int failed;

	queue_iter = ao2_iterator_init(queues, 0);
	while ((q = ao2_t_iterator_next(&queue_iter, "Iterate over queues"))) {
		ao2_lock(q);
		if (ast_strlen_zero(queuename) || !strcasecmp(q->name, queuename)) {
			if ((mem = interface_exists(q, interface))) {
				if (mem->paused == paused) {
					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);
				}

				failed = 0;
				if (mem->realtime) {
					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");
				}

				if (failed) {
					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);
					ao2_ref(mem, -1);
					ao2_unlock(q);
					queue_t_unref(q, "Done with iterator");
					continue;
				}
				found++;

				/* Before we do the PAUSE/UNPAUSE log, if this was a PAUSEALL/UNPAUSEALL, log that here, but only on the first found entry. */
				if (found == 1) {

					/* XXX In all other cases, we use the membername, but since this affects all queues, we cannot */
					if (ast_strlen_zero(queuename)) {
						ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");
					}
				}

				mem->paused = paused;

				if (queue_persistent_members) {
					dump_queue_members(q);
				}

				if (is_member_available(mem)) {
					ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s_avail", q->name);
				} else if (!num_available_members(q)) {
					ast_devstate_changed(AST_DEVICE_INUSE, "Queue:%s_avail", q->name);
				}

				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));

				/*** DOCUMENTATION
				<managerEventInstance>
					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>
					<syntax>
						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />
						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />
						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />
						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />
					</syntax>
					<see-also>
						<ref type="application">PauseQueueMember</ref>
						<ref type="application">UnPauseQueueMember</ref>
					</see-also>
				</managerEventInstance>
				***/
				if (!ast_strlen_zero(reason)) {
					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",
						"Queue: %s\r\n"
						"Location: %s\r\n"
						"MemberName: %s\r\n"
						"Paused: %d\r\n"
						"Reason: %s\r\n",
							q->name, mem->interface, mem->membername, paused, reason);
				} else {
					/*** DOCUMENTATION
					<managerEventInstance>
						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>
						<syntax>
							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />
							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />
							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />
							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />
						</syntax>
						<see-also>
							<ref type="application">PauseQueueMember</ref>
							<ref type="application">UnPauseQueueMember</ref>
						</see-also>
					</managerEventInstance>
					***/
					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",
						"Queue: %s\r\n"
						"Location: %s\r\n"
						"MemberName: %s\r\n"
						"Paused: %d\r\n",
							q->name, mem->interface, mem->membername, paused);
				}
				ao2_ref(mem, -1);
			}
		}

		if (!ast_strlen_zero(queuename) && !strcasecmp(queuename, q->name)) {
			ao2_unlock(q);
			queue_t_unref(q, "Done with iterator");
			break;
		}

		ao2_unlock(q);
		queue_t_unref(q, "Done with iterator");
	}
	ao2_iterator_destroy(&queue_iter);

	return found ? RESULT_SUCCESS : RESULT_FAILURE;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
7,8
7,9
10,11
10,12
12,13
12,14
15,16
15,17
17,18
17,19
20,21
20,22
22,23
24,25
24,26
24,27
24,28
24,29
24,30
24,31
24,32
24,33
25,26
26,27
26,28
28,29
28,30
30,31
32,33
33,34
33,35
34,35
36,37
36,38
39,40
40,41
40,42
41,42
43,44
43,45
46,47
47,48
47,49
48,49
50,51
52,53
53,54
53,55
55,56
57,58
58,59
58,60
59,60
61,62
61,63
61,64
62,63
64,65
67,68
67,69
68,69
69,70
69,71
70,71
72,73
72,74
72,75
73,74
75,76
76,77
79,80
79,81
79,82
79,83
79,84
80,81
81,82
81,83
82,83
84,85
86,87
86,88
87,88
87,89
88,89
88,90
89,90
91,92
93,94
94,95
94,96
94,97
95,96
97,98
97,99
98,99
101,102
103,104
104,105
104,106
105,106
106,107
106,108
107,108
109,110
109,111
109,112
110,111
112,113
114,115
116,117
116,118
116,119
116,120
116,121
116,122
116,123
116,124
116,125
116,126
116,127
116,128
117,118
117,119
118,119
118,120
119,120
119,121
120,121
123,124
125,126
126,127
127,128
127,129
127,130
127,131
127,132
127,133
127,134
128,129
132,133
133,134
133,135
133,136
134,135
138,139
139,140
139,141
139,142
140,141
144,145
144,146
145,146
148,149
150,151
151,152
151,153
152,153
155,156
155,157
156,157
156,158
157,158
160,161
161,162
162,163
162,164
163,164
165,166
165,167
165,168
165,169
165,170
166,167
168,169
170,171
170,172
171,172
175,176
175,177
175,178
176,177
180,181
180,182
181,182
183,184
183,185
183,186
183,187
183,188
184,185
185,186
185,187
185,188
185,189
185,190
185,191
186,187
188,189
191,192
192,193
192,194
192,195
193,194
197,198
197,199
198,199
201,202
203,204
204,205
204,206
204,207
205,206
207,208
209,210
211,212
212,213
212,214
213,214
215,216
217,218
218,219
218,220
218,221
219,220
221,222
225,226
226,227
227,228
229,230
229,231
230,231
230,232
231,232
234,235
235,236
235,237
236,237
236,238
237,238
239,240
241,242
242,243
243,244
243,245
243,246
243,247
243,248
243,249
243,250
244,245
248,249
250,251
251,252
251,253
251,254
252,253
258,259
259,260
259,261
260,261
260,262
261,262
264,265
266,267
266,268
267,268
269,270
270,271
271,272
271,273
272,273
274,275
276,277
276,278
276,279
277,278
277,279
278,279
280,281
282,283
283,284
284,285
284,286
284,287
284,288
285,286
287,288
290,291
290,292
291,292
294,295
294,296
295,296
296,297
296,298
297,298
299,300
301,302
302,303
303,304
303,305
303,306
303,307
304,305
306,307
309,310
309,311
310,311
313,314
314,315
314,316
314,317
314,318
314,319
314,320
314,321
315,316
317,318
317,319
318,319
322,323
322,324
323,324
326,327
327,328
327,329
327,330
328,329
333,334
333,335
333,336
334,335
336,337
339,340
339,341
339,342
340,341
341,342
341,343
342,343
344,345
346,347
347,348
348,349
348,350
348,351
348,352
348,353
348,354
348,355
348,356
348,357
349,350
351,352
355,356
355,357
356,357
359,360
359,361
360,361
363,364
363,365
364,365
367,368
369,370
371,372
372,373
373,374
373,375
373,376
373,377
373,378
373,379
373,380
373,381
374,375
376,377
380,381
380,382
381,382
384,385
384,386
385,386
388,389
388,390
389,390
392,393
394,395
395,396
395,397
395,398
396,397
398,399
400,401
402,403
402,404
403,404
403,405
404,405
405,406
405,407
406,407
408,409
410,411
411,412
411,413
411,414
412,413
414,415
416,417
416,418
417,418
420,421
420,422
420,423
421,422
422,423
422,424
423,424
425,426
427,428
428,429
428,430
428,431
429,430
431,432
435,436
436,437
436,438
437,438
439,440
441,442
442,443
442,444
442,445
443,444
445,446
448,449
449,450
449,451
450,451
452,453
453,454
455,456
456,457
456,458
456,459
457,458
459,460
461,462
-----nextToken-----
2,4,6,8,9,11,13,14,16,18,19,21,23,27,29,31,35,37,38,42,44,45,49,51,54,56,60,63,65,66,71,74,77,78,83,85,90,92,96,99,100,102,108,111,113,115,121,122,124,129,130,131,135,136,137,141,142,143,146,147,149,153,154,158,159,164,167,169,172,173,174,177,178,179,182,187,189,190,194,195,196,199,200,202,206,208,210,214,216,220,222,223,224,228,232,233,238,240,245,246,247,249,253,254,255,256,257,262,263,265,268,273,275,279,281,286,288,289,292,293,298,300,305,307,308,311,312,316,319,320,321,324,325,329,330,331,332,335,337,338,343,345,350,352,353,354,357,358,361,362,365,366,368,370,375,377,378,379,382,383,386,387,390,391,393,397,399,401,407,409,413,415,418,419,424,426,430,432,433,434,438,440,444,446,447,451,454,458,460,462
-----computeFrom-----
58,59
58,60
69,70
69,71
87,88
87,89
106,107
106,108
118,119
118,120
151,152
151,153
162,163
162,164
230,231
230,232
259,260
259,261
403,404
403,405
-----guardedBy-----
102,240
99,382
100,383
90,343
124,141
418,432
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;LiteralExpression;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;WhileStatement;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;IfStatement;UnaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;UnaryExpression;ConditionalExpression;IdExpression;Name;LiteralExpression;LiteralExpression;UnaryExpression;ConditionalExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;ConditionalExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;ConditionalExpression;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ContinueStatement;ExpressionStatement;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;LiteralExpression;IdExpression;Name;UnaryExpression;ConditionalExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;UnaryExpression;ConditionalExpression;IdExpression;Name;LiteralExpression;LiteralExpression;LiteralExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;LiteralExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;IdExpression;Name;ReturnStatement;ConditionalExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;
-----ast_node-----
static int set_member_paused(const char *queuename, const char *interface, const char *reason, int paused){	int found = 0;	struct call_queue *q;	struct member *mem;	struct ao2_iterator queue_iter;	int failed;	queue_iter = ao2_iterator_init(queues, 0);	while ((q = ao2_t_iterator_next(&queue_iter, "Iterate over queues"))) {		ao2_lock(q);		if (ast_strlen_zero(queuename) || !strcasecmp(q->name, queuename)) {			if ((mem = interface_exists(q, interface))) {				if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}				failed = 0;				if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}				if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}				found++;				/* Before we do the PAUSE/UNPAUSE log, if this was a PAUSEALL/UNPAUSEALL, log that here, but only on the first found entry. */				if (found == 1) {					/* XXX In all other cases, we use the membername, but since this affects all queues, we cannot */					if (ast_strlen_zero(queuename)) {						ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");					}				}				mem->paused = paused;				if (queue_persistent_members) {					dump_queue_members(q);				}				if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, "Queue:%s_avail", q->name);				}				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));				/*** DOCUMENTATION				<managerEventInstance>					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>					<syntax>						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />					</syntax>					<see-also>						<ref type="application">PauseQueueMember</ref>						<ref type="application">UnPauseQueueMember</ref>					</see-also>				</managerEventInstance>				***/				if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}				ao2_ref(mem, -1);			}		}		if (!ast_strlen_zero(queuename) && !strcasecmp(queuename, q->name)) {			ao2_unlock(q);			queue_t_unref(q, "Done with iterator");			break;		}		ao2_unlock(q);		queue_t_unref(q, "Done with iterator");	}	ao2_iterator_destroy(&queue_iter);	return found ? RESULT_SUCCESS : RESULT_FAILURE;}
static int
set_member_paused(const char *queuename, const char *interface, const char *reason, int paused)
set_member_paused
const char *queuename
const char
*queuename
*
queuename
const char *interface
const char
*interface
*
interface
const char *reason
const char
*reason
*
reason
int paused
int
paused
paused
{	int found = 0;	struct call_queue *q;	struct member *mem;	struct ao2_iterator queue_iter;	int failed;	queue_iter = ao2_iterator_init(queues, 0);	while ((q = ao2_t_iterator_next(&queue_iter, "Iterate over queues"))) {		ao2_lock(q);		if (ast_strlen_zero(queuename) || !strcasecmp(q->name, queuename)) {			if ((mem = interface_exists(q, interface))) {				if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}				failed = 0;				if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}				if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}				found++;				/* Before we do the PAUSE/UNPAUSE log, if this was a PAUSEALL/UNPAUSEALL, log that here, but only on the first found entry. */				if (found == 1) {					/* XXX In all other cases, we use the membername, but since this affects all queues, we cannot */					if (ast_strlen_zero(queuename)) {						ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");					}				}				mem->paused = paused;				if (queue_persistent_members) {					dump_queue_members(q);				}				if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, "Queue:%s_avail", q->name);				}				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));				/*** DOCUMENTATION				<managerEventInstance>					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>					<syntax>						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />					</syntax>					<see-also>						<ref type="application">PauseQueueMember</ref>						<ref type="application">UnPauseQueueMember</ref>					</see-also>				</managerEventInstance>				***/				if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}				ao2_ref(mem, -1);			}		}		if (!ast_strlen_zero(queuename) && !strcasecmp(queuename, q->name)) {			ao2_unlock(q);			queue_t_unref(q, "Done with iterator");			break;		}		ao2_unlock(q);		queue_t_unref(q, "Done with iterator");	}	ao2_iterator_destroy(&queue_iter);	return found ? RESULT_SUCCESS : RESULT_FAILURE;}
int found = 0;
int found = 0;
int
found = 0
found
= 0
0
struct call_queue *q;
struct call_queue *q;
struct call_queue
call_queue
*q
*
q
struct member *mem;
struct member *mem;
struct member
member
*mem
*
mem
struct ao2_iterator queue_iter;
struct ao2_iterator queue_iter;
struct ao2_iterator
ao2_iterator
queue_iter
queue_iter
int failed;
int failed;
int
failed
failed
queue_iter = ao2_iterator_init(queues, 0);
queue_iter = ao2_iterator_init(queues, 0)
queue_iter
queue_iter
ao2_iterator_init(queues, 0)
ao2_iterator_init
ao2_iterator_init
queues
queues
0
while ((q = ao2_t_iterator_next(&queue_iter, "Iterate over queues"))) {		ao2_lock(q);		if (ast_strlen_zero(queuename) || !strcasecmp(q->name, queuename)) {			if ((mem = interface_exists(q, interface))) {				if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}				failed = 0;				if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}				if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}				found++;				/* Before we do the PAUSE/UNPAUSE log, if this was a PAUSEALL/UNPAUSEALL, log that here, but only on the first found entry. */				if (found == 1) {					/* XXX In all other cases, we use the membername, but since this affects all queues, we cannot */					if (ast_strlen_zero(queuename)) {						ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");					}				}				mem->paused = paused;				if (queue_persistent_members) {					dump_queue_members(q);				}				if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, "Queue:%s_avail", q->name);				}				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));				/*** DOCUMENTATION				<managerEventInstance>					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>					<syntax>						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />					</syntax>					<see-also>						<ref type="application">PauseQueueMember</ref>						<ref type="application">UnPauseQueueMember</ref>					</see-also>				</managerEventInstance>				***/				if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}				ao2_ref(mem, -1);			}		}		if (!ast_strlen_zero(queuename) && !strcasecmp(queuename, q->name)) {			ao2_unlock(q);			queue_t_unref(q, "Done with iterator");			break;		}		ao2_unlock(q);		queue_t_unref(q, "Done with iterator");	}
(q = ao2_t_iterator_next(&queue_iter, "Iterate over queues"))
q = ao2_t_iterator_next(&queue_iter, "Iterate over queues")
q
q
ao2_t_iterator_next(&queue_iter, "Iterate over queues")
ao2_t_iterator_next
ao2_t_iterator_next
&queue_iter
queue_iter
queue_iter
"Iterate over queues"
{		ao2_lock(q);		if (ast_strlen_zero(queuename) || !strcasecmp(q->name, queuename)) {			if ((mem = interface_exists(q, interface))) {				if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}				failed = 0;				if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}				if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}				found++;				/* Before we do the PAUSE/UNPAUSE log, if this was a PAUSEALL/UNPAUSEALL, log that here, but only on the first found entry. */				if (found == 1) {					/* XXX In all other cases, we use the membername, but since this affects all queues, we cannot */					if (ast_strlen_zero(queuename)) {						ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");					}				}				mem->paused = paused;				if (queue_persistent_members) {					dump_queue_members(q);				}				if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, "Queue:%s_avail", q->name);				}				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));				/*** DOCUMENTATION				<managerEventInstance>					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>					<syntax>						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />					</syntax>					<see-also>						<ref type="application">PauseQueueMember</ref>						<ref type="application">UnPauseQueueMember</ref>					</see-also>				</managerEventInstance>				***/				if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}				ao2_ref(mem, -1);			}		}		if (!ast_strlen_zero(queuename) && !strcasecmp(queuename, q->name)) {			ao2_unlock(q);			queue_t_unref(q, "Done with iterator");			break;		}		ao2_unlock(q);		queue_t_unref(q, "Done with iterator");	}
ao2_lock(q);
ao2_lock(q)
ao2_lock
ao2_lock
q
q
if (ast_strlen_zero(queuename) || !strcasecmp(q->name, queuename)) {			if ((mem = interface_exists(q, interface))) {				if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}				failed = 0;				if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}				if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}				found++;				/* Before we do the PAUSE/UNPAUSE log, if this was a PAUSEALL/UNPAUSEALL, log that here, but only on the first found entry. */				if (found == 1) {					/* XXX In all other cases, we use the membername, but since this affects all queues, we cannot */					if (ast_strlen_zero(queuename)) {						ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");					}				}				mem->paused = paused;				if (queue_persistent_members) {					dump_queue_members(q);				}				if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, "Queue:%s_avail", q->name);				}				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));				/*** DOCUMENTATION				<managerEventInstance>					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>					<syntax>						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />					</syntax>					<see-also>						<ref type="application">PauseQueueMember</ref>						<ref type="application">UnPauseQueueMember</ref>					</see-also>				</managerEventInstance>				***/				if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}				ao2_ref(mem, -1);			}		}
ast_strlen_zero(queuename) || !strcasecmp(q->name, queuename)
ast_strlen_zero(queuename)
ast_strlen_zero
ast_strlen_zero
queuename
queuename
!strcasecmp(q->name, queuename)
strcasecmp(q->name, queuename)
strcasecmp
strcasecmp
q->name
q
q
name
queuename
queuename
{			if ((mem = interface_exists(q, interface))) {				if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}				failed = 0;				if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}				if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}				found++;				/* Before we do the PAUSE/UNPAUSE log, if this was a PAUSEALL/UNPAUSEALL, log that here, but only on the first found entry. */				if (found == 1) {					/* XXX In all other cases, we use the membername, but since this affects all queues, we cannot */					if (ast_strlen_zero(queuename)) {						ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");					}				}				mem->paused = paused;				if (queue_persistent_members) {					dump_queue_members(q);				}				if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, "Queue:%s_avail", q->name);				}				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));				/*** DOCUMENTATION				<managerEventInstance>					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>					<syntax>						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />					</syntax>					<see-also>						<ref type="application">PauseQueueMember</ref>						<ref type="application">UnPauseQueueMember</ref>					</see-also>				</managerEventInstance>				***/				if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}				ao2_ref(mem, -1);			}		}
if ((mem = interface_exists(q, interface))) {				if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}				failed = 0;				if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}				if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}				found++;				/* Before we do the PAUSE/UNPAUSE log, if this was a PAUSEALL/UNPAUSEALL, log that here, but only on the first found entry. */				if (found == 1) {					/* XXX In all other cases, we use the membername, but since this affects all queues, we cannot */					if (ast_strlen_zero(queuename)) {						ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");					}				}				mem->paused = paused;				if (queue_persistent_members) {					dump_queue_members(q);				}				if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, "Queue:%s_avail", q->name);				}				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));				/*** DOCUMENTATION				<managerEventInstance>					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>					<syntax>						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />					</syntax>					<see-also>						<ref type="application">PauseQueueMember</ref>						<ref type="application">UnPauseQueueMember</ref>					</see-also>				</managerEventInstance>				***/				if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}				ao2_ref(mem, -1);			}
(mem = interface_exists(q, interface))
mem = interface_exists(q, interface)
mem
mem
interface_exists(q, interface)
interface_exists
interface_exists
q
q
interface
interface
{				if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}				failed = 0;				if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}				if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}				found++;				/* Before we do the PAUSE/UNPAUSE log, if this was a PAUSEALL/UNPAUSEALL, log that here, but only on the first found entry. */				if (found == 1) {					/* XXX In all other cases, we use the membername, but since this affects all queues, we cannot */					if (ast_strlen_zero(queuename)) {						ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");					}				}				mem->paused = paused;				if (queue_persistent_members) {					dump_queue_members(q);				}				if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, "Queue:%s_avail", q->name);				}				ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));				/*** DOCUMENTATION				<managerEventInstance>					<synopsis>Raised when a member is paused/unpaused in the queue with a reason.</synopsis>					<syntax>						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />						<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />					</syntax>					<see-also>						<ref type="application">PauseQueueMember</ref>						<ref type="application">UnPauseQueueMember</ref>					</see-also>				</managerEventInstance>				***/				if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}				ao2_ref(mem, -1);			}
if (mem->paused == paused) {					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}
mem->paused == paused
mem->paused
mem
mem
paused
paused
paused
{					ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);				}
ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface);
ast_debug(1, "%spausing already-%spaused queue member %s:%s\n", (paused ? "" : "un"), (paused ? "" : "un"), q->name, interface)
ast_debug
ast_debug
1
"%spausing already-%spaused queue member %s:%s\n"
(paused ? "" : "un")
paused ? "" : "un"
paused
paused
""
"un"
(paused ? "" : "un")
paused ? "" : "un"
paused
paused
""
"un"
q->name
q
q
name
interface
interface
failed = 0;
failed = 0
failed
failed
0
if (mem->realtime) {					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}
mem->realtime
mem
mem
realtime
{					failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");				}
failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0");
failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0")
failed
failed
update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0")
update_realtime_member_field
update_realtime_member_field
mem
mem
q->name
q
q
name
"paused"
paused ? "1" : "0"
paused
paused
"1"
"0"
if (failed) {					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}
failed
failed
{					ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);					ao2_ref(mem, -1);					ao2_unlock(q);					queue_t_unref(q, "Done with iterator");					continue;				}
ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface);
ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\n", (paused ? "" : "un"), q->name, interface)
ast_log
ast_log
LOG_WARNING
LOG_WARNING
"Failed %spausing realtime queue member %s:%s\n"
(paused ? "" : "un")
paused ? "" : "un"
paused
paused
""
"un"
q->name
q
q
name
interface
interface
ao2_ref(mem, -1);
ao2_ref(mem, -1)
ao2_ref
ao2_ref
mem
mem
-1
1
ao2_unlock(q);
ao2_unlock(q)
ao2_unlock
ao2_unlock
q
q
queue_t_unref(q, "Done with iterator");
queue_t_unref(q, "Done with iterator")
queue_t_unref
queue_t_unref
q
q
"Done with iterator"
continue;
found++;
found++
found
found
if (found == 1) {					/* XXX In all other cases, we use the membername, but since this affects all queues, we cannot */					if (ast_strlen_zero(queuename)) {						ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");					}				}
found == 1
found
found
1
{					/* XXX In all other cases, we use the membername, but since this affects all queues, we cannot */					if (ast_strlen_zero(queuename)) {						ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");					}				}
if (ast_strlen_zero(queuename)) {						ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");					}
ast_strlen_zero(queuename)
ast_strlen_zero
ast_strlen_zero
queuename
queuename
{						ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");					}
ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "");
ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL"), "%s", "")
ast_queue_log
ast_queue_log
"NONE"
"NONE"
interface
interface
(paused ? "PAUSEALL" : "UNPAUSEALL")
paused ? "PAUSEALL" : "UNPAUSEALL"
paused
paused
"PAUSEALL"
"UNPAUSEALL"
"%s"
""
mem->paused = paused;
mem->paused = paused
mem->paused
mem
mem
paused
paused
paused
if (queue_persistent_members) {					dump_queue_members(q);				}
queue_persistent_members
queue_persistent_members
{					dump_queue_members(q);				}
dump_queue_members(q);
dump_queue_members(q)
dump_queue_members
dump_queue_members
q
q
if (is_member_available(mem)) {					ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s_avail", q->name);				} else if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, "Queue:%s_avail", q->name);				}
is_member_available(mem)
is_member_available
is_member_available
mem
mem
{					ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s_avail", q->name);				}
ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s_avail", q->name);
ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s_avail", q->name)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_NOT_INUSE
AST_DEVICE_NOT_INUSE
"Queue:%s_avail"
q->name
q
q
name
if (!num_available_members(q)) {					ast_devstate_changed(AST_DEVICE_INUSE, "Queue:%s_avail", q->name);				}
!num_available_members(q)
num_available_members(q)
num_available_members
num_available_members
q
q
{					ast_devstate_changed(AST_DEVICE_INUSE, "Queue:%s_avail", q->name);				}
ast_devstate_changed(AST_DEVICE_INUSE, "Queue:%s_avail", q->name);
ast_devstate_changed(AST_DEVICE_INUSE, "Queue:%s_avail", q->name)
ast_devstate_changed
ast_devstate_changed
AST_DEVICE_INUSE
AST_DEVICE_INUSE
"Queue:%s_avail"
q->name
q
q
name
ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""));
ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE"), "%s", S_OR(reason, ""))
ast_queue_log
ast_queue_log
q->name
q
q
name
"NONE"
mem->membername
mem
mem
membername
(paused ? "PAUSE" : "UNPAUSE")
paused ? "PAUSE" : "UNPAUSE"
paused
paused
"PAUSE"
"UNPAUSE"
"%s"
S_OR(reason, "")
S_OR
S_OR
reason
reason
""
if (!ast_strlen_zero(reason)) {					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				} else {					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}
!ast_strlen_zero(reason)
ast_strlen_zero(reason)
ast_strlen_zero
ast_strlen_zero
reason
reason
{					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);				}
manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason);
manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n",							q->name, mem->interface, mem->membername, paused, reason)
manager_event
manager_event
EVENT_FLAG_AGENT
EVENT_FLAG_AGENT
"QueueMemberPaused"
"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"						"Reason: %s\r\n"
q->name
q
q
name
mem->interface
mem
mem
interface
mem->membername
mem
mem
membername
paused
paused
reason
reason
{					/*** DOCUMENTATION					<managerEventInstance>						<synopsis>Raised when a member is paused/unpaused in the queue without a reason.</synopsis>						<syntax>							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Queue'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Location'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='MemberName'])" />							<xi:include xpointer="xpointer(/docs/managerEvent[@name='QueueMemberStatus']/managerEventInstance/syntax/parameter[@name='Paused'])" />						</syntax>						<see-also>							<ref type="application">PauseQueueMember</ref>							<ref type="application">UnPauseQueueMember</ref>						</see-also>					</managerEventInstance>					***/					manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);				}
manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused);
manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",						"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n",							q->name, mem->interface, mem->membername, paused)
manager_event
manager_event
EVENT_FLAG_AGENT
EVENT_FLAG_AGENT
"QueueMemberPaused"
"Queue: %s\r\n"						"Location: %s\r\n"						"MemberName: %s\r\n"						"Paused: %d\r\n"
q->name
q
q
name
mem->interface
mem
mem
interface
mem->membername
mem
mem
membername
paused
paused
ao2_ref(mem, -1);
ao2_ref(mem, -1)
ao2_ref
ao2_ref
mem
mem
-1
1
if (!ast_strlen_zero(queuename) && !strcasecmp(queuename, q->name)) {			ao2_unlock(q);			queue_t_unref(q, "Done with iterator");			break;		}
!ast_strlen_zero(queuename) && !strcasecmp(queuename, q->name)
!ast_strlen_zero(queuename)
ast_strlen_zero(queuename)
ast_strlen_zero
ast_strlen_zero
queuename
queuename
!strcasecmp(queuename, q->name)
strcasecmp(queuename, q->name)
strcasecmp
strcasecmp
queuename
queuename
q->name
q
q
name
{			ao2_unlock(q);			queue_t_unref(q, "Done with iterator");			break;		}
ao2_unlock(q);
ao2_unlock(q)
ao2_unlock
ao2_unlock
q
q
queue_t_unref(q, "Done with iterator");
queue_t_unref(q, "Done with iterator")
queue_t_unref
queue_t_unref
q
q
"Done with iterator"
break;
ao2_unlock(q);
ao2_unlock(q)
ao2_unlock
ao2_unlock
q
q
queue_t_unref(q, "Done with iterator");
queue_t_unref(q, "Done with iterator")
queue_t_unref
queue_t_unref
q
q
"Done with iterator"
ao2_iterator_destroy(&queue_iter);
ao2_iterator_destroy(&queue_iter)
ao2_iterator_destroy
ao2_iterator_destroy
&queue_iter
queue_iter
queue_iter
return found ? RESULT_SUCCESS : RESULT_FAILURE;
found ? RESULT_SUCCESS : RESULT_FAILURE
found
found
RESULT_SUCCESS
RESULT_SUCCESS
RESULT_FAILURE
RESULT_FAILURE
-----joern-----
(160,179,0)
(232,115,0)
(133,64,0)
(74,86,0)
(19,100,0)
(241,29,0)
(134,212,0)
(114,203,0)
(223,59,0)
(217,216,0)
(96,64,0)
(9,56,0)
(164,195,0)
(191,118,0)
(57,19,0)
(200,22,0)
(13,91,0)
(80,187,0)
(185,69,0)
(103,104,0)
(133,180,0)
(11,207,0)
(17,118,0)
(131,35,0)
(37,100,0)
(222,119,0)
(184,151,0)
(87,64,0)
(106,139,0)
(172,23,0)
(221,35,0)
(86,64,0)
(244,33,0)
(119,133,0)
(129,119,0)
(188,27,0)
(158,26,0)
(97,87,0)
(117,226,0)
(158,105,0)
(92,10,0)
(205,187,0)
(205,198,0)
(71,212,0)
(48,16,0)
(239,64,0)
(95,210,0)
(79,10,0)
(163,195,0)
(210,95,0)
(222,158,0)
(240,23,0)
(99,180,0)
(67,149,0)
(132,1,0)
(152,64,0)
(233,150,0)
(1,118,0)
(98,195,0)
(158,124,0)
(0,246,0)
(11,209,0)
(126,158,0)
(139,214,0)
(241,26,0)
(136,119,0)
(47,221,0)
(201,136,0)
(190,64,0)
(61,63,0)
(206,109,0)
(118,1,0)
(20,96,0)
(22,92,0)
(27,64,0)
(187,205,0)
(142,167,0)
(52,226,0)
(121,64,0)
(23,91,0)
(232,181,0)
(18,31,0)
(182,158,0)
(136,189,0)
(239,83,0)
(225,21,0)
(125,86,0)
(151,64,0)
(91,23,0)
(141,64,0)
(69,185,0)
(99,78,0)
(102,189,0)
(156,141,0)
(178,152,0)
(167,119,0)
(115,73,0)
(213,65,0)
(44,11,0)
(90,134,0)
(124,119,0)
(218,207,0)
(176,119,0)
(48,115,0)
(135,189,0)
(42,96,0)
(139,106,0)
(137,22,0)
(200,212,0)
(220,176,0)
(246,31,0)
(29,241,0)
(19,242,0)
(210,64,0)
(193,112,0)
(28,189,0)
(196,112,0)
(19,59,0)
(111,95,0)
(159,207,0)
(27,56,0)
(81,141,0)
(107,168,0)
(23,25,0)
(36,48,0)
(230,181,0)
(139,249,0)
(21,225,0)
(186,212,0)
(187,87,0)
(1,216,0)
(109,65,0)
(100,64,0)
(45,222,0)
(62,133,0)
(55,239,0)
(197,54,0)
(214,181,0)
(235,124,0)
(41,59,0)
(92,212,0)
(226,181,0)
(100,19,0)
(236,126,0)
(104,64,0)
(24,226,0)
(150,35,0)
(113,168,0)
(149,64,0)
(158,222,0)
(196,119,0)
(34,83,0)
(96,109,0)
(108,124,0)
(101,106,0)
(64,210,0)
(231,196,0)
(122,119,0)
(46,73,0)
(237,152,0)
(215,1,0)
(118,181,0)
(106,119,0)
(208,23,0)
(150,134,0)
(219,119,0)
(43,150,0)
(145,35,0)
(35,212,0)
(229,99,0)
(21,64,0)
(69,65,0)
(133,119,0)
(6,92,0)
(66,87,0)
(70,126,0)
(249,139,0)
(179,189,0)
(166,214,0)
(136,201,0)
(155,213,0)
(154,201,0)
(238,109,0)
(183,212,0)
(130,99,0)
(5,118,0)
(50,136,0)
(190,83,0)
(139,149,0)
(3,139,0)
(84,232,0)
(149,139,0)
(206,185,0)
(99,226,0)
(1,56,0)
(59,119,0)
(115,232,0)
(68,189,0)
(219,230,0)
(88,1,0)
(59,19,0)
(86,31,0)
(109,96,0)
(129,230,0)
(234,198,0)
(192,176,0)
(171,232,0)
(120,149,0)
(77,19,0)
(63,189,0)
(1,180,0)
(195,181,0)
(228,91,0)
(199,10,0)
(75,115,0)
(109,206,0)
(126,64,0)
(202,214,0)
(76,219,0)
(4,106,0)
(110,83,0)
(33,65,0)
(175,23,0)
(51,115,0)
(139,189,0)
(49,219,0)
(73,64,0)
(176,19,0)
(198,205,0)
(151,83,0)
(177,221,0)
(224,247,0)
(174,19,0)
(60,212,0)
(10,92,0)
(95,92,0)
(161,203,0)
(214,139,0)
(19,181,0)
(148,158,0)
(23,180,0)
(138,73,0)
(82,222,0)
(146,189,0)
(243,69,0)
(157,91,0)
(8,212,0)
(115,48,0)
(15,12,0)
(195,99,0)
(246,64,0)
(144,232,0)
(72,129,0)
(152,203,0)
(245,63,0)
(115,119,0)
(143,11,0)
(194,158,0)
(7,216,0)
(158,126,0)
(207,64,0)
(40,23,0)
(91,181,0)
(226,99,0)
(247,181,0)
(123,210,0)
(140,100,0)
(204,99,0)
(53,189,0)
(227,27,0)
(73,115,0)
(134,129,0)
(87,187,0)
(127,133,0)
(247,219,0)
(116,129,0)
(230,189,0)
(147,9,0)
(128,249,0)
(158,181,0)
(19,176,0)
(32,214,0)
(203,152,0)
(211,19,0)
(112,196,0)
(153,241,0)
(99,141,0)
(93,190,0)
(248,56,0)
(39,158,0)
(38,249,0)
(216,64,0)
(249,26,0)
(141,99,0)
(168,119,0)
(213,234,0)
(196,56,0)
(169,230,0)
(185,206,0)
(179,35,0)
(187,65,0)
(99,195,0)
(58,212,0)
(124,158,0)
(198,234,0)
(22,200,0)
(216,1,0)
(162,21,0)
(219,247,0)
(94,150,0)
(104,85,0)
(165,151,0)
(9,64,0)
(203,2,0)
(207,11,0)
(14,189,0)
(30,158,0)
(89,139,0)
(234,213,0)
(93,64,1)
(52,117,1)
(226,24,1)
(214,32,1)
(24,117,1)
(21,64,1)
(185,206,1)
(123,95,1)
(185,69,1)
(155,136,1)
(125,74,1)
(95,92,1)
(96,20,1)
(19,59,1)
(40,91,1)
(158,222,1)
(175,33,1)
(114,225,1)
(106,119,1)
(115,232,1)
(23,91,1)
(199,79,1)
(107,63,1)
(213,65,1)
(96,64,1)
(120,67,1)
(76,49,1)
(35,145,1)
(19,100,1)
(178,237,1)
(87,64,1)
(1,180,1)
(165,184,1)
(190,93,1)
(139,149,1)
(119,133,1)
(91,157,1)
(150,233,1)
(6,35,1)
(218,143,1)
(221,47,1)
(156,226,1)
(99,130,1)
(20,42,1)
(33,65,1)
(22,137,1)
(167,119,1)
(237,161,1)
(133,127,1)
(208,175,1)
(245,99,1)
(46,51,1)
(67,203,1)
(137,18,1)
(158,181,1)
(121,151,1)
(241,26,1)
(7,118,1)
(210,95,1)
(109,96,1)
(101,3,1)
(55,198,1)
(82,126,1)
(112,193,1)
(124,119,1)
(45,82,1)
(170,230,1)
(214,202,1)
(81,156,1)
(232,181,1)
(129,72,1)
(196,112,1)
(167,142,1)
(74,246,1)
(87,66,1)
(216,64,1)
(164,98,1)
(138,46,1)
(226,52,1)
(194,29,1)
(143,44,1)
(247,219,1)
(184,239,1)
(187,65,1)
(226,181,1)
(127,62,1)
(33,244,1)
(169,129,1)
(202,166,1)
(95,111,1)
(190,64,1)
(155,119,1)
(42,69,1)
(9,64,1)
(99,226,1)
(195,163,1)
(59,41,1)
(247,181,1)
(238,96,1)
(91,13,1)
(240,40,1)
(1,88,1)
(153,139,1)
(219,230,1)
(86,125,1)
(160,173,1)
(80,234,1)
(161,114,1)
(248,27,1)
(84,144,1)
(215,173,1)
(61,245,1)
(195,181,1)
(230,169,1)
(39,194,1)
(152,64,1)
(19,181,1)
(142,170,1)
(139,106,1)
(38,89,1)
(129,119,1)
(159,218,1)
(174,77,1)
(3,149,1)
(99,141,1)
(207,64,1)
(121,92,1)
(99,180,1)
(10,199,1)
(224,219,1)
(69,65,1)
(94,200,1)
(89,214,1)
(176,220,1)
(134,150,1)
(133,64,1)
(154,50,1)
(176,119,1)
(22,92,1)
(137,64,1)
(118,181,1)
(173,48,1)
(230,181,1)
(30,148,1)
(73,138,1)
(163,98,1)
(247,224,1)
(32,166,1)
(204,247,1)
(148,124,1)
(232,171,1)
(11,207,1)
(145,131,1)
(4,101,1)
(43,94,1)
(246,0,1)
(108,222,1)
(100,37,1)
(217,7,1)
(19,176,1)
(29,241,1)
(69,243,1)
(249,128,1)
(23,180,1)
(66,97,1)
(173,168,1)
(221,35,1)
(152,178,1)
(225,21,1)
(201,154,1)
(227,9,1)
(198,205,1)
(177,179,1)
(213,155,1)
(191,17,1)
(72,116,1)
(79,6,1)
(151,64,1)
(179,160,1)
(206,109,1)
(211,174,1)
(50,19,1)
(219,76,1)
(192,59,1)
(162,167,1)
(104,64,1)
(132,215,1)
(223,100,1)
(118,5,1)
(136,119,1)
(111,121,1)
(1,216,1)
(214,181,1)
(116,221,1)
(172,208,1)
(59,119,1)
(124,235,1)
(115,73,1)
(244,221,1)
(90,134,1)
(133,180,1)
(44,167,1)
(109,238,1)
(220,192,1)
(115,119,1)
(239,64,1)
(67,225,1)
(27,64,1)
(234,213,1)
(134,129,1)
(144,75,1)
(109,65,1)
(117,195,1)
(0,198,1)
(126,70,1)
(92,10,1)
(141,81,1)
(158,126,1)
(166,106,1)
(49,119,1)
(5,17,1)
(103,170,1)
(229,204,1)
(196,119,1)
(77,29,1)
(241,153,1)
(41,223,1)
(91,181,1)
(13,228,1)
(116,33,1)
(136,201,1)
(86,64,1)
(122,185,1)
(188,227,1)
(168,119,1)
(158,26,1)
(47,177,1)
(150,35,1)
(149,64,1)
(36,168,1)
(57,176,1)
(243,190,1)
(75,73,1)
(182,39,1)
(236,182,1)
(9,147,1)
(70,236,1)
(142,104,1)
(1,118,1)
(104,103,1)
(97,80,1)
(17,132,1)
(195,164,1)
(249,26,1)
(239,55,1)
(157,228,1)
(187,87,1)
(231,1,1)
(50,158,1)
(99,195,1)
(130,141,1)
(150,43,1)
(51,36,1)
(48,115,1)
(19,57,1)
(147,196,1)
(27,188,1)
(106,4,1)
(222,119,1)
(235,108,1)
(67,11,1)
(149,120,1)
(216,217,1)
(98,229,1)
(126,64,1)
(233,94,1)
(63,61,1)
(232,84,1)
(116,23,1)
(151,165,1)
(139,249,1)
(158,30,1)
(245,247,1)
(121,248,1)
(179,35,1)
(219,119,1)
(139,214,1)
(171,144,1)
(246,64,1)
(21,162,1)
(88,216,1)
(168,113,1)
(18,86,1)
(141,64,1)
(118,191,1)
(140,211,1)
(203,152,1)
(158,124,1)
(210,123,1)
(222,45,1)
(100,64,1)
(23,240,1)
(193,231,1)
(198,234,1)
(207,159,1)
(113,107,1)
(73,64,1)
(64,210,1)
(62,122,1)
(128,38,1)
(155,185,1)
(228,172,1)
(200,22,1)
(205,187,1)
(37,140,1)
(49,119,2)
(80,234,2)
(167,173,2)
(155,173,2)
(109,69,2)
(241,26,2)
(168,119,2)
(73,168,2)
(171,144,2)
(126,29,2)
(121,198,2)
(198,205,2)
(99,226,2)
(162,167,2)
(90,134,2)
(158,26,2)
(89,173,2)
(139,106,2)
(42,69,2)
(24,117,2)
(111,173,2)
(155,185,2)
(63,119,2)
(216,64,2)
(185,206,2)
(139,173,2)
(45,29,2)
(5,17,2)
(11,167,2)
(9,173,2)
(198,185,2)
(213,173,2)
(221,35,2)
(208,33,2)
(87,234,2)
(142,173,2)
(176,29,2)
(187,87,2)
(48,115,2)
(114,225,2)
(176,119,2)
(147,173,2)
(157,228,2)
(32,166,2)
(29,173,2)
(249,173,2)
(101,173,2)
(39,29,2)
(44,167,2)
(136,201,2)
(158,29,2)
(193,173,2)
(182,29,2)
(133,185,2)
(123,173,2)
(66,234,2)
(158,124,2)
(245,119,2)
(59,119,2)
(119,185,2)
(86,198,2)
(172,33,2)
(7,173,2)
(11,207,2)
(190,64,2)
(106,119,2)
(87,64,2)
(118,181,2)
(133,180,2)
(211,29,2)
(232,181,2)
(125,198,2)
(29,241,2)
(210,173,2)
(241,173,2)
(214,181,2)
(55,198,2)
(113,119,2)
(247,119,2)
(88,173,2)
(167,119,2)
(188,173,2)
(200,22,2)
(18,198,2)
(143,167,2)
(1,173,2)
(0,198,2)
(184,198,2)
(152,225,2)
(127,185,2)
(220,29,2)
(19,29,2)
(126,64,2)
(163,98,2)
(139,249,2)
(73,64,2)
(215,173,2)
(192,29,2)
(96,64,2)
(19,100,2)
(19,59,2)
(115,119,2)
(43,94,2)
(23,91,2)
(219,119,2)
(99,180,2)
(155,119,2)
(203,225,2)
(100,29,2)
(95,198,2)
(203,152,2)
(138,168,2)
(100,64,2)
(159,167,2)
(108,29,2)
(104,170,2)
(165,198,2)
(246,198,2)
(141,64,2)
(120,173,2)
(115,73,2)
(116,173,2)
(93,64,2)
(238,69,2)
(244,221,2)
(185,69,2)
(47,173,2)
(239,198,2)
(99,195,2)
(130,247,2)
(166,173,2)
(69,64,2)
(27,173,2)
(164,98,2)
(149,173,2)
(206,109,2)
(236,29,2)
(213,185,2)
(117,247,2)
(103,170,2)
(121,173,2)
(207,167,2)
(104,64,2)
(234,213,2)
(195,181,2)
(95,173,2)
(216,173,2)
(247,219,2)
(154,173,2)
(86,64,2)
(222,119,2)
(36,168,2)
(76,119,2)
(227,173,2)
(59,29,2)
(210,95,2)
(205,187,2)
(246,64,2)
(158,126,2)
(205,234,2)
(30,29,2)
(161,225,2)
(133,64,2)
(177,173,2)
(70,29,2)
(226,247,2)
(204,247,2)
(4,173,2)
(224,119,2)
(195,247,2)
(202,166,2)
(230,173,2)
(169,173,2)
(119,133,2)
(243,64,2)
(214,173,2)
(234,185,2)
(21,167,2)
(173,119,2)
(40,33,2)
(38,173,2)
(206,69,2)
(156,247,2)
(19,176,2)
(21,64,2)
(57,29,2)
(136,119,2)
(179,35,2)
(112,173,2)
(48,168,2)
(118,173,2)
(248,173,2)
(1,216,2)
(228,33,2)
(175,33,2)
(187,234,2)
(99,141,2)
(51,168,2)
(128,173,2)
(109,65,2)
(72,173,2)
(218,167,2)
(115,232,2)
(194,29,2)
(141,247,2)
(91,181,2)
(225,167,2)
(225,21,2)
(198,119,2)
(153,173,2)
(97,234,2)
(187,65,2)
(139,214,2)
(148,29,2)
(198,173,2)
(231,173,2)
(240,33,2)
(77,29,2)
(33,221,2)
(123,198,2)
(234,119,2)
(96,69,2)
(37,29,2)
(106,173,2)
(198,234,2)
(22,92,2)
(50,173,2)
(81,247,2)
(174,29,2)
(109,96,2)
(229,247,2)
(134,129,2)
(213,119,2)
(207,64,2)
(99,247,2)
(122,185,2)
(239,64,2)
(179,173,2)
(158,181,2)
(170,173,2)
(69,65,2)
(196,173,2)
(124,119,2)
(151,64,2)
(140,29,2)
(201,173,2)
(61,119,2)
(23,33,2)
(178,225,2)
(235,29,2)
(27,64,2)
(91,33,2)
(98,247,2)
(196,112,2)
(67,173,2)
(19,181,2)
(149,64,2)
(237,225,2)
(9,64,2)
(249,26,2)
(232,168,2)
(144,168,2)
(217,173,2)
(213,65,2)
(46,168,2)
(62,185,2)
(84,144,2)
(17,173,2)
(210,198,2)
(92,10,2)
(233,94,2)
(41,29,2)
(247,181,2)
(152,64,2)
(82,29,2)
(150,35,2)
(139,149,2)
(132,173,2)
(1,118,2)
(115,168,2)
(33,65,2)
(20,69,2)
(226,181,2)
(151,198,2)
(191,17,2)
(64,173,2)
(3,173,2)
(129,119,2)
(160,173,2)
(221,173,2)
(107,119,2)
(23,180,2)
(95,92,2)
(52,117,2)
(234,173,2)
(230,181,2)
(64,198,2)
(124,29,2)
(13,228,2)
(1,180,2)
(185,64,2)
(196,119,2)
(74,198,2)
(129,173,2)
(222,29,2)
(64,210,2)
(219,230,2)
(111,198,2)
(75,168,2)
(223,29,2)
(136,173,2)
(158,222,2)
-----------------------------------
(0,q)
(1,ast_log(LOG_WARNING, "Failed %spausing realtime queue member %s:%s\\n", (paused ? "" : "un")
(2,)
(3,"NONE")
(4,membername)
(5,"")
(6,queue_iter)
(7,q)
(8,q)
(9,ao2_unlock(q)
(10,ao2_iterator_init(queues, 0)
(11,ast_devstate_changed(AST_DEVICE_NOT_INUSE, "Queue:%s_avail", q->name)
(12,)
(13,"UNPAUSEALL")
(14,if (mem->paused == paused)
(15,if (ast_strlen_zero(queuename)
(16,)
(17,paused)
(18,break;)
(19,manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",\n\\n\\t\\t\\t\\t\\t\\t"Queue: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Location: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"MemberName: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Paused: %d\\r\\n",\n\\n\\t\\t\\t\\t\\t\\t\\tq->name, mem->interface, mem->membername, paused)
(20,name)
(21,num_available_members(q)
(22,&queue_iter)
(23,ast_queue_log("NONE", "NONE", interface, (paused ? "PAUSEALL" : "UNPAUSEALL")
(24,"")
(25,)
(26,const char *reason)
(27,queue_t_unref(q, "Done with iterator")
(28,if (failed)
(29,!ast_strlen_zero(reason)
(30,reason)
(31,)
(32,"PAUSE")
(33,ast_strlen_zero(queuename)
(34,if (!ast_strlen_zero(queuename)
(35,found = 0)
(36,failed)
(37,name)
(38,reason)
(39,"QueueMemberPaused")
(40,"%s")
(41,interface)
(42,q)
(43,RESULT_SUCCESS)
(44,AST_DEVICE_NOT_INUSE)
(45,interface)
(46,q)
(47,1)
(48,failed = update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0")
(49,mem)
(50,mem)
(51,mem)
(52,"un")
(53,if (queue_persistent_members)
(54,)
(55,q)
(56,)
(57,paused)
(58,queue_iter)
(59,mem->interface)
(60,failed)
(61,0)
(62,q)
(63,failed = 0)
(64,q = ao2_t_iterator_next(&queue_iter, "Iterate over queues")
(65,const char *queuename)
(66,name)
(67,q)
(68,if (is_member_available(mem)
(69,ast_strlen_zero(queuename)
(70,name)
(71,mem)
(72,paused)
(73,q->name)
(74,q)
(75,"paused")
(76,paused)
(77,EVENT_FLAG_AGENT)
(78,)
(79,queues)
(80,queuename)
(81,name)
(82,mem)
(83,)
(84,"1")
(85,)
(86,queue_t_unref(q, "Done with iterator")
(87,q->name)
(88,interface)
(89,"%s")
(90,RET)
(91,paused ? "PAUSEALL" : "UNPAUSEALL")
(92,queue_iter = ao2_iterator_init(queues, 0)
(93,q)
(94,found)
(95,&queue_iter)
(96,q->name)
(97,q)
(98,paused)
(99,ast_debug(1, "%spausing already-%spaused queue member %s:%s\\n", (paused ? "" : "un")
(100,q->name)
(101,mem)
(102,if (found == 1)
(103,q)
(104,dump_queue_members(q)
(105,)
(106,mem->membername)
(107,mem)
(108,mem)
(109,strcasecmp(q->name, queuename)
(110,if (ast_strlen_zero(queuename)
(111,queue_iter)
(112,-1)
(113,realtime)
(114,AST_DEVICE_INUSE)
(115,update_realtime_member_field(mem, q->name, "paused", paused ? "1" : "0")
(116,mem)
(117,paused)
(118,paused ? "" : "un")
(119,mem = interface_exists(q, interface)
(120,name)
(121,q)
(122,mem)
(123,"Iterate over queues")
(124,mem->membername)
(125,"Done with iterator")
(126,q->name)
(127,interface)
(128,"")
(129,mem->paused)
(130,interface)
(131,found)
(132,"Failed %spausing realtime queue member %s:%s\\n")
(133,interface_exists(q, interface)
(134,return found ? RESULT_SUCCESS : RESULT_FAILURE;)
(135,if (!ast_strlen_zero(reason)
(136,ao2_ref(mem, -1)
(137,queue_iter)
(138,name)
(139,ast_queue_log(q->name, "NONE", mem->membername, (paused ? "PAUSE" : "UNPAUSE")
(140,q)
(141,q->name)
(142,mem)
(143,"Queue:%s_avail")
(144,paused)
(145,0)
(146,if (mem->realtime)
(147,q)
(148,paused)
(149,q->name)
(150,found ? RESULT_SUCCESS : RESULT_FAILURE)
(151,queue_t_unref(q, "Done with iterator")
(152,q->name)
(153,reason)
(154,1)
(155,queuename)
(156,q)
(157,"PAUSEALL")
(158,manager_event(EVENT_FLAG_AGENT, "QueueMemberPaused",\n\\n\\t\\t\\t\\t\\t\\t"Queue: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Location: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"MemberName: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Paused: %d\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Reason: %s\\r\\n",\n\\n\\t\\t\\t\\t\\t\\t\\tq->name, mem->interface, mem->membername, paused, reason)
(159,name)
(160,found)
(161,"Queue:%s_avail")
(162,q)
(163,"un")
(164,"")
(165,"Done with iterator")
(166,paused)
(167,is_member_available(mem)
(168,mem->realtime)
(169,paused)
(170,queue_persistent_members)
(171,"0")
(172,interface)
(173,failed)
(174,"QueueMemberPaused")
(175,"NONE")
(176,mem->membername)
(177,found)
(178,name)
(179,found++)
(180,const char *interface)
(181,int paused)
(182,"Queue: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Location: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"MemberName: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Paused: %d\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Reason: %s\\r\\n")
(183,while ((q = ao2_t_iterator_next(&queue_iter, "Iterate over queues")
(184,q)
(185,ast_strlen_zero(queuename)
(186,found)
(187,strcasecmp(queuename, q->name)
(188,"Done with iterator")
(189,)
(190,ao2_lock(q)
(191,"un")
(192,mem)
(193,1)
(194,EVENT_FLAG_AGENT)
(195,paused ? "" : "un")
(196,ao2_ref(mem, -1)
(197,if ((mem = interface_exists(q, interface)
(198,!ast_strlen_zero(queuename)
(199,0)
(200,ao2_iterator_destroy(&queue_iter)
(201,-1)
(202,"UNPAUSE")
(203,ast_devstate_changed(AST_DEVICE_INUSE, "Queue:%s_avail", q->name)
(204,1)
(205,!strcasecmp(queuename, q->name)
(206,!strcasecmp(q->name, queuename)
(207,q->name)
(208,"NONE")
(209,)
(210,ao2_t_iterator_next(&queue_iter, "Iterate over queues")
(211,"Queue: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Location: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"MemberName: %s\\r\\n"\n\\n\\t\\t\\t\\t\\t\\t"Paused: %d\\r\\n")
(212,)
(213,ast_strlen_zero(queuename)
(214,paused ? "PAUSE" : "UNPAUSE")
(215,LOG_WARNING)
(216,q->name)
(217,name)
(218,q)
(219,mem->paused)
(220,membername)
(221,found == 1)
(222,mem->interface)
(223,mem)
(224,paused)
(225,!num_available_members(q)
(226,paused ? "" : "un")
(227,q)
(228,paused)
(229,"%spausing already-%spaused queue member %s:%s\\n")
(230,mem->paused = paused)
(231,mem)
(232,paused ? "1" : "0")
(233,RESULT_FAILURE)
(234,!ast_strlen_zero(queuename)
(235,membername)
(236,q)
(237,q)
(238,queuename)
(239,ao2_unlock(q)
(240,"")
(241,ast_strlen_zero(reason)
(242,)
(243,queuename)
(244,queuename)
(245,failed)
(246,ao2_unlock(q)
(247,mem->paused == paused)
(248,continue;)
(249,S_OR(reason, "")
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^