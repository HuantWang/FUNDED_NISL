-----label-----
1
-----code-----
static void srp_remove_one(struct ib_device *device)
{
	struct srp_device *srp_dev;
	struct srp_host *host, *tmp_host;
	struct srp_target_port *target;

	srp_dev = ib_get_client_data(device, &srp_client);
	if (!srp_dev)
		return;

	list_for_each_entry_safe(host, tmp_host, &srp_dev->dev_list, list) {
		device_unregister(&host->dev);
		/*
		 * Wait for the sysfs entry to go away, so that no new
		 * target ports can be created.
		 */
		wait_for_completion(&host->released);

		/*
		 * Remove all target ports.
		 */
		spin_lock(&host->target_lock);
		list_for_each_entry(target, &host->target_list, list)
			srp_queue_remove_work(target);
		spin_unlock(&host->target_lock);

		/*
		 * Wait for tl_err and target port removal tasks.
		 */
		flush_workqueue(system_long_wq);
		flush_workqueue(srp_remove_wq);

		kfree(host);
	}

	if (srp_dev->fmr_pool)
		ib_destroy_fmr_pool(srp_dev->fmr_pool);
	ib_dereg_mr(srp_dev->mr);
	ib_dealloc_pd(srp_dev->pd);

	kfree(srp_dev);
}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
6,7
8,9
8,10
11,12
11,13
11,14
11,15
11,16
11,17
11,18
11,19
11,20
11,21
11,22
11,23
12,13
13,14
13,15
14,15
16,17
16,18
19,20
20,21
20,22
20,23
21,22
23,24
23,25
26,27
26,28
29,30
30,31
30,32
31,32
33,34
33,35
36,37
37,38
37,39
38,39
40,41
40,42
40,43
41,42
43,44
45,46
46,47
48,49
48,50
49,50
50,51
53,54
54,55
54,56
54,57
54,58
54,59
55,56
57,58
59,60
61,62
62,63
62,64
63,64
66,67
68,69
69,70
69,71
69,72
69,73
69,74
69,75
69,76
69,77
69,78
69,79
70,71
71,72
71,73
72,73
74,75
75,76
75,77
76,77
79,80
80,81
80,82
81,82
83,84
84,85
84,86
85,86
88,89
89,90
89,91
90,91
92,93
93,94
93,95
94,95
97,98
98,99
98,100
98,101
98,102
99,100
101,102
103,104
104,105
104,106
105,106
108,109
110,111
111,112
112,113
112,114
113,114
115,116
117,118
118,119
118,120
119,120
121,122
122,123
122,124
123,124
126,127
127,128
127,129
128,129
130,131
131,132
133,134
134,135
134,136
135,136
137,138
138,139
140,141
141,142
141,143
142,143
144,145
146,147
146,148
147,148
147,149
148,149
151,152
152,153
152,154
153,154
155,156
155,157
156,157
159,160
160,161
160,162
161,162
163,164
163,165
164,165
167,168
168,169
168,170
169,170
171,172
171,173
172,173
175,176
176,177
176,178
177,178
179,180
-----nextToken-----
2,4,7,9,10,15,17,18,22,24,25,27,28,32,34,35,39,42,44,47,51,52,56,58,60,64,65,67,73,77,78,82,86,87,91,95,96,100,102,106,107,109,114,116,120,124,125,129,132,136,139,143,145,149,150,154,157,158,162,165,166,170,173,174,178,180
-----computeFrom-----
37,38
37,39
-----guardedBy-----
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;Declarator;Pointer;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;UnaryExpression;IdExpression;Name;ReturnStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ProblemStatement;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ProblemStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IfStatement;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
static void srp_remove_one(struct ib_device *device){	struct srp_device *srp_dev;	struct srp_host *host, *tmp_host;	struct srp_target_port *target;	srp_dev = ib_get_client_data(device, &srp_client);	if (!srp_dev)		return;	list_for_each_entry_safe(host, tmp_host, &srp_dev->dev_list, list) {		device_unregister(&host->dev);		/*		 * Wait for the sysfs entry to go away, so that no new		 * target ports can be created.		 */		wait_for_completion(&host->released);		/*		 * Remove all target ports.		 */		spin_lock(&host->target_lock);		list_for_each_entry(target, &host->target_list, list)			srp_queue_remove_work(target);		spin_unlock(&host->target_lock);		/*		 * Wait for tl_err and target port removal tasks.		 */		flush_workqueue(system_long_wq);		flush_workqueue(srp_remove_wq);		kfree(host);	}	if (srp_dev->fmr_pool)		ib_destroy_fmr_pool(srp_dev->fmr_pool);	ib_dereg_mr(srp_dev->mr);	ib_dealloc_pd(srp_dev->pd);	kfree(srp_dev);}
static void
srp_remove_one(struct ib_device *device)
srp_remove_one
struct ib_device *device
struct ib_device
ib_device
*device
*
device
{	struct srp_device *srp_dev;	struct srp_host *host, *tmp_host;	struct srp_target_port *target;	srp_dev = ib_get_client_data(device, &srp_client);	if (!srp_dev)		return;	list_for_each_entry_safe(host, tmp_host, &srp_dev->dev_list, list) {		device_unregister(&host->dev);		/*		 * Wait for the sysfs entry to go away, so that no new		 * target ports can be created.		 */		wait_for_completion(&host->released);		/*		 * Remove all target ports.		 */		spin_lock(&host->target_lock);		list_for_each_entry(target, &host->target_list, list)			srp_queue_remove_work(target);		spin_unlock(&host->target_lock);		/*		 * Wait for tl_err and target port removal tasks.		 */		flush_workqueue(system_long_wq);		flush_workqueue(srp_remove_wq);		kfree(host);	}	if (srp_dev->fmr_pool)		ib_destroy_fmr_pool(srp_dev->fmr_pool);	ib_dereg_mr(srp_dev->mr);	ib_dealloc_pd(srp_dev->pd);	kfree(srp_dev);}
struct srp_device *srp_dev;
struct srp_device *srp_dev;
struct srp_device
srp_device
*srp_dev
*
srp_dev
struct srp_host *host, *tmp_host;
struct srp_host *host, *tmp_host;
struct srp_host
srp_host
*host
*
host
*tmp_host
*
tmp_host
struct srp_target_port *target;
struct srp_target_port *target;
struct srp_target_port
srp_target_port
*target
*
target
srp_dev = ib_get_client_data(device, &srp_client);
srp_dev = ib_get_client_data(device, &srp_client)
srp_dev
srp_dev
ib_get_client_data(device, &srp_client)
ib_get_client_data
ib_get_client_data
device
device
&srp_client
srp_client
srp_client
if (!srp_dev)		return;
!srp_dev
srp_dev
srp_dev
return;
list_for_each_entry_safe(host, tmp_host, &srp_dev->dev_list, list)
list_for_each_entry_safe(host, tmp_host, &srp_dev->dev_list, list)
list_for_each_entry_safe
list_for_each_entry_safe
host
host
tmp_host
tmp_host
&srp_dev->dev_list
srp_dev->dev_list
srp_dev
srp_dev
dev_list
list
list
)
{		device_unregister(&host->dev);		/*		 * Wait for the sysfs entry to go away, so that no new		 * target ports can be created.		 */		wait_for_completion(&host->released);		/*		 * Remove all target ports.		 */		spin_lock(&host->target_lock);		list_for_each_entry(target, &host->target_list, list)			srp_queue_remove_work(target);		spin_unlock(&host->target_lock);		/*		 * Wait for tl_err and target port removal tasks.		 */		flush_workqueue(system_long_wq);		flush_workqueue(srp_remove_wq);		kfree(host);	}
device_unregister(&host->dev);
device_unregister(&host->dev)
device_unregister
device_unregister
&host->dev
host->dev
host
host
dev
wait_for_completion(&host->released);
wait_for_completion(&host->released)
wait_for_completion
wait_for_completion
&host->released
host->released
host
host
released
spin_lock(&host->target_lock);
spin_lock(&host->target_lock)
spin_lock
spin_lock
&host->target_lock
host->target_lock
host
host
target_lock
list_for_each_entry(target, &host->target_list, list)
list_for_each_entry(target, &host->target_list, list)
list_for_each_entry
list_for_each_entry
target
target
&host->target_list
host->target_list
host
host
target_list
list
list
)
srp_queue_remove_work(target);
srp_queue_remove_work(target)
srp_queue_remove_work
srp_queue_remove_work
target
target
spin_unlock(&host->target_lock);
spin_unlock(&host->target_lock)
spin_unlock
spin_unlock
&host->target_lock
host->target_lock
host
host
target_lock
flush_workqueue(system_long_wq);
flush_workqueue(system_long_wq);
flush_workqueue
flush_workqueue
(system_long_wq)
system_long_wq
system_long_wq
flush_workqueue(srp_remove_wq);
flush_workqueue(srp_remove_wq);
flush_workqueue
flush_workqueue
(srp_remove_wq)
srp_remove_wq
srp_remove_wq
kfree(host);
kfree(host)
kfree
kfree
host
host
if (srp_dev->fmr_pool)		ib_destroy_fmr_pool(srp_dev->fmr_pool);
srp_dev->fmr_pool
srp_dev
srp_dev
fmr_pool
ib_destroy_fmr_pool(srp_dev->fmr_pool);
ib_destroy_fmr_pool(srp_dev->fmr_pool)
ib_destroy_fmr_pool
ib_destroy_fmr_pool
srp_dev->fmr_pool
srp_dev
srp_dev
fmr_pool
ib_dereg_mr(srp_dev->mr);
ib_dereg_mr(srp_dev->mr)
ib_dereg_mr
ib_dereg_mr
srp_dev->mr
srp_dev
srp_dev
mr
ib_dealloc_pd(srp_dev->pd);
ib_dealloc_pd(srp_dev->pd)
ib_dealloc_pd
ib_dealloc_pd
srp_dev->pd
srp_dev
srp_dev
pd
kfree(srp_dev);
kfree(srp_dev)
kfree
kfree
srp_dev
srp_dev
-----joern-----
(19,36,0)
(15,44,0)
(35,54,0)
(51,43,0)
(42,36,0)
(40,18,0)
(15,36,0)
(53,10,0)
(60,21,0)
(54,36,0)
(10,54,0)
(62,54,0)
(58,36,0)
(34,31,0)
(17,29,0)
(17,41,0)
(24,3,0)
(55,48,0)
(63,44,0)
(5,62,0)
(2,30,0)
(14,38,0)
(33,12,0)
(27,29,0)
(54,60,0)
(16,30,0)
(7,6,0)
(22,32,0)
(57,13,0)
(60,13,0)
(39,36,0)
(12,29,0)
(44,15,0)
(35,36,0)
(11,16,0)
(0,23,0)
(61,36,0)
(29,36,0)
(46,6,0)
(30,2,0)
(9,16,0)
(25,6,0)
(47,18,0)
(4,44,0)
(2,29,0)
(3,38,0)
(37,23,0)
(41,18,0)
(20,35,0)
(38,3,0)
(26,27,0)
(56,36,0)
(49,60,0)
(8,1,0)
(18,41,0)
(13,60,0)
(24,29,0)
(41,17,0)
(52,10,0)
(7,36,0)
(6,7,0)
(30,16,0)
(32,29,0)
(44,54,0)
(6,54,0)
(8,23,0)
(50,10,0)
(10,50,0)
(60,54,0)
(31,29,0)
(3,24,0)
(43,54,0)
(1,8,0)
(28,62,0)
(23,8,0)
(45,54,0)
(59,38,0)
(1,29,0)
(22,31,1)
(62,54,1)
(27,26,1)
(46,50,1)
(52,53,1)
(38,59,1)
(25,46,1)
(24,3,1)
(47,27,1)
(30,16,1)
(6,25,1)
(44,63,1)
(6,54,1)
(0,24,1)
(5,32,1)
(37,0,1)
(14,2,1)
(31,34,1)
(33,17,1)
(51,54,1)
(40,47,1)
(43,51,1)
(48,43,1)
(35,20,1)
(63,4,1)
(49,45,1)
(55,35,1)
(57,49,1)
(35,54,1)
(59,14,1)
(28,5,1)
(60,21,1)
(32,22,1)
(18,40,1)
(20,15,1)
(12,33,1)
(4,7,1)
(34,12,1)
(16,11,1)
(44,54,1)
(9,43,1)
(2,30,1)
(10,52,1)
(3,38,1)
(15,44,1)
(46,62,1)
(7,6,1)
(1,8,1)
(62,28,1)
(26,1,1)
(53,62,1)
(55,48,1)
(17,41,1)
(8,23,1)
(41,18,1)
(10,54,1)
(11,9,1)
(43,54,1)
(60,13,1)
(54,60,1)
(23,37,1)
(50,10,1)
(13,57,1)
(52,62,2)
(3,43,2)
(31,43,2)
(1,43,2)
(63,43,2)
(9,43,2)
(18,43,2)
(6,54,2)
(10,54,2)
(62,43,2)
(35,43,2)
(50,10,2)
(11,43,2)
(30,43,2)
(41,43,2)
(22,43,2)
(43,54,2)
(46,43,2)
(14,43,2)
(48,43,2)
(27,43,2)
(17,43,2)
(59,43,2)
(37,43,2)
(4,43,2)
(44,54,2)
(26,43,2)
(2,43,2)
(28,43,2)
(41,18,2)
(10,62,2)
(8,23,2)
(15,43,2)
(40,43,2)
(62,54,2)
(33,43,2)
(6,43,2)
(5,43,2)
(47,43,2)
(34,43,2)
(32,43,2)
(60,13,2)
(16,43,2)
(60,21,2)
(24,3,2)
(50,62,2)
(38,43,2)
(0,43,2)
(30,16,2)
(3,38,2)
(20,43,2)
(35,54,2)
(1,8,2)
(12,43,2)
(7,6,2)
(2,30,2)
(54,60,2)
(44,43,2)
(55,48,2)
(23,43,2)
(17,41,2)
(8,43,2)
(7,43,2)
(53,62,2)
(15,44,2)
(24,43,2)
(25,43,2)
-----------------------------------
(0,host)
(1,spin_lock(&host->target_lock)
(2,device_unregister(&host->dev)
(3,&host->released)
(4,srp_dev)
(5,srp_dev)
(6,srp_dev->mr)
(7,ib_dereg_mr(srp_dev->mr)
(8,&host->target_lock)
(9,host)
(10,srp_dev->fmr_pool)
(11,dev)
(12,flush_workqueue(system_long_wq)
(13,&srp_client)
(14,host)
(15,ib_dealloc_pd(srp_dev->pd)
(16,host->dev)
(17,spin_unlock(&host->target_lock)
(18,host->target_lock)
(19,host)
(20,srp_dev)
(21,struct ib_device *device)
(22,host)
(23,host->target_lock)
(24,wait_for_completion(&host->released)
(25,mr)
(26,target)
(27,srp_queue_remove_work(target)
(28,fmr_pool)
(29,)
(30,&host->dev)
(31,flush_workqueue(srp_remove_wq)
(32,kfree(host)
(33,system_long_wq)
(34,srp_remove_wq)
(35,kfree(srp_dev)
(36,)
(37,target_lock)
(38,host->released)
(39,tmp_host)
(40,target_lock)
(41,&host->target_lock)
(42,if (!srp_dev)
(43,!srp_dev)
(44,srp_dev->pd)
(45,srp_dev)
(46,srp_dev)
(47,host)
(48,return;)
(49,device)
(50,ib_destroy_fmr_pool(srp_dev->fmr_pool)
(51,srp_dev)
(52,fmr_pool)
(53,srp_dev)
(54,srp_dev = ib_get_client_data(device, &srp_client)
(55,RET)
(56,srp_dev)
(57,srp_client)
(58,target)
(59,released)
(60,ib_get_client_data(device, &srp_client)
(61,if (srp_dev->fmr_pool)
(62,srp_dev->fmr_pool)
(63,pd)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^