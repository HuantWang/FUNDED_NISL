-----label-----
0
-----code-----
static void backupPathInThread(NiBackup *ni, char *name, int source, int destDir)
{
    if (ni->threads == 1) {
        /* we don't need no stinkin' threads! */
        int bpfd = backupPath(ni, name, source, destDir);
        close(bpfd);
        free(name);
        close(source);
        close(destDir);

    } else {
        int ti;
        BackupPathArgs *bpa = malloc(sizeof(BackupPathArgs));
        if (!bpa) {
            /* FIXME */
            close(source);
            close(destDir);
            return;
        }

        bpa->ni = ni;
        bpa->name = name;
        bpa->source = source;
        bpa->destDir = destDir;

        /* wait until a thread is free */
        sem_wait(&ni->bsem);

        /* and start it */
        for (ti = 0; ti < ni->threads; ti++) {
            pthread_mutex_lock(&ni->blocks[ti]);
            if (!ni->brunning[ti]) {
                /* not running, take it */
                ni->brunning[ti] = 1;
                bpa->ti = ti;
                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);
                pthread_mutex_unlock(&ni->blocks[ti]);
                break;
            }
            pthread_mutex_unlock(&ni->blocks[ti]);
        }

        if (ti == ni->threads) {
            /* FIXME: this should never happen */
            free(bpa);
            free(name);
            close(source);
            close(destDir);
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
3,8
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
13,15
16,17
16,18
18,19
20,21
20,22
22,23
24,25
25,26
25,27
25,28
26,27
26,28
27,28
27,29
28,29
32,33
32,34
32,35
32,36
32,37
33,34
34,35
34,36
36,37
36,38
38,39
39,40
39,41
39,42
39,43
39,44
40,41
42,43
44,45
46,47
48,49
50,51
51,52
51,53
52,53
54,55
56,57
57,58
57,59
58,59
60,61
62,63
63,64
63,65
64,65
66,67
68,69
69,70
69,71
70,71
72,73
74,75
74,76
74,77
74,78
74,79
74,80
74,81
74,82
74,83
74,84
75,76
76,77
76,78
78,79
80,81
81,82
81,83
82,83
84,85
84,86
84,87
87,88
88,89
88,90
89,90
91,92
92,93
92,94
93,94
96,97
96,98
97,98
98,99
100,101
100,102
100,103
101,102
102,103
102,104
103,104
105,106
107,108
108,109
108,110
109,110
111,112
114,115
115,116
115,117
116,117
116,118
117,118
120,121
122,123
123,124
123,125
124,125
124,126
125,126
128,129
130,131
131,132
131,133
132,133
132,134
133,134
136,137
138,139
139,140
139,141
140,141
140,142
141,142
144,145
146,147
147,148
147,149
148,149
150,151
151,152
151,153
152,153
155,156
155,157
155,158
155,159
156,157
157,158
157,159
158,159
161,162
161,163
162,163
164,165
164,166
165,166
168,169
169,170
171,172
171,173
171,174
172,173
173,174
173,175
174,175
176,177
177,178
177,179
178,179
178,180
179,180
182,183
184,185
184,186
185,186
186,187
186,188
187,188
187,189
188,189
191,192
193,194
193,195
193,196
193,197
193,198
194,195
195,196
195,197
196,197
196,198
197,198
197,199
198,199
201,202
204,205
205,206
205,207
206,207
206,208
207,208
210,211
212,213
213,214
213,215
213,216
213,217
213,218
214,215
216,217
217,218
217,219
218,219
218,220
219,220
222,223
224,225
226,227
228,229
230,231
231,232
231,233
232,233
234,235
235,236
235,237
236,237
236,238
237,238
240,241
243,244
244,245
244,246
245,246
247,248
248,249
248,250
249,250
249,251
250,251
253,254
255,256
255,257
256,257
256,258
257,258
259,260
259,261
260,261
263,264
263,265
263,266
263,267
264,265
265,266
265,267
266,267
268,269
270,271
271,272
271,273
272,273
274,275
276,277
277,278
277,279
278,279
280,281
282,283
283,284
283,285
284,285
286,287
-----nextToken-----
2,4,7,9,10,12,14,15,17,19,21,23,29,30,31,35,37,41,43,45,47,49,53,55,59,61,65,67,71,73,77,79,83,85,86,90,94,95,99,104,106,110,112,113,118,119,121,126,127,129,134,135,137,142,143,145,149,153,154,159,160,163,166,167,170,175,180,181,183,189,190,192,199,200,202,203,208,209,211,215,220,221,223,225,227,229,233,238,239,241,242,246,251,252,254,258,261,262,267,269,273,275,279,281,285,287
-----computeFrom-----
26,27
26,28
115,116
115,117
123,124
123,125
131,132
131,133
139,140
139,141
157,158
157,159
161,162
161,163
195,196
195,197
205,206
205,207
256,257
256,258
-----guardedBy-----
29,43
-----guardedByNegation-----
30,262
29,261
-----lastLexicalUse-----
29,261
-----jump-----
29,261
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;FunctionCallExpression;IdExpression;Name;TypeIdExpression;TypeId;NamedTypeSpecifier;Name;Declarator;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;FieldReference;IdExpression;Name;Name;ForStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;UnaryExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;ArraySubscriptExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IfStatement;BinaryExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;
-----ast_node-----
static void backupPathInThread(NiBackup *ni, char *name, int source, int destDir){    if (ni->threads == 1) {        /* we don't need no stinkin' threads! */        int bpfd = backupPath(ni, name, source, destDir);        close(bpfd);        free(name);        close(source);        close(destDir);    } else {        int ti;        BackupPathArgs *bpa = malloc(sizeof(BackupPathArgs));        if (!bpa) {            /* FIXME */            close(source);            close(destDir);            return;        }        bpa->ni = ni;        bpa->name = name;        bpa->source = source;        bpa->destDir = destDir;        /* wait until a thread is free */        sem_wait(&ni->bsem);        /* and start it */        for (ti = 0; ti < ni->threads; ti++) {            pthread_mutex_lock(&ni->blocks[ti]);            if (!ni->brunning[ti]) {                /* not running, take it */                ni->brunning[ti] = 1;                bpa->ti = ti;                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);                pthread_mutex_unlock(&ni->blocks[ti]);                break;            }            pthread_mutex_unlock(&ni->blocks[ti]);        }        if (ti == ni->threads) {            /* FIXME: this should never happen */            free(bpa);            free(name);            close(source);            close(destDir);        }    }}
static void
backupPathInThread(NiBackup *ni, char *name, int source, int destDir)
backupPathInThread
NiBackup *ni
NiBackup
NiBackup
*ni
*
ni
char *name
char
*name
*
name
int source
int
source
source
int destDir
int
destDir
destDir
{    if (ni->threads == 1) {        /* we don't need no stinkin' threads! */        int bpfd = backupPath(ni, name, source, destDir);        close(bpfd);        free(name);        close(source);        close(destDir);    } else {        int ti;        BackupPathArgs *bpa = malloc(sizeof(BackupPathArgs));        if (!bpa) {            /* FIXME */            close(source);            close(destDir);            return;        }        bpa->ni = ni;        bpa->name = name;        bpa->source = source;        bpa->destDir = destDir;        /* wait until a thread is free */        sem_wait(&ni->bsem);        /* and start it */        for (ti = 0; ti < ni->threads; ti++) {            pthread_mutex_lock(&ni->blocks[ti]);            if (!ni->brunning[ti]) {                /* not running, take it */                ni->brunning[ti] = 1;                bpa->ti = ti;                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);                pthread_mutex_unlock(&ni->blocks[ti]);                break;            }            pthread_mutex_unlock(&ni->blocks[ti]);        }        if (ti == ni->threads) {            /* FIXME: this should never happen */            free(bpa);            free(name);            close(source);            close(destDir);        }    }}
if (ni->threads == 1) {        /* we don't need no stinkin' threads! */        int bpfd = backupPath(ni, name, source, destDir);        close(bpfd);        free(name);        close(source);        close(destDir);    } else {        int ti;        BackupPathArgs *bpa = malloc(sizeof(BackupPathArgs));        if (!bpa) {            /* FIXME */            close(source);            close(destDir);            return;        }        bpa->ni = ni;        bpa->name = name;        bpa->source = source;        bpa->destDir = destDir;        /* wait until a thread is free */        sem_wait(&ni->bsem);        /* and start it */        for (ti = 0; ti < ni->threads; ti++) {            pthread_mutex_lock(&ni->blocks[ti]);            if (!ni->brunning[ti]) {                /* not running, take it */                ni->brunning[ti] = 1;                bpa->ti = ti;                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);                pthread_mutex_unlock(&ni->blocks[ti]);                break;            }            pthread_mutex_unlock(&ni->blocks[ti]);        }        if (ti == ni->threads) {            /* FIXME: this should never happen */            free(bpa);            free(name);            close(source);            close(destDir);        }    }
ni->threads == 1
ni->threads
ni
ni
threads
1
{        /* we don't need no stinkin' threads! */        int bpfd = backupPath(ni, name, source, destDir);        close(bpfd);        free(name);        close(source);        close(destDir);    }
int bpfd = backupPath(ni, name, source, destDir);
int bpfd = backupPath(ni, name, source, destDir);
int
bpfd = backupPath(ni, name, source, destDir)
bpfd
= backupPath(ni, name, source, destDir)
backupPath(ni, name, source, destDir)
backupPath
backupPath
ni
ni
name
name
source
source
destDir
destDir
close(bpfd);
close(bpfd)
close
close
bpfd
bpfd
free(name);
free(name)
free
free
name
name
close(source);
close(source)
close
close
source
source
close(destDir);
close(destDir)
close
close
destDir
destDir
{        int ti;        BackupPathArgs *bpa = malloc(sizeof(BackupPathArgs));        if (!bpa) {            /* FIXME */            close(source);            close(destDir);            return;        }        bpa->ni = ni;        bpa->name = name;        bpa->source = source;        bpa->destDir = destDir;        /* wait until a thread is free */        sem_wait(&ni->bsem);        /* and start it */        for (ti = 0; ti < ni->threads; ti++) {            pthread_mutex_lock(&ni->blocks[ti]);            if (!ni->brunning[ti]) {                /* not running, take it */                ni->brunning[ti] = 1;                bpa->ti = ti;                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);                pthread_mutex_unlock(&ni->blocks[ti]);                break;            }            pthread_mutex_unlock(&ni->blocks[ti]);        }        if (ti == ni->threads) {            /* FIXME: this should never happen */            free(bpa);            free(name);            close(source);            close(destDir);        }    }
int ti;
int ti;
int
ti
ti
BackupPathArgs *bpa = malloc(sizeof(BackupPathArgs));
BackupPathArgs *bpa = malloc(sizeof(BackupPathArgs));
BackupPathArgs
BackupPathArgs
*bpa = malloc(sizeof(BackupPathArgs))
*
bpa
= malloc(sizeof(BackupPathArgs))
malloc(sizeof(BackupPathArgs))
malloc
malloc
sizeof(BackupPathArgs)
BackupPathArgs
BackupPathArgs
BackupPathArgs

if (!bpa) {            /* FIXME */            close(source);            close(destDir);            return;        }
!bpa
bpa
bpa
{            /* FIXME */            close(source);            close(destDir);            return;        }
close(source);
close(source)
close
close
source
source
close(destDir);
close(destDir)
close
close
destDir
destDir
return;
bpa->ni = ni;
bpa->ni = ni
bpa->ni
bpa
bpa
ni
ni
ni
bpa->name = name;
bpa->name = name
bpa->name
bpa
bpa
name
name
name
bpa->source = source;
bpa->source = source
bpa->source
bpa
bpa
source
source
source
bpa->destDir = destDir;
bpa->destDir = destDir
bpa->destDir
bpa
bpa
destDir
destDir
destDir
sem_wait(&ni->bsem);
sem_wait(&ni->bsem)
sem_wait
sem_wait
&ni->bsem
ni->bsem
ni
ni
bsem
for (ti = 0; ti < ni->threads; ti++) {            pthread_mutex_lock(&ni->blocks[ti]);            if (!ni->brunning[ti]) {                /* not running, take it */                ni->brunning[ti] = 1;                bpa->ti = ti;                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);                pthread_mutex_unlock(&ni->blocks[ti]);                break;            }            pthread_mutex_unlock(&ni->blocks[ti]);        }
ti = 0;
ti = 0
ti
ti
0
ti < ni->threads
ti
ti
ni->threads
ni
ni
threads
ti++
ti
ti
{            pthread_mutex_lock(&ni->blocks[ti]);            if (!ni->brunning[ti]) {                /* not running, take it */                ni->brunning[ti] = 1;                bpa->ti = ti;                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);                pthread_mutex_unlock(&ni->blocks[ti]);                break;            }            pthread_mutex_unlock(&ni->blocks[ti]);        }
pthread_mutex_lock(&ni->blocks[ti]);
pthread_mutex_lock(&ni->blocks[ti])
pthread_mutex_lock
pthread_mutex_lock
&ni->blocks[ti]
ni->blocks[ti]
ni->blocks
ni
ni
blocks
ti
ti
if (!ni->brunning[ti]) {                /* not running, take it */                ni->brunning[ti] = 1;                bpa->ti = ti;                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);                pthread_mutex_unlock(&ni->blocks[ti]);                break;            }
!ni->brunning[ti]
ni->brunning[ti]
ni->brunning
ni
ni
brunning
ti
ti
{                /* not running, take it */                ni->brunning[ti] = 1;                bpa->ti = ti;                pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);                pthread_mutex_unlock(&ni->blocks[ti]);                break;            }
ni->brunning[ti] = 1;
ni->brunning[ti] = 1
ni->brunning[ti]
ni->brunning
ni
ni
brunning
ti
ti
1
bpa->ti = ti;
bpa->ti = ti
bpa->ti
bpa
bpa
ti
ti
ti
pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa);
pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa)
pthread_create
pthread_create
&ni->bth[ti]
ni->bth[ti]
ni->bth
ni
ni
bth
ti
ti
NULL
NULL
backupPathTh
backupPathTh
bpa
bpa
pthread_mutex_unlock(&ni->blocks[ti]);
pthread_mutex_unlock(&ni->blocks[ti])
pthread_mutex_unlock
pthread_mutex_unlock
&ni->blocks[ti]
ni->blocks[ti]
ni->blocks
ni
ni
blocks
ti
ti
break;
pthread_mutex_unlock(&ni->blocks[ti]);
pthread_mutex_unlock(&ni->blocks[ti])
pthread_mutex_unlock
pthread_mutex_unlock
&ni->blocks[ti]
ni->blocks[ti]
ni->blocks
ni
ni
blocks
ti
ti
if (ti == ni->threads) {            /* FIXME: this should never happen */            free(bpa);            free(name);            close(source);            close(destDir);        }
ti == ni->threads
ti
ti
ni->threads
ni
ni
threads
{            /* FIXME: this should never happen */            free(bpa);            free(name);            close(source);            close(destDir);        }
free(bpa);
free(bpa)
free
free
bpa
bpa
free(name);
free(name)
free
free
name
name
close(source);
close(source)
close
close
source
source
close(destDir);
close(destDir)
close
close
destDir
destDir
-----joern-----
(28,64,0)
(20,77,0)
(144,76,0)
(99,58,0)
(113,11,0)
(138,42,0)
(43,117,0)
(121,20,0)
(127,75,0)
(45,52,0)
(61,63,0)
(112,65,0)
(141,49,0)
(87,74,0)
(57,106,0)
(15,126,0)
(69,127,0)
(80,82,0)
(61,38,0)
(53,126,0)
(103,38,0)
(74,87,0)
(76,64,0)
(146,135,0)
(68,48,0)
(120,145,0)
(85,82,0)
(84,75,0)
(26,64,0)
(17,105,0)
(23,128,0)
(135,23,0)
(9,41,0)
(63,61,0)
(114,86,0)
(40,41,0)
(25,100,0)
(22,61,0)
(40,86,0)
(140,100,0)
(52,45,0)
(114,109,0)
(94,74,0)
(44,16,0)
(14,37,0)
(48,128,0)
(125,137,0)
(78,145,0)
(136,121,0)
(98,140,0)
(72,20,0)
(39,126,0)
(134,58,0)
(129,1,0)
(39,59,0)
(126,38,0)
(119,105,0)
(2,75,0)
(91,21,0)
(34,40,0)
(88,59,0)
(111,41,0)
(96,116,0)
(88,105,0)
(63,124,0)
(142,111,0)
(104,128,0)
(140,42,0)
(119,28,0)
(6,74,0)
(148,79,0)
(67,76,0)
(106,109,0)
(60,129,0)
(29,72,0)
(118,103,0)
(124,75,0)
(76,38,0)
(137,84,0)
(145,38,0)
(108,56,0)
(50,140,0)
(139,39,0)
(133,137,0)
(11,128,0)
(145,78,0)
(64,128,0)
(23,117,0)
(37,83,0)
(0,84,0)
(116,87,0)
(143,128,0)
(111,20,0)
(116,96,0)
(79,38,0)
(107,9,0)
(37,20,0)
(21,103,0)
(11,43,0)
(42,140,0)
(92,75,0)
(4,20,0)
(58,99,0)
(24,129,0)
(80,109,0)
(11,65,0)
(62,61,0)
(45,128,0)
(58,38,0)
(30,35,0)
(104,79,0)
(106,100,0)
(3,82,0)
(78,83,0)
(83,78,0)
(90,85,0)
(37,117,0)
(64,28,0)
(56,45,0)
(59,39,0)
(66,37,0)
(87,116,0)
(140,82,0)
(64,76,0)
(21,128,0)
(74,38,0)
(54,128,0)
(71,75,0)
(46,72,0)
(8,3,0)
(47,75,0)
(25,7,0)
(129,20,0)
(135,20,0)
(36,114,0)
(16,20,0)
(31,56,0)
(19,75,0)
(9,100,0)
(89,25,0)
(51,95,0)
(10,140,0)
(131,42,0)
(102,23,0)
(83,37,0)
(140,86,0)
(77,20,0)
(127,100,0)
(124,63,0)
(93,79,0)
(18,103,0)
(5,43,0)
(96,117,0)
(149,58,0)
(16,35,0)
(72,127,0)
(1,75,0)
(95,7,0)
(55,12,0)
(140,38,0)
(12,77,0)
(35,38,0)
(65,11,0)
(130,140,0)
(81,104,0)
(122,1,0)
(28,119,0)
(77,12,0)
(13,109,0)
(3,7,0)
(85,41,0)
(33,138,0)
(87,128,0)
(39,128,0)
(138,109,0)
(1,82,0)
(137,20,0)
(79,104,0)
(27,145,0)
(20,75,0)
(123,87,0)
(101,16,0)
(115,37,0)
(32,135,0)
(78,128,0)
(65,38,0)
(126,39,0)
(110,78,0)
(84,86,0)
(45,56,0)
(35,75,0)
(42,109,0)
(59,88,0)
(147,45,0)
(97,65,0)
(132,99,0)
(73,80,0)
(70,117,0)
(103,21,0)
(56,38,0)
(145,38,1)
(126,53,1)
(136,20,1)
(114,36,1)
(74,38,1)
(145,27,1)
(58,38,1)
(76,38,1)
(119,28,1)
(83,78,1)
(80,82,1)
(40,86,1)
(58,134,1)
(140,82,1)
(25,89,1)
(35,30,1)
(78,128,1)
(9,107,1)
(52,45,1)
(51,104,1)
(125,133,1)
(29,46,1)
(23,102,1)
(78,145,1)
(15,21,1)
(79,148,1)
(122,129,1)
(81,21,1)
(5,11,1)
(63,61,1)
(87,74,1)
(77,12,1)
(80,73,1)
(113,65,1)
(20,77,1)
(123,74,1)
(70,96,1)
(140,10,1)
(39,128,1)
(76,67,1)
(99,132,1)
(126,38,1)
(72,29,1)
(60,127,1)
(96,116,1)
(36,138,1)
(48,128,1)
(120,23,1)
(64,76,1)
(45,128,1)
(33,42,1)
(139,126,1)
(48,68,1)
(56,38,1)
(8,25,1)
(110,145,1)
(3,82,1)
(129,24,1)
(89,121,1)
(137,125,1)
(34,111,1)
(146,32,1)
(103,38,1)
(97,112,1)
(31,88,1)
(84,0,1)
(55,4,1)
(121,136,1)
(42,140,1)
(137,20,1)
(37,66,1)
(72,20,1)
(56,108,1)
(135,146,1)
(43,5,1)
(0,137,1)
(130,98,1)
(115,83,1)
(114,86,1)
(9,100,1)
(104,79,1)
(138,33,1)
(1,82,1)
(104,128,1)
(64,128,1)
(61,22,1)
(39,126,1)
(61,38,1)
(98,131,1)
(10,50,1)
(53,15,1)
(25,100,1)
(37,83,1)
(51,85,1)
(131,99,1)
(51,95,1)
(112,52,1)
(111,20,1)
(129,20,1)
(27,120,1)
(39,139,1)
(16,20,1)
(144,52,1)
(32,43,1)
(65,38,1)
(57,114,1)
(93,81,1)
(94,6,1)
(148,93,1)
(59,39,1)
(111,142,1)
(11,128,1)
(11,113,1)
(87,123,1)
(1,122,1)
(95,3,1)
(30,16,1)
(135,20,1)
(4,99,1)
(26,76,1)
(124,63,1)
(50,130,1)
(108,31,1)
(134,149,1)
(37,20,1)
(68,119,1)
(64,26,1)
(46,84,1)
(143,54,1)
(28,64,1)
(90,9,1)
(116,87,1)
(91,48,1)
(6,37,1)
(18,118,1)
(14,115,1)
(66,14,1)
(69,72,1)
(51,80,1)
(127,69,1)
(118,91,1)
(22,62,1)
(142,104,1)
(107,40,1)
(35,38,1)
(85,90,1)
(65,97,1)
(106,57,1)
(140,38,1)
(103,18,1)
(78,110,1)
(62,1,1)
(74,94,1)
(127,100,1)
(138,42,1)
(23,128,1)
(87,128,1)
(44,101,1)
(101,121,1)
(11,65,1)
(85,82,1)
(45,56,1)
(12,55,1)
(99,58,1)
(54,124,1)
(147,56,1)
(121,20,1)
(102,135,1)
(21,128,1)
(21,103,1)
(81,70,1)
(24,60,1)
(140,86,1)
(73,106,1)
(40,34,1)
(106,100,1)
(140,100,1)
(128,143,1)
(133,35,1)
(88,59,1)
(132,58,1)
(45,147,1)
(67,144,1)
(84,86,1)
(79,38,1)
(16,44,1)
(3,8,1)
(91,128,1)
(142,104,2)
(45,21,2)
(139,21,2)
(11,52,2)
(23,52,2)
(102,52,2)
(33,99,2)
(112,52,2)
(6,52,2)
(104,79,2)
(37,20,2)
(89,121,2)
(129,121,2)
(91,121,2)
(67,52,2)
(111,104,2)
(77,99,2)
(138,99,2)
(61,38,2)
(140,100,2)
(104,121,2)
(103,52,2)
(48,52,2)
(145,52,2)
(72,121,2)
(20,99,2)
(137,121,2)
(32,52,2)
(20,77,2)
(74,52,2)
(147,21,2)
(54,121,2)
(70,52,2)
(22,121,2)
(96,116,2)
(78,52,2)
(1,121,2)
(148,121,2)
(87,128,2)
(44,121,2)
(4,99,2)
(65,38,2)
(94,52,2)
(16,20,2)
(121,99,2)
(63,121,2)
(95,121,2)
(1,82,2)
(98,99,2)
(40,86,2)
(39,128,2)
(21,52,2)
(45,56,2)
(66,52,2)
(111,20,2)
(90,104,2)
(143,121,2)
(110,52,2)
(56,38,2)
(116,87,2)
(137,20,2)
(79,121,2)
(52,21,2)
(42,99,2)
(57,99,2)
(14,52,2)
(87,52,2)
(96,52,2)
(130,99,2)
(68,52,2)
(107,104,2)
(56,21,2)
(58,38,2)
(37,83,2)
(118,52,2)
(119,28,2)
(72,20,2)
(15,21,2)
(35,38,2)
(36,99,2)
(114,99,2)
(144,52,2)
(79,38,2)
(21,128,2)
(76,38,2)
(27,52,2)
(65,52,2)
(39,126,2)
(12,99,2)
(25,121,2)
(10,99,2)
(16,121,2)
(146,52,2)
(83,52,2)
(37,52,2)
(24,121,2)
(21,121,2)
(64,128,2)
(135,20,2)
(122,121,2)
(43,52,2)
(140,86,2)
(138,42,2)
(136,99,2)
(18,121,2)
(60,121,2)
(81,121,2)
(145,38,2)
(69,121,2)
(124,121,2)
(84,121,2)
(120,52,2)
(140,38,2)
(18,52,2)
(133,121,2)
(80,82,2)
(26,52,2)
(91,52,2)
(106,99,2)
(3,121,2)
(104,128,2)
(21,103,2)
(85,104,2)
(125,121,2)
(42,140,2)
(113,52,2)
(62,121,2)
(63,61,2)
(131,99,2)
(25,100,2)
(85,82,2)
(135,52,2)
(52,45,2)
(99,58,2)
(9,104,2)
(9,100,2)
(127,121,2)
(119,52,2)
(61,121,2)
(39,21,2)
(108,21,2)
(87,74,2)
(50,99,2)
(59,39,2)
(140,99,2)
(127,100,2)
(115,52,2)
(64,76,2)
(23,128,2)
(128,121,2)
(88,21,2)
(97,52,2)
(88,59,2)
(80,99,2)
(29,121,2)
(103,38,2)
(114,86,2)
(123,52,2)
(34,104,2)
(28,52,2)
(74,38,2)
(129,20,2)
(3,82,2)
(40,104,2)
(35,121,2)
(126,38,2)
(0,121,2)
(116,52,2)
(55,99,2)
(124,63,2)
(121,20,2)
(126,21,2)
(46,121,2)
(140,82,2)
(8,121,2)
(28,64,2)
(45,128,2)
(93,121,2)
(11,128,2)
(73,99,2)
(77,12,2)
(59,21,2)
(103,121,2)
(78,128,2)
(48,128,2)
(64,52,2)
(78,145,2)
(106,100,2)
(5,52,2)
(51,95,2)
(84,86,2)
(83,78,2)
(11,65,2)
(76,52,2)
(101,121,2)
(118,121,2)
(53,21,2)
(30,121,2)
(31,21,2)
-----------------------------------
(0,name)
(1,bpa->destDir = destDir)
(2,for (ti = 0; ti < ni->threads; ti++)
(3,close(destDir)
(4,bpa)
(5,1)
(6,ni)
(7,)
(8,destDir)
(9,close(source)
(10,destDir)
(11,ni->brunning[ti])
(12,sizeof(BackupPathArgs)
(13,bpfd)
(14,backupPathTh)
(15,ni)
(16,bpa->ni)
(17,if (!ni->brunning[ti])
(18,threads)
(19,bpa)
(20,*bpa = malloc(sizeof(BackupPathArgs)
(21,ti < ni->threads)
(22,bsem)
(23,bpa->ti = ti)
(24,destDir)
(25,close(source)
(26,ti)
(27,bth)
(28,&ni->blocks[ti])
(29,source)
(30,ni)
(31,ni)
(32,bpa)
(33,bpfd)
(34,name)
(35,bpa->ni = ni)
(36,name)
(37,pthread_create(&ni->bth[ti], NULL, backupPathTh, bpa)
(38,NiBackup *ni)
(39,ni->blocks[ti])
(40,free(name)
(41,)
(42,bpfd = backupPath(ni, name, source, destDir)
(43,ni->brunning[ti] = 1)
(44,ni)
(45,ni->brunning[ti])
(46,bpa)
(47,ti)
(48,ti++)
(49,)
(50,source)
(51,RET)
(52,!ni->brunning[ti])
(53,blocks)
(54,ti)
(55,BackupPathArgs)
(56,ni->brunning)
(57,source)
(58,ni->threads)
(59,&ni->blocks[ti])
(60,bpa)
(61,ni->bsem)
(62,ni)
(63,&ni->bsem)
(64,ni->blocks[ti])
(65,ni->brunning)
(66,bpa)
(67,blocks)
(68,ti)
(69,source)
(70,break;)
(71,if (ti == ni->threads)
(72,bpa->source)
(73,destDir)
(74,ni->blocks)
(75,)
(76,ni->blocks)
(77,malloc(sizeof(BackupPathArgs)
(78,ni->bth[ti])
(79,ni->threads)
(80,close(destDir)
(81,ti)
(82,int destDir)
(83,&ni->bth[ti])
(84,bpa->name = name)
(85,close(destDir)
(86,char *name)
(87,ni->blocks[ti])
(88,pthread_mutex_lock(&ni->blocks[ti])
(89,source)
(90,destDir)
(91,ti)
(92,if (!bpa)
(93,ni)
(94,blocks)
(95,return;)
(96,pthread_mutex_unlock(&ni->blocks[ti])
(97,brunning)
(98,ni)
(99,ni->threads == 1)
(100,int source)
(101,bpa)
(102,ti)
(103,ni->threads)
(104,ti == ni->threads)
(105,)
(106,close(source)
(107,source)
(108,brunning)
(109,)
(110,ti)
(111,free(bpa)
(112,ni)
(113,ti)
(114,free(name)
(115,NULL)
(116,&ni->blocks[ti])
(117,)
(118,ni)
(119,pthread_mutex_unlock(&ni->blocks[ti])
(120,ni)
(121,!bpa)
(122,destDir)
(123,ti)
(124,sem_wait(&ni->bsem)
(125,name)
(126,ni->blocks)
(127,bpa->source = source)
(128,ti = 0)
(129,bpa->destDir)
(130,name)
(131,bpfd)
(132,1)
(133,bpa)
(134,threads)
(135,bpa->ti)
(136,bpa)
(137,bpa->name)
(138,close(bpfd)
(139,ti)
(140,backupPath(ni, name, source, destDir)
(141,if (ni->threads == 1)
(142,bpa)
(143,0)
(144,ni)
(145,ni->bth)
(146,ti)
(147,ti)
(148,threads)
(149,ni)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^