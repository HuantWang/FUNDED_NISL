-----label-----
0
-----code-----
static int commit_ref_update(struct ref_lock *lock,
			     const unsigned char *sha1, const char *logmsg)
{
	clear_loose_ref_cache(&ref_cache);
	if (log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0 ||
	    (strcmp(lock->ref_name, lock->orig_ref_name) &&
	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)) {
		unlock_ref(lock);
		return -1;
	}
	if (strcmp(lock->orig_ref_name, "HEAD") != 0) {
		/*
		 * Special hack: If a branch is updated directly and HEAD
		 * points to it (may happen on the remote side of a push
		 * for example) then logically the HEAD reflog should be
		 * updated too.
		 * A generic solution implies reverse symref information,
		 * but finding all symrefs pointing to the given branch
		 * would be rather costly for this rare event (the direct
		 * update of a branch) to be worth it.  So let's cheat and
		 * check with HEAD only which should cover 99% of all usage
		 * scenarios (even 100% of the default ones).
		 */
		unsigned char head_sha1[20];
		int head_flag;
		const char *head_ref;
		head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,
					      head_sha1, &head_flag);
		if (head_ref && (head_flag & REF_ISSYMREF) &&
		    !strcmp(head_ref, lock->ref_name))
			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);
	}
	if (commit_ref(lock)) {
		error("Couldn't set %s", lock->ref_name);
		unlock_ref(lock);
		return -1;
	}
	unlock_ref(lock);
	return 0;
}
-----children-----
1,2
1,3
1,4
3,4
3,5
3,6
3,7
5,6
5,7
6,7
8,9
8,10
11,12
11,13
13,14
13,15
16,17
16,18
18,19
18,20
21,22
21,23
21,24
21,25
21,26
21,27
22,23
23,24
23,25
24,25
26,27
27,28
27,29
30,31
30,32
31,32
31,33
32,33
32,34
33,34
33,35
33,36
33,37
33,38
34,35
36,37
36,38
37,38
40,41
40,42
41,42
44,45
46,47
49,50
50,51
50,52
51,52
51,53
51,54
52,53
54,55
54,56
55,56
58,59
58,60
59,60
62,63
62,64
63,64
63,65
63,66
63,67
63,68
64,65
66,67
66,68
67,68
70,71
70,72
71,72
74,75
76,77
79,80
79,81
80,81
81,82
81,83
82,83
84,85
86,87
87,88
89,90
89,91
90,91
90,92
91,92
91,93
91,94
92,93
94,95
94,96
95,96
100,101
100,102
100,103
100,104
100,105
101,102
102,103
102,104
104,105
104,106
106,107
108,109
109,110
109,111
111,112
113,114
114,115
114,116
116,117
116,118
119,120
120,121
120,122
121,122
123,124
123,125
123,126
123,127
123,128
124,125
127,128
129,130
131,132
132,133
134,135
134,136
135,136
135,137
136,137
136,138
137,138
139,140
140,141
140,142
141,142
143,144
145,146
146,147
146,148
146,149
147,148
149,150
151,152
151,153
152,153
155,156
156,157
156,158
156,159
156,160
156,161
157,158
160,161
160,162
161,162
164,165
166,167
168,169
168,170
169,170
169,171
170,171
172,173
174,175
174,176
174,177
175,176
176,177
176,178
176,179
177,178
180,181
180,182
181,182
184,185
185,186
185,187
186,187
188,189
190,191
191,192
193,194
194,195
194,196
195,196
197,198
199,200
-----nextToken-----
2,4,7,9,10,12,14,15,17,19,20,25,28,29,35,38,39,42,43,45,47,48,53,56,57,60,61,65,68,69,72,73,75,77,78,83,85,88,93,96,97,98,99,103,105,107,110,112,115,117,118,122,125,126,128,130,133,138,142,144,148,150,153,154,158,159,162,163,165,167,171,173,178,179,182,183,187,189,192,196,198,200
-----computeFrom-----
31,32
31,33
32,33
32,34
50,51
50,52
62,63
62,64
90,91
90,92
120,121
120,122
135,136
135,137
136,137
136,138
140,141
140,142
-----guardedBy-----
72,85
93,148
96,162
153,162
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;ReferenceOperator;Name;IfStatement;BinaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;UnaryExpression;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;LiteralExpression;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;LiteralExpression;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Name;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;LiteralExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;UnaryExpression;BinaryExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;IdExpression;Name;IfStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ReturnStatement;LiteralExpression;
-----ast_node-----
static int commit_ref_update(struct ref_lock *lock,			     const unsigned char *sha1, const char *logmsg){	clear_loose_ref_cache(&ref_cache);	if (log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0 ||	    (strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)) {		unlock_ref(lock);		return -1;	}	if (strcmp(lock->orig_ref_name, "HEAD") != 0) {		/*		 * Special hack: If a branch is updated directly and HEAD		 * points to it (may happen on the remote side of a push		 * for example) then logically the HEAD reflog should be		 * updated too.		 * A generic solution implies reverse symref information,		 * but finding all symrefs pointing to the given branch		 * would be rather costly for this rare event (the direct		 * update of a branch) to be worth it.  So let's cheat and		 * check with HEAD only which should cover 99% of all usage		 * scenarios (even 100% of the default ones).		 */		unsigned char head_sha1[20];		int head_flag;		const char *head_ref;		head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag);		if (head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name))			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);	}	if (commit_ref(lock)) {		error("Couldn't set %s", lock->ref_name);		unlock_ref(lock);		return -1;	}	unlock_ref(lock);	return 0;}
static int
commit_ref_update(struct ref_lock *lock,			     const unsigned char *sha1, const char *logmsg)
commit_ref_update
struct ref_lock *lock
struct ref_lock
ref_lock
*lock
*
lock
const unsigned char *sha1
const unsigned char
*sha1
*
sha1
const char *logmsg
const char
*logmsg
*
logmsg
{	clear_loose_ref_cache(&ref_cache);	if (log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0 ||	    (strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)) {		unlock_ref(lock);		return -1;	}	if (strcmp(lock->orig_ref_name, "HEAD") != 0) {		/*		 * Special hack: If a branch is updated directly and HEAD		 * points to it (may happen on the remote side of a push		 * for example) then logically the HEAD reflog should be		 * updated too.		 * A generic solution implies reverse symref information,		 * but finding all symrefs pointing to the given branch		 * would be rather costly for this rare event (the direct		 * update of a branch) to be worth it.  So let's cheat and		 * check with HEAD only which should cover 99% of all usage		 * scenarios (even 100% of the default ones).		 */		unsigned char head_sha1[20];		int head_flag;		const char *head_ref;		head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag);		if (head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name))			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);	}	if (commit_ref(lock)) {		error("Couldn't set %s", lock->ref_name);		unlock_ref(lock);		return -1;	}	unlock_ref(lock);	return 0;}
clear_loose_ref_cache(&ref_cache);
clear_loose_ref_cache(&ref_cache);
clear_loose_ref_cache
clear_loose_ref_cache
(&ref_cache)
&ref_cache
&
ref_cache
if (log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0 ||	    (strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)) {		unlock_ref(lock);		return -1;	}
log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0 ||	    (strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)
log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg) < 0
log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg)
log_ref_write
log_ref_write
lock->ref_name
lock
lock
ref_name
lock->old_sha1
lock
lock
old_sha1
sha1
sha1
logmsg
logmsg
0
(strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0)
strcmp(lock->ref_name, lock->orig_ref_name) &&	     log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0
strcmp(lock->ref_name, lock->orig_ref_name)
strcmp
strcmp
lock->ref_name
lock
lock
ref_name
lock->orig_ref_name
lock
lock
orig_ref_name
log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg) < 0
log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg)
log_ref_write
log_ref_write
lock->orig_ref_name
lock
lock
orig_ref_name
lock->old_sha1
lock
lock
old_sha1
sha1
sha1
logmsg
logmsg
0
{		unlock_ref(lock);		return -1;	}
unlock_ref(lock);
unlock_ref(lock)
unlock_ref
unlock_ref
lock
lock
return -1;
-1
1
if (strcmp(lock->orig_ref_name, "HEAD") != 0) {		/*		 * Special hack: If a branch is updated directly and HEAD		 * points to it (may happen on the remote side of a push		 * for example) then logically the HEAD reflog should be		 * updated too.		 * A generic solution implies reverse symref information,		 * but finding all symrefs pointing to the given branch		 * would be rather costly for this rare event (the direct		 * update of a branch) to be worth it.  So let's cheat and		 * check with HEAD only which should cover 99% of all usage		 * scenarios (even 100% of the default ones).		 */		unsigned char head_sha1[20];		int head_flag;		const char *head_ref;		head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag);		if (head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name))			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);	}
strcmp(lock->orig_ref_name, "HEAD") != 0
strcmp(lock->orig_ref_name, "HEAD")
strcmp
strcmp
lock->orig_ref_name
lock
lock
orig_ref_name
"HEAD"
0
{		/*		 * Special hack: If a branch is updated directly and HEAD		 * points to it (may happen on the remote side of a push		 * for example) then logically the HEAD reflog should be		 * updated too.		 * A generic solution implies reverse symref information,		 * but finding all symrefs pointing to the given branch		 * would be rather costly for this rare event (the direct		 * update of a branch) to be worth it.  So let's cheat and		 * check with HEAD only which should cover 99% of all usage		 * scenarios (even 100% of the default ones).		 */		unsigned char head_sha1[20];		int head_flag;		const char *head_ref;		head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag);		if (head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name))			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);	}
unsigned char head_sha1[20];
unsigned char head_sha1[20];
unsigned char
head_sha1[20]
head_sha1
[20]
20
int head_flag;
int head_flag;
int
head_flag
head_flag
const char *head_ref;
const char *head_ref;
const char
*head_ref
*
head_ref
head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag);
head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag)
head_ref
head_ref
resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,					      head_sha1, &head_flag)
resolve_ref_unsafe
resolve_ref_unsafe
"HEAD"
RESOLVE_REF_READING
RESOLVE_REF_READING
head_sha1
head_sha1
&head_flag
head_flag
head_flag
if (head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name))			log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);
head_ref && (head_flag & REF_ISSYMREF) &&		    !strcmp(head_ref, lock->ref_name)
head_ref && (head_flag & REF_ISSYMREF)
head_ref
head_ref
(head_flag & REF_ISSYMREF)
head_flag & REF_ISSYMREF
head_flag
head_flag
REF_ISSYMREF
REF_ISSYMREF
!strcmp(head_ref, lock->ref_name)
strcmp(head_ref, lock->ref_name)
strcmp
strcmp
head_ref
head_ref
lock->ref_name
lock
lock
ref_name
log_ref_write("HEAD", lock->old_sha1, sha1, logmsg);
log_ref_write("HEAD", lock->old_sha1, sha1, logmsg)
log_ref_write
log_ref_write
"HEAD"
lock->old_sha1
lock
lock
old_sha1
sha1
sha1
logmsg
logmsg
if (commit_ref(lock)) {		error("Couldn't set %s", lock->ref_name);		unlock_ref(lock);		return -1;	}
commit_ref(lock)
commit_ref
commit_ref
lock
lock
{		error("Couldn't set %s", lock->ref_name);		unlock_ref(lock);		return -1;	}
error("Couldn't set %s", lock->ref_name);
error("Couldn't set %s", lock->ref_name)
error
error
"Couldn't set %s"
lock->ref_name
lock
lock
ref_name
unlock_ref(lock);
unlock_ref(lock)
unlock_ref
unlock_ref
lock
lock
return -1;
-1
1
unlock_ref(lock);
unlock_ref(lock)
unlock_ref
unlock_ref
lock
lock
return 0;
0
-----joern-----
(76,25,0)
(20,47,0)
(60,5,0)
(24,80,0)
(94,52,0)
(62,18,0)
(46,69,0)
(0,25,0)
(64,33,0)
(102,7,0)
(87,78,0)
(50,8,0)
(13,80,0)
(75,94,0)
(46,47,0)
(93,101,0)
(36,8,0)
(56,92,0)
(40,2,0)
(52,21,0)
(52,12,0)
(52,8,0)
(60,78,0)
(100,46,0)
(31,98,0)
(21,78,0)
(35,78,0)
(53,78,0)
(46,88,0)
(101,87,0)
(46,48,0)
(5,10,0)
(44,67,0)
(57,43,0)
(28,2,0)
(15,59,0)
(26,88,0)
(55,74,0)
(6,88,0)
(87,101,0)
(7,102,0)
(103,98,0)
(8,78,0)
(99,78,0)
(82,48,0)
(65,16,0)
(32,87,0)
(81,60,0)
(101,69,0)
(16,91,0)
(95,31,0)
(71,0,0)
(11,80,0)
(21,52,0)
(18,34,0)
(70,26,0)
(79,21,0)
(33,55,0)
(63,35,0)
(80,11,0)
(19,21,0)
(70,94,0)
(73,65,0)
(10,5,0)
(86,17,0)
(8,52,0)
(15,27,0)
(9,2,0)
(49,48,0)
(68,101,0)
(84,102,0)
(16,65,0)
(46,12,0)
(51,34,0)
(11,35,0)
(11,70,0)
(25,0,0)
(23,53,0)
(54,2,0)
(41,91,0)
(31,78,0)
(80,78,0)
(98,74,0)
(72,43,0)
(77,22,0)
(15,55,0)
(47,46,0)
(3,52,0)
(48,46,0)
(22,78,0)
(5,60,0)
(7,10,0)
(34,78,0)
(92,27,0)
(10,7,0)
(67,18,0)
(7,72,0)
(42,72,0)
(43,25,0)
(4,5,0)
(17,37,0)
(52,69,0)
(88,26,0)
(59,91,0)
(1,52,0)
(72,7,0)
(22,91,0)
(43,2,0)
(27,37,0)
(97,46,0)
(101,12,0)
(39,25,0)
(14,59,0)
(90,34,0)
(48,78,0)
(18,67,0)
(25,43,0)
(85,25,0)
(5,43,0)
(83,47,0)
(38,87,0)
(88,46,0)
(96,91,0)
(58,35,0)
(29,31,0)
(98,31,0)
(52,94,0)
(66,99,0)
(89,91,0)
(70,11,0)
(61,101,0)
(99,74,0)
(47,78,0)
(34,18,0)
(35,11,0)
(45,102,0)
(30,60,0)
(94,70,0)
(26,70,0)
(17,78,0)
(64,99,1)
(98,31,1)
(22,78,1)
(67,44,1)
(43,25,1)
(46,100,1)
(67,18,1)
(56,17,1)
(102,45,1)
(46,69,1)
(99,66,1)
(59,14,1)
(25,0,1)
(71,85,1)
(66,98,1)
(50,11,1)
(52,8,1)
(15,55,1)
(20,83,1)
(19,79,1)
(65,73,1)
(7,10,1)
(49,16,1)
(87,32,1)
(45,84,1)
(13,35,1)
(57,67,1)
(60,78,1)
(33,64,1)
(55,33,1)
(14,22,1)
(52,69,1)
(97,47,1)
(83,48,1)
(103,53,1)
(26,88,1)
(21,19,1)
(101,87,1)
(46,12,1)
(52,21,1)
(70,94,1)
(34,90,1)
(0,71,1)
(95,29,1)
(46,47,1)
(72,42,1)
(3,21,1)
(62,34,1)
(79,8,1)
(22,77,1)
(53,78,1)
(63,88,1)
(92,56,1)
(72,7,1)
(101,69,1)
(61,72,1)
(5,43,1)
(68,93,1)
(35,78,1)
(27,92,1)
(36,50,1)
(93,87,1)
(94,75,1)
(60,81,1)
(47,78,1)
(48,78,1)
(51,26,1)
(80,24,1)
(94,52,1)
(8,78,1)
(7,102,1)
(39,76,1)
(90,51,1)
(15,27,1)
(47,20,1)
(88,6,1)
(81,30,1)
(101,12,1)
(44,18,1)
(17,78,1)
(100,97,1)
(42,43,1)
(99,78,1)
(34,78,1)
(15,59,1)
(11,80,1)
(24,13,1)
(26,70,1)
(11,35,1)
(8,36,1)
(5,60,1)
(30,4,1)
(4,102,1)
(46,48,1)
(84,42,1)
(31,78,1)
(88,46,1)
(16,65,1)
(35,58,1)
(23,72,1)
(75,52,1)
(58,63,1)
(18,34,1)
(1,3,1)
(29,103,1)
(38,61,1)
(87,78,1)
(32,38,1)
(86,26,1)
(17,86,1)
(77,53,1)
(85,39,1)
(52,12,1)
(70,11,1)
(21,78,1)
(18,62,1)
(23,67,1)
(52,1,1)
(72,43,1)
(10,5,1)
(31,95,1)
(48,82,1)
(82,49,1)
(6,46,1)
(101,68,1)
(23,101,1)
(53,23,1)
(80,78,1)
(76,57,1)
(62,26,2)
(72,67,2)
(42,67,2)
(103,53,2)
(11,80,2)
(3,11,2)
(79,11,2)
(59,53,2)
(58,88,2)
(70,94,2)
(8,78,2)
(22,53,2)
(10,5,2)
(56,26,2)
(87,78,2)
(15,55,2)
(88,46,2)
(27,26,2)
(25,0,2)
(101,69,2)
(26,88,2)
(95,53,2)
(35,88,2)
(55,53,2)
(71,67,2)
(5,60,2)
(67,18,2)
(84,42,2)
(93,72,2)
(64,53,2)
(5,43,2)
(63,88,2)
(1,11,2)
(34,26,2)
(72,7,2)
(16,65,2)
(17,26,2)
(14,53,2)
(47,78,2)
(33,53,2)
(4,102,2)
(15,27,2)
(29,53,2)
(102,42,2)
(11,88,2)
(53,26,2)
(43,67,2)
(46,48,2)
(75,11,2)
(60,102,2)
(101,72,2)
(99,78,2)
(7,102,2)
(68,72,2)
(23,26,2)
(99,53,2)
(52,69,2)
(36,11,2)
(60,78,2)
(31,53,2)
(8,11,2)
(87,72,2)
(92,26,2)
(76,67,2)
(46,12,2)
(46,47,2)
(67,26,2)
(61,72,2)
(98,31,2)
(24,88,2)
(46,69,2)
(94,11,2)
(80,88,2)
(51,26,2)
(94,52,2)
(17,78,2)
(80,78,2)
(90,26,2)
(18,26,2)
(22,78,2)
(19,11,2)
(39,67,2)
(70,88,2)
(15,59,2)
(52,11,2)
(13,88,2)
(21,78,2)
(25,67,2)
(21,11,2)
(44,26,2)
(0,67,2)
(98,53,2)
(52,12,2)
(101,87,2)
(52,8,2)
(77,53,2)
(81,102,2)
(26,70,2)
(43,25,2)
(7,10,2)
(86,26,2)
(32,72,2)
(66,53,2)
(11,35,2)
(10,102,2)
(38,72,2)
(5,102,2)
(7,42,2)
(101,12,2)
(35,78,2)
(70,11,2)
(57,67,2)
(72,43,2)
(48,78,2)
(31,78,2)
(50,11,2)
(85,67,2)
(53,78,2)
(18,34,2)
(52,21,2)
(45,42,2)
(34,78,2)
(30,102,2)
-----------------------------------
(0,&head_flag)
(1,logmsg)
(2,)
(3,sha1)
(4,head_ref)
(5,strcmp(head_ref, lock->ref_name)
(6,0)
(7,(head_flag & REF_ISSYMREF)
(8,lock->orig_ref_name)
(9,if (head_ref && (head_flag & REF_ISSYMREF)
(10,!strcmp(head_ref, lock->ref_name)
(11,strcmp(lock->ref_name, lock->orig_ref_name)
(12,const unsigned char *sha1)
(13,lock)
(14,0)
(15,RET)
(16,clear_loose_ref_cache(&ref_cache)
(17,unlock_ref(lock)
(18,strcmp(lock->orig_ref_name, "HEAD")
(19,old_sha1)
(20,old_sha1)
(21,lock->old_sha1)
(22,unlock_ref(lock)
(23,lock)
(24,orig_ref_name)
(25,resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,\n\\n\\t\\t\\t\\t\\t      head_sha1, &head_flag)
(26,log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg)
(27,return -1;)
(28,head_flag)
(29,lock)
(30,lock)
(31,lock->ref_name)
(32,old_sha1)
(33,-1)
(34,lock->orig_ref_name)
(35,lock->ref_name)
(36,orig_ref_name)
(37,)
(38,lock)
(39,RESOLVE_REF_READING)
(40,head_ref)
(41,if (log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg)
(42,head_ref)
(43,head_ref = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,\n\\n\\t\\t\\t\\t\\t      head_sha1, &head_flag)
(44,0)
(45,REF_ISSYMREF)
(46,log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg)
(47,lock->old_sha1)
(48,lock->ref_name)
(49,lock)
(50,lock)
(51,lock)
(52,log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg)
(53,commit_ref(lock)
(54,head_sha1)
(55,return -1;)
(56,1)
(57,head_ref)
(58,ref_name)
(59,return 0;)
(60,lock->ref_name)
(61,"HEAD")
(62,"HEAD")
(63,lock)
(64,1)
(65,&ref_cache)
(66,lock)
(67,strcmp(lock->orig_ref_name, "HEAD")
(68,logmsg)
(69,const char *logmsg)
(70,strcmp(lock->ref_name, lock->orig_ref_name)
(71,head_flag)
(72,head_ref && (head_flag & REF_ISSYMREF)
(73,ref_cache)
(74,)
(75,0)
(76,"HEAD")
(77,lock)
(78,struct ref_lock *lock)
(79,lock)
(80,lock->orig_ref_name)
(81,ref_name)
(82,ref_name)
(83,lock)
(84,head_flag)
(85,head_sha1)
(86,lock)
(87,lock->old_sha1)
(88,log_ref_write(lock->ref_name, lock->old_sha1, sha1, logmsg)
(89,if (commit_ref(lock)
(90,orig_ref_name)
(91,)
(92,-1)
(93,sha1)
(94,log_ref_write(lock->orig_ref_name, lock->old_sha1, sha1, logmsg)
(95,ref_name)
(96,if (strcmp(lock->orig_ref_name, "HEAD")
(97,sha1)
(98,error("Couldn\'t set %s", lock->ref_name)
(99,unlock_ref(lock)
(100,logmsg)
(101,log_ref_write("HEAD", lock->old_sha1, sha1, logmsg)
(102,head_flag & REF_ISSYMREF)
(103,"Couldn\'t set %s")
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^