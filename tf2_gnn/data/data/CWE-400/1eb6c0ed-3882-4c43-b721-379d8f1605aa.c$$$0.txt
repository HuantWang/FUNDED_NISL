-----label-----
0
-----code-----
static void goodB2G()
{
    size_t data;
    size_t *dataPtr1 = &data;
    size_t *dataPtr2 = &data;
    /* Initialize data */
    data = 0;
    {
        size_t data = *dataPtr1;
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = "";
            /* POTENTIAL FLAW: Read data from the console using fgets() */
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                /* Convert to unsigned int */
                data = strtoul(inputBuffer, NULL, 0);
            }
            else
            {
                printLine("fgets() failed.");
            }
        }
        *dataPtr1 = data;
    }
    {
        size_t data = *dataPtr2;
        {
            wchar_t * myString;
            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough
             * for the wcscpy() function to not cause a buffer overflow */
            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */
            if (data > wcslen(HELLO_STRING) && data < 100)
            {
                myString = (wchar_t *)malloc(data*sizeof(wchar_t));
                if (myString == NULL) {exit(-1);}
                /* Copy a small string into myString */
                wcscpy(myString, HELLO_STRING);
                printWLine(myString);
                free(myString);
            }
            else
            {
                printLine("Input is less than the length of the source string or too large");
            }
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
5,10
5,11
6,7
7,8
7,9
8,9
10,11
12,13
13,14
13,15
14,15
16,17
16,18
16,19
19,20
20,21
21,22
23,24
24,25
24,26
25,26
27,28
27,29
27,30
30,31
31,32
32,33
34,35
35,36
35,37
36,37
39,40
39,41
39,42
40,41
41,42
41,43
42,43
44,45
44,46
46,47
47,48
48,49
50,51
50,52
51,52
52,53
52,54
54,55
54,56
54,57
56,57
57,58
59,60
61,62
61,63
61,64
62,63
62,64
63,64
63,65
63,66
63,67
64,65
66,67
68,69
70,71
72,73
74,75
75,76
76,77
76,78
77,78
79,80
79,81
79,82
79,83
80,81
82,83
84,85
87,88
88,89
89,90
89,91
90,91
93,94
94,95
94,96
95,96
96,97
98,99
100,101
100,102
101,102
102,103
102,104
103,104
105,106
105,107
107,108
108,109
109,110
111,112
111,113
112,113
113,114
113,115
115,116
115,117
118,119
118,120
118,121
119,120
119,121
120,121
120,122
121,122
123,124
123,125
124,125
126,127
128,129
128,130
129,130
132,133
132,134
132,135
132,136
132,137
133,134
134,135
134,136
135,136
137,138
137,139
138,139
138,140
140,141
142,143
142,144
143,144
145,146
145,147
146,147
148,149
149,150
149,151
152,153
152,154
153,154
153,155
154,155
156,157
158,159
159,160
160,161
160,162
161,162
163,164
165,166
166,167
166,168
166,169
167,168
169,170
171,172
173,174
174,175
174,176
175,176
177,178
179,180
180,181
180,182
181,182
183,184
185,186
186,187
187,188
187,189
188,189
-----nextToken-----
2,4,9,11,15,17,18,22,26,28,29,33,37,38,43,45,49,53,55,58,60,65,67,69,71,73,78,81,83,85,86,91,92,97,99,104,106,110,114,116,117,122,125,127,130,131,136,139,141,144,147,150,151,155,157,162,164,168,170,172,176,178,182,184,189,190
-----computeFrom-----
35,36
35,37
62,63
62,64
76,77
76,78
94,95
94,96
119,120
119,121
120,121
120,122
128,129
128,130
134,135
134,136
145,146
145,147
153,154
153,155
-----guardedBy-----
67,83
73,85
127,172
130,147
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Pointer;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;ArrayDeclarator;Name;ArrayModifier;IdExpression;Name;EqualsInitializer;LiteralExpression;IfStatement;BinaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;ExpressionStatement;BinaryExpression;UnaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;EqualsInitializer;UnaryExpression;IdExpression;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;
-----ast_node-----
static void goodB2G(){    size_t data;    size_t *dataPtr1 = &data;    size_t *dataPtr2 = &data;    /* Initialize data */    data = 0;    {        size_t data = *dataPtr1;        {            char inputBuffer[CHAR_ARRAY_SIZE] = "";            /* POTENTIAL FLAW: Read data from the console using fgets() */            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)            {                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }            else            {                printLine("fgets() failed.");            }        }        *dataPtr1 = data;    }    {        size_t data = *dataPtr2;        {            wchar_t * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }}
static void
goodB2G()
goodB2G
{    size_t data;    size_t *dataPtr1 = &data;    size_t *dataPtr2 = &data;    /* Initialize data */    data = 0;    {        size_t data = *dataPtr1;        {            char inputBuffer[CHAR_ARRAY_SIZE] = "";            /* POTENTIAL FLAW: Read data from the console using fgets() */            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)            {                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }            else            {                printLine("fgets() failed.");            }        }        *dataPtr1 = data;    }    {        size_t data = *dataPtr2;        {            wchar_t * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }}
size_t data;
size_t data;
size_t
size_t
data
data
size_t *dataPtr1 = &data;
size_t *dataPtr1 = &data;
size_t
size_t
*dataPtr1 = &data
*
dataPtr1
= &data
&data
data
data
size_t *dataPtr2 = &data;
size_t *dataPtr2 = &data;
size_t
size_t
*dataPtr2 = &data
*
dataPtr2
= &data
&data
data
data
data = 0;
data = 0
data
data
0
{        size_t data = *dataPtr1;        {            char inputBuffer[CHAR_ARRAY_SIZE] = "";            /* POTENTIAL FLAW: Read data from the console using fgets() */            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)            {                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }            else            {                printLine("fgets() failed.");            }        }        *dataPtr1 = data;    }
size_t data = *dataPtr1;
size_t data = *dataPtr1;
size_t
size_t
data = *dataPtr1
data
= *dataPtr1
*dataPtr1
dataPtr1
dataPtr1
{            char inputBuffer[CHAR_ARRAY_SIZE] = "";            /* POTENTIAL FLAW: Read data from the console using fgets() */            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)            {                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }            else            {                printLine("fgets() failed.");            }        }
char inputBuffer[CHAR_ARRAY_SIZE] = "";
char inputBuffer[CHAR_ARRAY_SIZE] = "";
char
inputBuffer[CHAR_ARRAY_SIZE] = ""
inputBuffer
[CHAR_ARRAY_SIZE]
CHAR_ARRAY_SIZE
CHAR_ARRAY_SIZE
= ""
""
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)            {                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }            else            {                printLine("fgets() failed.");            }
fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL
fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
fgets
fgets
inputBuffer
inputBuffer
CHAR_ARRAY_SIZE
CHAR_ARRAY_SIZE
stdin
stdin
NULL
NULL
{                /* Convert to unsigned int */                data = strtoul(inputBuffer, NULL, 0);            }
data = strtoul(inputBuffer, NULL, 0);
data = strtoul(inputBuffer, NULL, 0)
data
data
strtoul(inputBuffer, NULL, 0)
strtoul
strtoul
inputBuffer
inputBuffer
NULL
NULL
0
{                printLine("fgets() failed.");            }
printLine("fgets() failed.");
printLine("fgets() failed.")
printLine
printLine
"fgets() failed."
*dataPtr1 = data;
*dataPtr1 = data
*dataPtr1
dataPtr1
dataPtr1
data
data
{        size_t data = *dataPtr2;        {            wchar_t * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }
size_t data = *dataPtr2;
size_t data = *dataPtr2;
size_t
size_t
data = *dataPtr2
data
= *dataPtr2
*dataPtr2
dataPtr2
dataPtr2
{            wchar_t * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }
wchar_t * myString;
wchar_t * myString;
wchar_t
* myString
*
myString
if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }
data > wcslen(HELLO_STRING) && data < 100
data > wcslen(HELLO_STRING)
data
data
wcslen(HELLO_STRING)
wcslen
wcslen
HELLO_STRING
HELLO_STRING
data < 100
data
data
100
{                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }
myString = (wchar_t *)malloc(data*sizeof(wchar_t));
myString = (wchar_t *)malloc(data*sizeof(wchar_t))
myString
myString
(wchar_t *)malloc(data*sizeof(wchar_t))
wchar_t *
wchar_t
*
*
malloc(data*sizeof(wchar_t))
malloc
malloc
data*sizeof(wchar_t)
data
data
sizeof(wchar_t)
wchar_t
wchar_t

if (myString == NULL) {exit(-1);}
myString == NULL
myString
myString
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
wcscpy(myString, HELLO_STRING);
wcscpy(myString, HELLO_STRING)
wcscpy
wcscpy
myString
myString
HELLO_STRING
HELLO_STRING
printWLine(myString);
printWLine(myString)
printWLine
printWLine
myString
myString
free(myString);
free(myString)
free
free
myString
myString
{                printLine("Input is less than the length of the source string or too large");            }
printLine("Input is less than the length of the source string or too large");
printLine("Input is less than the length of the source string or too large")
printLine
printLine
"Input is less than the length of the source string or too large"
-----joern-----
(38,49,0)
(91,45,0)
(84,58,0)
(39,52,0)
(70,79,0)
(46,39,0)
(3,55,0)
(48,51,0)
(90,1,0)
(85,8,0)
(6,55,0)
(10,56,0)
(61,47,0)
(79,83,0)
(89,87,0)
(1,69,0)
(39,21,0)
(14,0,0)
(44,35,0)
(77,72,0)
(82,14,0)
(27,85,0)
(51,47,0)
(92,17,0)
(88,4,0)
(18,88,0)
(52,82,0)
(29,85,0)
(65,52,0)
(20,87,0)
(34,17,0)
(54,70,0)
(7,3,0)
(2,81,0)
(55,35,0)
(56,10,0)
(35,44,0)
(19,0,0)
(27,19,0)
(16,70,0)
(8,85,0)
(85,19,0)
(24,14,0)
(12,52,0)
(58,39,0)
(47,72,0)
(21,39,0)
(55,60,0)
(42,1,0)
(17,55,0)
(3,60,0)
(73,55,0)
(69,1,0)
(37,32,0)
(51,45,0)
(49,38,0)
(25,49,0)
(14,80,0)
(45,51,0)
(67,0,0)
(13,37,0)
(21,35,0)
(59,51,0)
(15,49,0)
(49,52,0)
(75,55,0)
(64,10,0)
(79,70,0)
(35,21,0)
(65,38,0)
(31,19,0)
(38,65,0)
(42,27,0)
(33,0,0)
(35,55,0)
(73,60,0)
(5,0,0)
(26,72,0)
(36,42,0)
(9,8,0)
(65,81,0)
(1,0,0)
(80,14,0)
(27,79,0)
(22,79,0)
(75,60,0)
(87,0,0)
(11,51,0)
(74,73,0)
(66,78,0)
(62,69,0)
(28,3,0)
(68,37,0)
(40,47,0)
(23,70,0)
(50,65,0)
(52,32,0)
(82,52,0)
(8,1,0)
(39,58,0)
(43,27,0)
(71,32,0)
(56,76,0)
(70,47,0)
(53,82,0)
(57,60,0)
(78,41,0)
(81,65,0)
(63,80,0)
(72,19,0)
(30,75,0)
(32,0,0)
(63,24,1)
(35,44,1)
(20,89,1)
(17,92,1)
(62,90,1)
(65,52,1)
(28,17,1)
(56,10,1)
(80,63,1)
(65,81,1)
(29,87,1)
(86,88,1)
(82,53,1)
(42,36,1)
(21,39,1)
(49,52,1)
(12,27,1)
(30,3,1)
(25,15,1)
(84,46,1)
(70,47,1)
(59,47,1)
(28,56,1)
(45,51,1)
(88,18,1)
(34,55,1)
(10,64,1)
(17,55,1)
(18,38,1)
(27,43,1)
(81,2,1)
(14,80,1)
(9,29,1)
(73,74,1)
(70,54,1)
(51,47,1)
(27,85,1)
(61,40,1)
(2,50,1)
(43,42,1)
(36,78,1)
(6,38,1)
(64,17,1)
(89,14,1)
(22,45,1)
(3,55,1)
(79,70,1)
(46,6,1)
(54,23,1)
(85,8,1)
(86,73,1)
(3,7,1)
(35,21,1)
(48,59,1)
(40,85,1)
(8,1,1)
(55,35,1)
(7,28,1)
(38,65,1)
(75,30,1)
(52,82,1)
(87,20,1)
(78,66,1)
(45,91,1)
(27,79,1)
(73,55,1)
(69,62,1)
(38,49,1)
(51,11,1)
(8,9,1)
(49,25,1)
(82,14,1)
(75,55,1)
(36,79,1)
(91,51,1)
(15,65,1)
(58,84,1)
(92,34,1)
(16,22,1)
(66,45,1)
(1,69,1)
(42,1,1)
(39,52,1)
(23,16,1)
(24,1,1)
(11,48,1)
(47,61,1)
(39,58,1)
(53,12,1)
(50,52,1)
(74,75,1)
(3,55,2)
(70,45,2)
(58,38,2)
(70,47,2)
(35,44,2)
(42,1,2)
(56,17,2)
(85,8,2)
(52,82,2)
(27,85,2)
(78,45,2)
(88,38,2)
(65,81,2)
(39,38,2)
(49,65,2)
(27,79,2)
(66,45,2)
(73,38,2)
(28,38,2)
(39,58,2)
(39,52,2)
(30,38,2)
(14,80,2)
(79,70,2)
(82,14,2)
(25,65,2)
(45,51,2)
(79,45,2)
(23,45,2)
(17,55,2)
(21,39,2)
(16,45,2)
(17,38,2)
(75,55,2)
(3,38,2)
(64,17,2)
(74,38,2)
(21,38,2)
(7,38,2)
(15,65,2)
(73,55,2)
(8,1,2)
(35,21,2)
(10,17,2)
(84,38,2)
(35,38,2)
(49,52,2)
(75,38,2)
(56,10,2)
(34,38,2)
(92,38,2)
(22,45,2)
(65,52,2)
(51,47,2)
(38,65,2)
(54,45,2)
(18,38,2)
(6,38,2)
(1,69,2)
(46,38,2)
(38,49,2)
(55,35,2)
(55,38,2)
-----------------------------------
(0,)
(1,*dataPtr1 = &data)
(2,HELLO_STRING)
(3,wcscpy(myString, HELLO_STRING)
(4,)
(5,dataPtr1)
(6,myString)
(7,HELLO_STRING)
(8,*dataPtr1)
(9,dataPtr1)
(10,-1)
(11,stdin)
(12,data)
(13,if (data > wcslen(HELLO_STRING)
(14,*dataPtr2 = &data)
(15,data)
(16,inputBuffer)
(17,myString == NULL)
(18,"Input is less than the length of the source string or too large")
(19,)
(20,0)
(21,malloc(data*sizeof(wchar_t)
(22,data)
(23,NULL)
(24,dataPtr2)
(25,100)
(26,if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
(27,*dataPtr1 = data)
(28,myString)
(29,data)
(30,myString)
(31,data)
(32,)
(33,data)
(34,myString)
(35,(wchar_t *)
(36,dataPtr1)
(37,)
(38,data > wcslen(HELLO_STRING)
(39,data*sizeof(wchar_t)
(40,inputBuffer)
(41,)
(42,*dataPtr1)
(43,data)
(44,wchar_t *)
(45,fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
(46,data)
(47,inputBuffer[CHAR_ARRAY_SIZE] = "")
(48,CHAR_ARRAY_SIZE)
(49,data < 100)
(50,data)
(51,fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin)
(52,data = *dataPtr2)
(53,dataPtr2)
(54,0)
(55,myString = (wchar_t *)
(56,exit(-1)
(57,if (myString == NULL)
(58,sizeof(wchar_t)
(59,inputBuffer)
(60,)
(61,"")
(62,data)
(63,data)
(64,1)
(65,data > wcslen(HELLO_STRING)
(66,"fgets()
(67,dataPtr2)
(68,myString)
(69,&data)
(70,strtoul(inputBuffer, NULL, 0)
(71,data)
(72,)
(73,free(myString)
(74,myString)
(75,printWLine(myString)
(76,)
(77,inputBuffer)
(78,printLine("fgets()
(79,data = strtoul(inputBuffer, NULL, 0)
(80,&data)
(81,wcslen(HELLO_STRING)
(82,*dataPtr2)
(83,)
(84,wchar_t)
(85,data = *dataPtr1)
(86,RET)
(87,data = 0)
(88,printLine("Input is less than the length of the source string or too large")
(89,data)
(90,dataPtr1)
(91,NULL)
(92,NULL)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^