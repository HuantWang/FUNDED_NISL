-----label-----
1
-----code-----
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_12_bad()
{
    size_t data;
    /* Initialize data */
    data = 0;
    if(globalReturnsTrueOrFalse())
    {
        /* POTENTIAL FLAW: Set data to a random value */
        data = rand();
    }
    else
    {
        /* FIX: Use a relatively small number for memory allocation */
        data = 20;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            wchar_t * myString;
            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough
             * for the wcscpy() function to not cause a buffer overflow */
            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */
            if (data > wcslen(HELLO_STRING))
            {
                myString = (wchar_t *)malloc(data*sizeof(wchar_t));
                if (myString == NULL) {exit(-1);}
                /* Copy a small string into myString */
                wcscpy(myString, HELLO_STRING);
                printWLine(myString);
                free(myString);
            }
            else
            {
                printLine("Input is less than the length of the source string");
            }
        }
    }
    else
    {
        {
            wchar_t * myString;
            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough
             * for the wcscpy() function to not cause a buffer overflow */
            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */
            if (data > wcslen(HELLO_STRING) && data < 100)
            {
                myString = (wchar_t *)malloc(data*sizeof(wchar_t));
                if (myString == NULL) {exit(-1);}
                /* Copy a small string into myString */
                wcscpy(myString, HELLO_STRING);
                printWLine(myString);
                free(myString);
            }
            else
            {
                printLine("Input is less than the length of the source string or too large");
            }
        }
    }
}
-----children-----
1,2
1,3
1,4
3,4
5,6
5,7
5,8
5,9
6,7
7,8
7,9
8,9
10,11
12,13
13,14
13,15
14,15
17,18
17,19
17,20
18,19
19,20
21,22
22,23
23,24
23,25
24,25
26,27
27,28
29,30
30,31
31,32
31,33
32,33
35,36
35,37
35,38
36,37
37,38
39,40
40,41
40,42
41,42
42,43
42,44
44,45
44,46
47,48
47,49
47,50
48,49
48,50
49,50
51,52
51,53
52,53
54,55
56,57
56,58
56,59
56,60
56,61
57,58
58,59
58,60
59,60
61,62
61,63
62,63
62,64
64,65
66,67
66,68
67,68
69,70
69,71
70,71
72,73
73,74
73,75
76,77
76,78
77,78
77,79
78,79
80,81
82,83
83,84
84,85
84,86
85,86
87,88
89,90
90,91
90,92
90,93
91,92
93,94
95,96
97,98
98,99
98,100
99,100
101,102
103,104
104,105
104,106
105,106
107,108
109,110
110,111
111,112
111,113
112,113
115,116
116,117
116,118
117,118
118,119
118,120
120,121
120,122
123,124
123,125
123,126
124,125
124,126
125,126
125,127
126,127
128,129
128,130
129,130
131,132
133,134
133,135
134,135
137,138
137,139
137,140
137,141
137,142
138,139
139,140
139,141
140,141
142,143
142,144
143,144
143,145
145,146
147,148
147,149
148,149
150,151
150,152
151,152
153,154
154,155
154,156
157,158
157,159
158,159
158,160
159,160
161,162
163,164
164,165
165,166
165,167
166,167
168,169
170,171
171,172
171,173
171,174
172,173
174,175
176,177
178,179
179,180
179,181
180,181
182,183
184,185
185,186
185,187
186,187
188,189
190,191
191,192
192,193
192,194
193,194
-----nextToken-----
2,4,9,11,15,16,20,25,28,33,34,38,43,45,46,50,53,55,60,63,65,68,71,74,75,79,81,86,88,92,94,96,100,102,106,108,113,114,119,121,122,127,130,132,135,136,141,144,146,149,152,155,156,160,162,167,169,173,175,177,181,183,187,189,194,195
-----computeFrom-----
13,14
13,15
23,24
23,25
31,32
31,33
48,49
48,50
58,59
58,60
69,70
69,71
77,78
77,79
124,125
124,126
125,126
125,127
133,134
133,135
139,140
139,141
150,151
150,152
158,159
158,160
-----guardedBy-----
55,96
50,71
132,177
135,152
-----guardedByNegation-----
-----lastLexicalUse-----
-----jump-----
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;LiteralExpression;IfStatement;FunctionCallExpression;IdExpression;Name;CompoundStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;IfStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;CompoundStatement;CompoundStatement;DeclarationStatement;SimpleDeclaration;SimpleDeclSpecifier;Declarator;Pointer;Name;IfStatement;BinaryExpression;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BinaryExpression;IdExpression;Name;LiteralExpression;CompoundStatement;ExpressionStatement;BinaryExpression;IdExpression;Name;CastExpression;TypeId;SimpleDeclSpecifier;Declarator;Pointer;FunctionCallExpression;IdExpression;Name;BinaryExpression;IdExpression;Name;TypeIdExpression;TypeId;SimpleDeclSpecifier;Declarator;IfStatement;BinaryExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;UnaryExpression;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;LiteralExpression;
-----ast_node-----
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_12_bad(){    size_t data;    /* Initialize data */    data = 0;    if(globalReturnsTrueOrFalse())    {        /* POTENTIAL FLAW: Set data to a random value */        data = rand();    }    else    {        /* FIX: Use a relatively small number for memory allocation */        data = 20;    }    if(globalReturnsTrueOrFalse())    {        {            wchar_t * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING))            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }    else    {        {            wchar_t * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }}
void
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_12_bad()
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_12_bad
{    size_t data;    /* Initialize data */    data = 0;    if(globalReturnsTrueOrFalse())    {        /* POTENTIAL FLAW: Set data to a random value */        data = rand();    }    else    {        /* FIX: Use a relatively small number for memory allocation */        data = 20;    }    if(globalReturnsTrueOrFalse())    {        {            wchar_t * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING))            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }    else    {        {            wchar_t * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }}
size_t data;
size_t data;
size_t
size_t
data
data
data = 0;
data = 0
data
data
0
if(globalReturnsTrueOrFalse())    {        /* POTENTIAL FLAW: Set data to a random value */        data = rand();    }    else    {        /* FIX: Use a relatively small number for memory allocation */        data = 20;    }
globalReturnsTrueOrFalse()
globalReturnsTrueOrFalse
globalReturnsTrueOrFalse
{        /* POTENTIAL FLAW: Set data to a random value */        data = rand();    }
data = rand();
data = rand()
data
data
rand()
rand
rand
{        /* FIX: Use a relatively small number for memory allocation */        data = 20;    }
data = 20;
data = 20
data
data
20
if(globalReturnsTrueOrFalse())    {        {            wchar_t * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING))            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }    else    {        {            wchar_t * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }
globalReturnsTrueOrFalse()
globalReturnsTrueOrFalse
globalReturnsTrueOrFalse
{        {            wchar_t * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING))            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }    }
{            wchar_t * myString;            /* POTENTIAL FLAW: No MAXIMUM limitation for memory allocation, but ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING))            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }        }
wchar_t * myString;
wchar_t * myString;
wchar_t
* myString
*
myString
if (data > wcslen(HELLO_STRING))            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string");            }
data > wcslen(HELLO_STRING)
data
data
wcslen(HELLO_STRING)
wcslen
wcslen
HELLO_STRING
HELLO_STRING
{                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }
myString = (wchar_t *)malloc(data*sizeof(wchar_t));
myString = (wchar_t *)malloc(data*sizeof(wchar_t))
myString
myString
(wchar_t *)malloc(data*sizeof(wchar_t))
wchar_t *
wchar_t
*
*
malloc(data*sizeof(wchar_t))
malloc
malloc
data*sizeof(wchar_t)
data
data
sizeof(wchar_t)
wchar_t
wchar_t

if (myString == NULL) {exit(-1);}
myString == NULL
myString
myString
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
wcscpy(myString, HELLO_STRING);
wcscpy(myString, HELLO_STRING)
wcscpy
wcscpy
myString
myString
HELLO_STRING
HELLO_STRING
printWLine(myString);
printWLine(myString)
printWLine
printWLine
myString
myString
free(myString);
free(myString)
free
free
myString
myString
{                printLine("Input is less than the length of the source string");            }
printLine("Input is less than the length of the source string");
printLine("Input is less than the length of the source string")
printLine
printLine
"Input is less than the length of the source string"
{        {            wchar_t * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }    }
{            wchar_t * myString;            /* FIX: Include a MAXIMUM limitation for memory allocation and a check to ensure data is large enough             * for the wcscpy() function to not cause a buffer overflow */            /* INCIDENTAL FLAW: The source could cause a type overrun in data or in the memory allocation */            if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }        }
wchar_t * myString;
wchar_t * myString;
wchar_t
* myString
*
myString
if (data > wcslen(HELLO_STRING) && data < 100)            {                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }            else            {                printLine("Input is less than the length of the source string or too large");            }
data > wcslen(HELLO_STRING) && data < 100
data > wcslen(HELLO_STRING)
data
data
wcslen(HELLO_STRING)
wcslen
wcslen
HELLO_STRING
HELLO_STRING
data < 100
data
data
100
{                myString = (wchar_t *)malloc(data*sizeof(wchar_t));                if (myString == NULL) {exit(-1);}                /* Copy a small string into myString */                wcscpy(myString, HELLO_STRING);                printWLine(myString);                free(myString);            }
myString = (wchar_t *)malloc(data*sizeof(wchar_t));
myString = (wchar_t *)malloc(data*sizeof(wchar_t))
myString
myString
(wchar_t *)malloc(data*sizeof(wchar_t))
wchar_t *
wchar_t
*
*
malloc(data*sizeof(wchar_t))
malloc
malloc
data*sizeof(wchar_t)
data
data
sizeof(wchar_t)
wchar_t
wchar_t

if (myString == NULL) {exit(-1);}
myString == NULL
myString
myString
NULL
NULL
{exit(-1);}
exit(-1);
exit(-1)
exit
exit
-1
1
wcscpy(myString, HELLO_STRING);
wcscpy(myString, HELLO_STRING)
wcscpy
wcscpy
myString
myString
HELLO_STRING
HELLO_STRING
printWLine(myString);
printWLine(myString)
printWLine
printWLine
myString
myString
free(myString);
free(myString)
free
free
myString
myString
{                printLine("Input is less than the length of the source string or too large");            }
printLine("Input is less than the length of the source string or too large");
printLine("Input is less than the length of the source string or too large")
printLine
printLine
"Input is less than the length of the source string or too large"
-----joern-----
(39,33,0)
(29,40,0)
(82,86,0)
(71,2,0)
(54,59,0)
(42,40,0)
(40,33,0)
(11,10,0)
(12,40,0)
(59,54,0)
(53,40,0)
(56,31,0)
(2,89,0)
(12,57,0)
(57,0,0)
(0,79,0)
(40,12,0)
(0,83,0)
(55,12,0)
(32,91,0)
(77,79,0)
(77,93,0)
(86,9,0)
(49,42,0)
(34,8,0)
(4,60,0)
(2,32,0)
(13,39,0)
(9,64,0)
(26,64,0)
(44,61,0)
(17,26,0)
(6,16,0)
(75,33,0)
(72,53,0)
(9,44,0)
(68,59,0)
(36,92,0)
(88,63,0)
(0,57,0)
(24,41,0)
(62,54,0)
(63,31,0)
(69,87,0)
(19,53,0)
(59,32,0)
(60,50,0)
(28,2,0)
(59,93,0)
(44,9,0)
(52,28,0)
(38,83,0)
(87,9,0)
(37,0,0)
(39,40,0)
(66,41,0)
(20,36,0)
(18,32,0)
(0,32,0)
(22,40,0)
(21,42,0)
(46,24,0)
(70,23,0)
(57,12,0)
(44,89,0)
(27,24,0)
(67,34,0)
(65,48,0)
(78,32,0)
(93,59,0)
(77,32,0)
(63,79,0)
(58,41,0)
(60,4,0)
(26,9,0)
(65,85,0)
(74,41,0)
(83,0,0)
(5,16,0)
(16,14,0)
(87,64,0)
(1,29,0)
(32,78,0)
(79,3,0)
(90,26,0)
(42,33,0)
(29,33,0)
(81,85,0)
(76,36,0)
(10,9,0)
(30,9,0)
(89,44,0)
(73,79,0)
(12,55,0)
(35,64,0)
(85,65,0)
(23,47,0)
(89,2,0)
(45,10,0)
(31,63,0)
(63,32,0)
(61,44,0)
(43,79,0)
(2,79,0)
(93,77,0)
(2,28,0)
(51,77,0)
(84,4,0)
(25,77,0)
(59,79,0)
(86,64,0)
(37,22,1)
(17,90,1)
(46,27,1)
(63,31,1)
(1,39,1)
(82,26,1)
(79,43,1)
(77,32,1)
(88,80,1)
(32,78,1)
(77,79,1)
(15,34,1)
(60,4,1)
(93,59,1)
(44,89,1)
(93,77,1)
(42,21,1)
(83,38,1)
(39,13,1)
(73,7,1)
(67,93,1)
(2,32,1)
(22,63,1)
(49,53,1)
(87,69,1)
(63,32,1)
(4,84,1)
(19,72,1)
(59,32,1)
(26,9,1)
(62,68,1)
(70,63,1)
(86,9,1)
(53,40,1)
(65,85,1)
(90,10,1)
(2,28,1)
(11,9,1)
(24,46,1)
(13,42,1)
(21,49,1)
(80,79,1)
(78,18,1)
(23,70,1)
(9,44,1)
(12,57,1)
(34,67,1)
(29,40,1)
(10,9,1)
(2,79,1)
(38,37,1)
(57,0,1)
(80,32,1)
(0,79,1)
(10,45,1)
(26,17,1)
(15,87,1)
(52,71,1)
(28,52,1)
(0,83,1)
(51,25,1)
(49,60,1)
(63,79,1)
(43,73,1)
(86,82,1)
(7,24,1)
(12,55,1)
(85,81,1)
(81,10,1)
(77,51,1)
(39,40,1)
(15,29,1)
(18,7,1)
(42,40,1)
(71,30,1)
(30,93,1)
(90,65,1)
(89,2,1)
(15,23,1)
(59,54,1)
(54,62,1)
(72,40,1)
(31,56,1)
(87,9,1)
(69,86,1)
(29,1,1)
(0,32,1)
(68,80,1)
(25,59,1)
(44,61,1)
(53,19,1)
(56,88,1)
(45,11,1)
(84,53,1)
(40,12,1)
(59,79,1)
(90,93,2)
(10,9,2)
(70,63,2)
(0,83,2)
(65,85,2)
(93,59,2)
(25,59,2)
(9,44,2)
(0,32,2)
(12,57,2)
(83,63,2)
(0,63,2)
(44,61,2)
(17,93,2)
(11,93,2)
(73,7,2)
(87,9,2)
(32,7,2)
(40,12,2)
(39,40,2)
(32,78,2)
(42,40,2)
(12,63,2)
(29,40,2)
(89,2,2)
(54,80,2)
(10,93,2)
(34,93,2)
(39,63,2)
(57,0,2)
(26,9,2)
(44,89,2)
(2,28,2)
(60,4,2)
(63,32,2)
(68,80,2)
(2,32,2)
(9,93,2)
(19,63,2)
(28,93,2)
(63,79,2)
(57,63,2)
(29,63,2)
(59,79,2)
(12,55,2)
(13,63,2)
(87,93,2)
(59,32,2)
(26,93,2)
(51,59,2)
(65,10,2)
(2,79,2)
(21,63,2)
(43,7,2)
(93,80,2)
(37,63,2)
(71,93,2)
(23,63,2)
(1,63,2)
(38,63,2)
(4,53,2)
(78,7,2)
(69,93,2)
(49,63,2)
(77,32,2)
(42,63,2)
(86,9,2)
(85,10,2)
(56,80,2)
(67,93,2)
(52,93,2)
(81,10,2)
(22,63,2)
(62,80,2)
(2,93,2)
(82,93,2)
(0,79,2)
(77,79,2)
(93,77,2)
(53,63,2)
(77,59,2)
(45,93,2)
(53,40,2)
(31,80,2)
(89,93,2)
(86,93,2)
(84,53,2)
(30,93,2)
(44,93,2)
(59,80,2)
(63,80,2)
(18,7,2)
(59,54,2)
(88,80,2)
(63,31,2)
(40,63,2)
(79,7,2)
(60,53,2)
(72,63,2)
-----------------------------------
(0,data*sizeof(wchar_t)
(1,myString)
(2,data*sizeof(wchar_t)
(3,)
(4,-1)
(5,myString)
(6,if (data > wcslen(HELLO_STRING)
(7,globalReturnsTrueOrFalse()
(8,)
(9,myString = (wchar_t *)
(10,myString == NULL)
(11,myString)
(12,(wchar_t *)
(13,myString)
(14,)
(15,RET)
(16,)
(17,HELLO_STRING)
(18,data)
(19,NULL)
(20,myString)
(21,HELLO_STRING)
(22,myString)
(23,printLine("Input is less than the length of the source string")
(24,data = 0)
(25,data)
(26,wcscpy(myString, HELLO_STRING)
(27,data)
(28,sizeof(wchar_t)
(29,free(myString)
(30,myString)
(31,wcslen(HELLO_STRING)
(32,data = rand()
(33,)
(34,printLine("Input is less than the length of the source string or too large")
(35,if (myString == NULL)
(36,)
(37,data)
(38,wchar_t)
(39,printWLine(myString)
(40,myString = (wchar_t *)
(41,)
(42,wcscpy(myString, HELLO_STRING)
(43,20)
(44,(wchar_t *)
(45,NULL)
(46,0)
(47,)
(48,)
(49,myString)
(50,)
(51,100)
(52,wchar_t)
(53,myString == NULL)
(54,wcslen(HELLO_STRING)
(55,wchar_t *)
(56,HELLO_STRING)
(57,malloc(data*sizeof(wchar_t)
(58,if(globalReturnsTrueOrFalse()
(59,data > wcslen(HELLO_STRING)
(60,exit(-1)
(61,wchar_t *)
(62,HELLO_STRING)
(63,data > wcslen(HELLO_STRING)
(64,)
(65,exit(-1)
(66,data)
(67,"Input is less than the length of the source string or too large")
(68,data)
(69,myString)
(70,"Input is less than the length of the source string")
(71,data)
(72,myString)
(73,data)
(74,if(globalReturnsTrueOrFalse()
(75,if (myString == NULL)
(76,if (data > wcslen(HELLO_STRING)
(77,data < 100)
(78,rand()
(79,data = 20)
(80,globalReturnsTrueOrFalse()
(81,1)
(82,myString)
(83,sizeof(wchar_t)
(84,1)
(85,-1)
(86,printWLine(myString)
(87,free(myString)
(88,data)
(89,malloc(data*sizeof(wchar_t)
(90,myString)
(91,)
(92,)
(93,data > wcslen(HELLO_STRING)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^