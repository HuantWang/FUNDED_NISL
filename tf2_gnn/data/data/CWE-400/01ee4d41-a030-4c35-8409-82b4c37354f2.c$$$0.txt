-----label-----
0
-----code-----
void rmonitor_dispatch_msg(void)
{
	struct rmonitor_msg msg;
	struct rmonitor_process_info *p;

	recv_monitor_msg(rmonitor_queue_fd, &msg);

	debug(D_DEBUG,"message \"%s\" from %d\n", str_msgtype(msg.type), msg.origin);

	p = itable_lookup(processes, (uint64_t) msg.origin);

	if(!p)
	{
		/* We either got a malformed message, message from a
		process we are not tracking anymore, or a message from
		a newly created process.  */
		if( msg.type == END_WAIT )
        {
			release_waiting_process(msg.origin);
			return;
        }
		else if(msg.type != BRANCH)
			return;
	}

    switch(msg.type)
    {
        case BRANCH:
            rmonitor_track_process(msg.origin);
            if(summary->max_concurrent_processes < itable_size(processes))
                summary->max_concurrent_processes = itable_size(processes);
            break;
        case END_WAIT:
            p->waiting = 1;
            break;
        case END:
            rmonitor_untrack_process(msg.data.p);
            break;
        case CHDIR:
            p->wd = lookup_or_create_wd(p->wd, msg.data.s);
            break;
		case OPEN_INPUT:
		case OPEN_OUTPUT:
			switch(msg.error) {
				case 0:
					debug(D_DEBUG, "File %s has been opened.\n", msg.data.s);
					rmonitor_inotify_add_watch(msg.data.s, msg.type == OPEN_OUTPUT);
					break;
				case EMFILE:
					/* Eventually report that we ran out of file descriptors. */
					break;
				default:
					break;
			}
			break;
        case READ:
            break;
        case WRITE:
            break;
        default:
            break;
    };

	if(!rmonitor_check_limits(summary))
		rmonitor_final_cleanup(SIGTERM);

}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
9,10
9,11
9,12
9,13
9,14
9,15
9,16
9,17
9,18
10,11
11,12
11,13
12,13
14,15
16,17
17,18
17,19
18,19
20,21
20,22
23,24
24,25
24,26
24,27
25,26
27,28
29,30
30,31
32,33
33,34
33,35
33,36
33,37
33,38
34,35
36,37
39,40
39,41
40,41
42,43
42,44
43,44
46,47
46,48
47,48
50,51
51,52
51,53
52,53
54,55
54,56
54,57
55,56
57,58
59,60
59,61
60,61
60,62
61,62
64,65
64,66
65,66
68,69
68,70
69,70
70,71
72,73
73,74
73,75
73,76
74,75
74,76
75,76
75,77
76,77
79,80
81,82
81,83
82,83
83,84
83,85
84,85
86,87
86,88
87,88
91,92
91,93
92,93
92,94
93,94
93,95
94,95
97,98
100,101
100,102
101,102
101,103
102,103
105,106
105,107
105,108
105,109
105,110
105,111
105,112
105,113
105,114
105,115
105,116
105,117
105,118
105,119
105,120
105,121
105,122
105,123
105,124
105,125
105,126
105,127
105,128
106,107
107,108
109,110
110,111
110,112
111,112
113,114
113,115
114,115
117,118
117,119
118,119
118,120
119,120
119,121
120,121
123,124
123,125
124,125
126,127
128,129
129,130
129,131
130,131
130,132
131,132
134,135
134,136
135,136
137,138
140,141
141,142
143,144
144,145
144,146
145,146
145,147
146,147
151,152
152,153
154,155
155,156
155,157
156,157
158,159
158,160
159,160
159,161
160,161
165,166
166,167
168,169
169,170
169,171
170,171
170,172
171,172
174,175
174,176
174,177
175,176
177,178
177,179
178,179
181,182
181,183
182,183
182,184
183,184
188,189
189,190
191,192
192,193
194,195
194,196
195,196
195,197
196,197
199,200
199,201
199,202
199,203
199,204
199,205
199,206
199,207
200,201
202,203
203,204
203,205
203,206
203,207
204,205
206,207
209,210
209,211
210,211
210,212
211,212
215,216
216,217
216,218
216,219
217,218
219,220
219,221
220,221
220,222
221,222
225,226
225,227
226,227
226,228
227,228
230,231
233,234
234,235
240,241
241,242
244,245
245,246
251,252
251,253
252,253
253,254
253,255
254,255
256,257
258,259
259,260
259,261
260,261
262,263
263,264
-----nextToken-----
2,4,6,8,13,15,19,21,22,26,28,31,35,37,38,41,44,45,48,49,53,56,58,62,63,66,67,71,77,78,80,85,88,89,90,95,96,98,99,103,104,108,112,115,116,121,122,125,127,132,133,136,138,139,142,147,148,149,150,153,157,161,162,163,164,167,172,173,176,179,180,184,185,186,187,190,193,197,198,201,205,207,208,212,213,214,218,222,223,224,228,229,231,232,235,236,237,238,239,242,243,246,247,248,249,250,255,257,261,264
-----computeFrom-----
51,52
51,53
74,75
74,76
92,93
92,94
118,119
118,120
129,130
129,131
144,145
144,146
169,170
169,171
225,226
225,227
-----guardedBy-----
77,88
121,132
127,138
122,133
125,136
-----guardedByNegation-----
77,95
78,96
-----lastLexicalUse-----
77,95
-----jump-----
77,95
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;BreakStatement;DefaultStatement;BreakStatement;BreakStatement;CaseStatement;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;BreakStatement;DefaultStatement;BreakStatement;NullStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;
-----ast_node-----
void rmonitor_dispatch_msg(void){	struct rmonitor_msg msg;	struct rmonitor_process_info *p;	recv_monitor_msg(rmonitor_queue_fd, &msg);	debug(D_DEBUG,"message \"%s\" from %d\n", str_msgtype(msg.type), msg.origin);	p = itable_lookup(processes, (uint64_t) msg.origin);	if(!p)	{		/* We either got a malformed message, message from a		process we are not tracking anymore, or a message from		a newly created process.  */		if( msg.type == END_WAIT )        {			release_waiting_process(msg.origin);			return;        }		else if(msg.type != BRANCH)			return;	}    switch(msg.type)    {        case BRANCH:            rmonitor_track_process(msg.origin);            if(summary->max_concurrent_processes < itable_size(processes))                summary->max_concurrent_processes = itable_size(processes);            break;        case END_WAIT:            p->waiting = 1;            break;        case END:            rmonitor_untrack_process(msg.data.p);            break;        case CHDIR:            p->wd = lookup_or_create_wd(p->wd, msg.data.s);            break;		case OPEN_INPUT:		case OPEN_OUTPUT:			switch(msg.error) {				case 0:					debug(D_DEBUG, "File %s has been opened.\n", msg.data.s);					rmonitor_inotify_add_watch(msg.data.s, msg.type == OPEN_OUTPUT);					break;				case EMFILE:					/* Eventually report that we ran out of file descriptors. */					break;				default:					break;			}			break;        case READ:            break;        case WRITE:            break;        default:            break;    };	if(!rmonitor_check_limits(summary))		rmonitor_final_cleanup(SIGTERM);}
void
rmonitor_dispatch_msg(void)
rmonitor_dispatch_msg
void
void


{	struct rmonitor_msg msg;	struct rmonitor_process_info *p;	recv_monitor_msg(rmonitor_queue_fd, &msg);	debug(D_DEBUG,"message \"%s\" from %d\n", str_msgtype(msg.type), msg.origin);	p = itable_lookup(processes, (uint64_t) msg.origin);	if(!p)	{		/* We either got a malformed message, message from a		process we are not tracking anymore, or a message from		a newly created process.  */		if( msg.type == END_WAIT )        {			release_waiting_process(msg.origin);			return;        }		else if(msg.type != BRANCH)			return;	}    switch(msg.type)    {        case BRANCH:            rmonitor_track_process(msg.origin);            if(summary->max_concurrent_processes < itable_size(processes))                summary->max_concurrent_processes = itable_size(processes);            break;        case END_WAIT:            p->waiting = 1;            break;        case END:            rmonitor_untrack_process(msg.data.p);            break;        case CHDIR:            p->wd = lookup_or_create_wd(p->wd, msg.data.s);            break;		case OPEN_INPUT:		case OPEN_OUTPUT:			switch(msg.error) {				case 0:					debug(D_DEBUG, "File %s has been opened.\n", msg.data.s);					rmonitor_inotify_add_watch(msg.data.s, msg.type == OPEN_OUTPUT);					break;				case EMFILE:					/* Eventually report that we ran out of file descriptors. */					break;				default:					break;			}			break;        case READ:            break;        case WRITE:            break;        default:            break;    };	if(!rmonitor_check_limits(summary))		rmonitor_final_cleanup(SIGTERM);}
struct rmonitor_msg msg;
struct rmonitor_msg msg;
struct rmonitor_msg
rmonitor_msg
msg
msg
struct rmonitor_process_info *p;
struct rmonitor_process_info *p;
struct rmonitor_process_info
rmonitor_process_info
*p
*
p
recv_monitor_msg(rmonitor_queue_fd, &msg);
recv_monitor_msg(rmonitor_queue_fd, &msg)
recv_monitor_msg
recv_monitor_msg
rmonitor_queue_fd
rmonitor_queue_fd
&msg
msg
msg
debug(D_DEBUG,"message \"%s\" from %d\n", str_msgtype(msg.type), msg.origin);
debug(D_DEBUG,"message \"%s\" from %d\n", str_msgtype(msg.type), msg.origin)
debug
debug
D_DEBUG
D_DEBUG
"message \"%s\" from %d\n"
str_msgtype(msg.type)
str_msgtype
str_msgtype
msg.type
msg
msg
type
msg.origin
msg
msg
origin
p = itable_lookup(processes, (uint64_t) msg.origin);
p = itable_lookup(processes, (uint64_t) msg.origin)
p
p
itable_lookup(processes, (uint64_t) msg.origin)
itable_lookup
itable_lookup
processes
processes
(uint64_t) msg.origin
uint64_t
uint64_t
uint64_t

msg.origin
msg
msg
origin
if(!p)	{		/* We either got a malformed message, message from a		process we are not tracking anymore, or a message from		a newly created process.  */		if( msg.type == END_WAIT )        {			release_waiting_process(msg.origin);			return;        }		else if(msg.type != BRANCH)			return;	}
!p
p
p
{		/* We either got a malformed message, message from a		process we are not tracking anymore, or a message from		a newly created process.  */		if( msg.type == END_WAIT )        {			release_waiting_process(msg.origin);			return;        }		else if(msg.type != BRANCH)			return;	}
if( msg.type == END_WAIT )        {			release_waiting_process(msg.origin);			return;        }		else if(msg.type != BRANCH)			return;
msg.type == END_WAIT
msg.type
msg
msg
type
END_WAIT
END_WAIT
{			release_waiting_process(msg.origin);			return;        }
release_waiting_process(msg.origin);
release_waiting_process(msg.origin)
release_waiting_process
release_waiting_process
msg.origin
msg
msg
origin
return;
if(msg.type != BRANCH)			return;
msg.type != BRANCH
msg.type
msg
msg
type
BRANCH
BRANCH
return;
switch(msg.type)    {        case BRANCH:            rmonitor_track_process(msg.origin);            if(summary->max_concurrent_processes < itable_size(processes))                summary->max_concurrent_processes = itable_size(processes);            break;        case END_WAIT:            p->waiting = 1;            break;        case END:            rmonitor_untrack_process(msg.data.p);            break;        case CHDIR:            p->wd = lookup_or_create_wd(p->wd, msg.data.s);            break;		case OPEN_INPUT:		case OPEN_OUTPUT:			switch(msg.error) {				case 0:					debug(D_DEBUG, "File %s has been opened.\n", msg.data.s);					rmonitor_inotify_add_watch(msg.data.s, msg.type == OPEN_OUTPUT);					break;				case EMFILE:					/* Eventually report that we ran out of file descriptors. */					break;				default:					break;			}			break;        case READ:            break;        case WRITE:            break;        default:            break;    }
msg.type
msg
msg
type
{        case BRANCH:            rmonitor_track_process(msg.origin);            if(summary->max_concurrent_processes < itable_size(processes))                summary->max_concurrent_processes = itable_size(processes);            break;        case END_WAIT:            p->waiting = 1;            break;        case END:            rmonitor_untrack_process(msg.data.p);            break;        case CHDIR:            p->wd = lookup_or_create_wd(p->wd, msg.data.s);            break;		case OPEN_INPUT:		case OPEN_OUTPUT:			switch(msg.error) {				case 0:					debug(D_DEBUG, "File %s has been opened.\n", msg.data.s);					rmonitor_inotify_add_watch(msg.data.s, msg.type == OPEN_OUTPUT);					break;				case EMFILE:					/* Eventually report that we ran out of file descriptors. */					break;				default:					break;			}			break;        case READ:            break;        case WRITE:            break;        default:            break;    }
case BRANCH:
BRANCH
BRANCH
rmonitor_track_process(msg.origin);
rmonitor_track_process(msg.origin)
rmonitor_track_process
rmonitor_track_process
msg.origin
msg
msg
origin
if(summary->max_concurrent_processes < itable_size(processes))                summary->max_concurrent_processes = itable_size(processes);
summary->max_concurrent_processes < itable_size(processes)
summary->max_concurrent_processes
summary
summary
max_concurrent_processes
itable_size(processes)
itable_size
itable_size
processes
processes
summary->max_concurrent_processes = itable_size(processes);
summary->max_concurrent_processes = itable_size(processes)
summary->max_concurrent_processes
summary
summary
max_concurrent_processes
itable_size(processes)
itable_size
itable_size
processes
processes
break;
case END_WAIT:
END_WAIT
END_WAIT
p->waiting = 1;
p->waiting = 1
p->waiting
p
p
waiting
1
break;
case END:
END
END
rmonitor_untrack_process(msg.data.p);
rmonitor_untrack_process(msg.data.p)
rmonitor_untrack_process
rmonitor_untrack_process
msg.data.p
msg.data
msg
msg
data
p
break;
case CHDIR:
CHDIR
CHDIR
p->wd = lookup_or_create_wd(p->wd, msg.data.s);
p->wd = lookup_or_create_wd(p->wd, msg.data.s)
p->wd
p
p
wd
lookup_or_create_wd(p->wd, msg.data.s)
lookup_or_create_wd
lookup_or_create_wd
p->wd
p
p
wd
msg.data.s
msg.data
msg
msg
data
s
break;
case OPEN_INPUT:
OPEN_INPUT
OPEN_INPUT
case OPEN_OUTPUT:
OPEN_OUTPUT
OPEN_OUTPUT
switch(msg.error) {				case 0:					debug(D_DEBUG, "File %s has been opened.\n", msg.data.s);					rmonitor_inotify_add_watch(msg.data.s, msg.type == OPEN_OUTPUT);					break;				case EMFILE:					/* Eventually report that we ran out of file descriptors. */					break;				default:					break;			}
msg.error
msg
msg
error
{				case 0:					debug(D_DEBUG, "File %s has been opened.\n", msg.data.s);					rmonitor_inotify_add_watch(msg.data.s, msg.type == OPEN_OUTPUT);					break;				case EMFILE:					/* Eventually report that we ran out of file descriptors. */					break;				default:					break;			}
case 0:
0
debug(D_DEBUG, "File %s has been opened.\n", msg.data.s);
debug(D_DEBUG, "File %s has been opened.\n", msg.data.s)
debug
debug
D_DEBUG
D_DEBUG
"File %s has been opened.\n"
msg.data.s
msg.data
msg
msg
data
s
rmonitor_inotify_add_watch(msg.data.s, msg.type == OPEN_OUTPUT);
rmonitor_inotify_add_watch(msg.data.s, msg.type == OPEN_OUTPUT)
rmonitor_inotify_add_watch
rmonitor_inotify_add_watch
msg.data.s
msg.data
msg
msg
data
s
msg.type == OPEN_OUTPUT
msg.type
msg
msg
type
OPEN_OUTPUT
OPEN_OUTPUT
break;
case EMFILE:
EMFILE
EMFILE
break;
default:
break;
break;
case READ:
READ
READ
break;
case WRITE:
WRITE
WRITE
break;
default:
break;
;
if(!rmonitor_check_limits(summary))		rmonitor_final_cleanup(SIGTERM);
!rmonitor_check_limits(summary)
rmonitor_check_limits(summary)
rmonitor_check_limits
rmonitor_check_limits
summary
summary
rmonitor_final_cleanup(SIGTERM);
rmonitor_final_cleanup(SIGTERM);
rmonitor_final_cleanup
rmonitor_final_cleanup
(SIGTERM)
SIGTERM
SIGTERM
-----joern-----
(142,125,0)
(124,49,0)
(132,53,0)
(45,70,0)
(64,10,0)
(75,8,0)
(83,140,0)
(70,100,0)
(98,25,0)
(146,125,0)
(30,16,0)
(112,43,0)
(66,92,0)
(72,42,0)
(91,122,0)
(38,60,0)
(23,97,0)
(108,123,0)
(109,127,0)
(84,92,0)
(26,42,0)
(110,62,0)
(101,135,0)
(35,32,0)
(130,92,0)
(43,8,0)
(9,65,0)
(55,78,0)
(24,91,0)
(31,70,0)
(11,135,0)
(1,92,0)
(5,27,0)
(46,92,0)
(147,92,0)
(122,91,0)
(73,132,0)
(39,100,0)
(10,64,0)
(90,87,0)
(74,60,0)
(6,27,0)
(4,8,0)
(42,72,0)
(111,92,0)
(88,39,0)
(113,139,0)
(115,44,0)
(14,27,0)
(44,56,0)
(15,27,0)
(50,16,0)
(16,25,0)
(144,92,0)
(17,8,0)
(40,92,0)
(68,27,0)
(107,27,0)
(59,132,0)
(80,140,0)
(96,91,0)
(34,109,0)
(104,47,0)
(136,90,0)
(116,41,0)
(127,109,0)
(122,15,0)
(129,74,0)
(39,27,0)
(72,123,0)
(105,18,0)
(74,64,0)
(128,41,0)
(123,72,0)
(54,122,0)
(119,62,0)
(69,41,0)
(36,60,0)
(145,92,0)
(100,70,0)
(78,62,0)
(43,65,0)
(131,0,0)
(99,42,0)
(126,92,0)
(81,43,0)
(19,47,0)
(10,139,0)
(15,122,0)
(95,28,0)
(100,39,0)
(60,123,0)
(7,125,0)
(18,97,0)
(133,74,0)
(63,92,0)
(128,43,0)
(52,32,0)
(93,18,0)
(61,92,0)
(89,72,0)
(135,28,0)
(64,92,0)
(139,60,0)
(57,92,0)
(12,49,0)
(37,35,0)
(72,89,0)
(16,60,0)
(56,44,0)
(47,8,0)
(120,53,0)
(43,128,0)
(47,19,0)
(141,20,0)
(65,43,0)
(85,0,0)
(121,8,0)
(28,135,0)
(97,23,0)
(15,53,0)
(134,92,0)
(51,23,0)
(62,78,0)
(127,1,0)
(103,86,0)
(48,38,0)
(33,92,0)
(21,39,0)
(106,109,0)
(117,114,0)
(143,127,0)
(37,67,0)
(58,92,0)
(77,100,0)
(137,27,0)
(22,114,0)
(87,90,0)
(10,28,0)
(138,19,0)
(139,10,0)
(0,52,0)
(28,10,0)
(13,87,0)
(76,2,0)
(79,92,0)
(140,83,0)
(3,8,0)
(114,56,0)
(118,65,0)
(123,60,0)
(53,15,0)
(142,92,0)
(25,92,0)
(60,8,0)
(71,92,0)
(125,142,0)
(52,0,0)
(41,128,0)
(102,92,0)
(82,139,0)
(29,90,0)
(94,2,0)
(1,127,0)
(53,132,0)
(97,18,0)
(14,2,1)
(55,62,1)
(6,2,1)
(112,81,1)
(38,48,1)
(12,78,1)
(82,113,1)
(13,90,1)
(2,94,1)
(88,21,1)
(80,145,1)
(71,25,1)
(35,52,1)
(98,16,1)
(12,38,1)
(86,103,1)
(80,111,1)
(139,60,1)
(132,59,1)
(10,28,1)
(94,76,1)
(37,86,1)
(74,133,1)
(145,97,1)
(123,72,1)
(73,122,1)
(0,85,1)
(107,15,1)
(24,39,1)
(111,107,1)
(43,65,1)
(53,132,1)
(16,60,1)
(37,83,1)
(131,87,1)
(96,24,1)
(44,115,1)
(31,88,1)
(100,77,1)
(36,43,1)
(62,119,1)
(127,143,1)
(11,101,1)
(80,66,1)
(120,132,1)
(91,96,1)
(93,142,1)
(52,0,1)
(136,38,1)
(105,93,1)
(47,19,1)
(15,122,1)
(117,97,1)
(129,49,1)
(30,50,1)
(127,109,1)
(145,56,1)
(19,138,1)
(21,2,1)
(113,74,1)
(25,98,1)
(38,60,1)
(37,67,1)
(9,118,1)
(125,7,1)
(139,82,1)
(85,131,1)
(115,114,1)
(133,129,1)
(110,87,1)
(1,127,1)
(101,139,1)
(49,124,1)
(87,13,1)
(146,49,1)
(51,18,1)
(128,41,1)
(64,10,1)
(16,30,1)
(65,9,1)
(54,91,1)
(81,47,1)
(48,60,1)
(28,135,1)
(10,139,1)
(111,14,1)
(43,128,1)
(83,140,1)
(34,106,1)
(87,90,1)
(80,71,1)
(126,49,1)
(78,62,1)
(56,44,1)
(63,49,1)
(109,34,1)
(80,126,1)
(103,83,1)
(50,49,1)
(45,31,1)
(143,109,1)
(142,125,1)
(74,60,1)
(22,117,1)
(15,53,1)
(7,146,1)
(106,49,1)
(140,80,1)
(59,73,1)
(124,12,1)
(60,123,1)
(111,6,1)
(42,99,1)
(37,35,1)
(100,70,1)
(78,55,1)
(53,120,1)
(80,63,1)
(69,116,1)
(116,112,1)
(77,70,1)
(97,18,1)
(102,1,1)
(90,29,1)
(135,11,1)
(84,49,1)
(67,78,1)
(70,45,1)
(72,89,1)
(39,100,1)
(80,102,1)
(114,22,1)
(29,136,1)
(108,36,1)
(23,51,1)
(72,42,1)
(118,128,1)
(80,84,1)
(119,110,1)
(26,108,1)
(76,49,1)
(122,54,1)
(66,64,1)
(97,23,1)
(28,95,1)
(122,91,1)
(99,26,1)
(18,105,1)
(95,135,1)
(138,104,1)
(41,69,1)
(117,97,2)
(120,2,2)
(28,49,2)
(90,38,2)
(43,65,2)
(14,2,2)
(72,89,2)
(78,87,2)
(10,28,2)
(24,2,2)
(133,49,2)
(67,78,2)
(21,2,2)
(131,87,2)
(15,122,2)
(146,49,2)
(105,49,2)
(13,38,2)
(145,49,2)
(140,78,2)
(43,128,2)
(18,49,2)
(113,49,2)
(6,2,2)
(111,49,2)
(49,78,2)
(7,49,2)
(142,125,2)
(47,19,2)
(39,100,2)
(119,87,2)
(49,38,2)
(98,49,2)
(87,38,2)
(72,42,2)
(2,49,2)
(62,87,2)
(94,49,2)
(86,83,2)
(106,49,2)
(107,2,2)
(129,49,2)
(54,2,2)
(56,44,2)
(64,10,2)
(51,49,2)
(74,49,2)
(77,2,2)
(78,62,2)
(135,49,2)
(139,49,2)
(39,2,2)
(52,87,2)
(142,49,2)
(35,87,2)
(80,78,2)
(10,49,2)
(102,49,2)
(91,2,2)
(100,70,2)
(23,49,2)
(114,97,2)
(115,97,2)
(55,87,2)
(38,60,2)
(34,49,2)
(56,97,2)
(74,60,2)
(29,38,2)
(124,78,2)
(70,2,2)
(100,2,2)
(95,49,2)
(101,49,2)
(11,49,2)
(84,49,2)
(10,139,2)
(97,18,2)
(59,2,2)
(143,49,2)
(140,38,2)
(1,127,2)
(127,109,2)
(64,49,2)
(22,97,2)
(53,132,2)
(76,49,2)
(12,38,2)
(83,78,2)
(122,91,2)
(1,49,2)
(73,2,2)
(132,2,2)
(139,60,2)
(50,49,2)
(124,38,2)
(0,87,2)
(28,135,2)
(71,49,2)
(31,2,2)
(44,97,2)
(85,87,2)
(87,90,2)
(128,41,2)
(125,49,2)
(82,49,2)
(97,49,2)
(53,2,2)
(97,23,2)
(15,53,2)
(136,38,2)
(80,38,2)
(110,87,2)
(127,49,2)
(103,83,2)
(16,60,2)
(37,67,2)
(88,2,2)
(122,2,2)
(63,49,2)
(30,49,2)
(123,72,2)
(16,49,2)
(66,49,2)
(109,49,2)
(83,38,2)
(93,49,2)
(83,140,2)
(25,49,2)
(15,2,2)
(12,78,2)
(45,2,2)
(60,123,2)
(96,2,2)
(126,49,2)
(52,0,2)
(37,35,2)
-----------------------------------
(0,msg.origin)
(1,rmonitor_untrack_process(msg.data.p)
(2,msg.error)
(3,if(!p)
(4,switch(msg.type)
(5,case 0:)
(6,break;)
(7,origin)
(8,)
(9,origin)
(10,lookup_or_create_wd(p->wd, msg.data.s)
(11,data)
(12,msg)
(13,END_WAIT)
(14,break;)
(15,rmonitor_inotify_add_watch(msg.data.s, msg.type == OPEN_OUTPUT)
(16,p->waiting)
(17,if(!rmonitor_check_limits(summary)
(18,summary->max_concurrent_processes)
(19,&msg)
(20,)
(21,D_DEBUG)
(22,max_concurrent_processes)
(23,itable_size(processes)
(24,msg)
(25,p->waiting = 1)
(26,msg)
(27,)
(28,msg.data.s)
(29,type)
(30,waiting)
(31,msg)
(32,)
(33,case END_WAIT:)
(34,data)
(35,return;)
(36,p)
(37,RET)
(38,!p)
(39,debug(D_DEBUG, "File %s has been opened.\\n", msg.data.s)
(40,if(summary->max_concurrent_processes < itable_size(processes)
(41,msg.type)
(42,msg.origin)
(43,debug(D_DEBUG,"message \\"%s\\" from %d\\n", str_msgtype(msg.type)
(44,itable_size(processes)
(45,data)
(46,case BRANCH:)
(47,recv_monitor_msg(rmonitor_queue_fd, &msg)
(48,p)
(49,msg.type)
(50,p)
(51,processes)
(52,release_waiting_process(msg.origin)
(53,msg.type == OPEN_OUTPUT)
(54,s)
(55,BRANCH)
(56,summary->max_concurrent_processes = itable_size(processes)
(57,case OPEN_OUTPUT:)
(58,switch(msg.error)
(59,type)
(60,p = itable_lookup(processes, (uint64_t)
(61,case END:)
(62,msg.type)
(63,break;)
(64,p->wd = lookup_or_create_wd(p->wd, msg.data.s)
(65,msg.origin)
(66,break;)
(67,return;)
(68,case EMFILE:)
(69,type)
(70,msg.data)
(71,break;)
(72,(uint64_t)
(73,msg)
(74,p->wd)
(75,p)
(76,msg)
(77,s)
(78,msg.type != BRANCH)
(79,case WRITE:)
(80,summary)
(81,D_DEBUG)
(82,wd)
(83,!rmonitor_check_limits(summary)
(84,break;)
(85,origin)
(86,rmonitor_final_cleanup(SIGTERM)
(87,msg.type == END_WAIT)
(88,"File %s has been opened.\\n")
(89,uint64_t)
(90,msg.type)
(91,msg.data)
(92,)
(93,summary)
(94,error)
(95,s)
(96,data)
(97,summary->max_concurrent_processes < itable_size(processes)
(98,1)
(99,origin)
(100,msg.data.s)
(101,msg)
(102,break;)
(103,SIGTERM)
(104,rmonitor_queue_fd)
(105,max_concurrent_processes)
(106,msg)
(107,break;)
(108,processes)
(109,msg.data)
(110,msg)
(111,break;)
(112,"message \\"%s\\" from %d\\n")
(113,p)
(114,summary->max_concurrent_processes)
(115,processes)
(116,msg)
(117,summary)
(118,msg)
(119,type)
(120,OPEN_OUTPUT)
(121,msg)
(122,msg.data.s)
(123,itable_lookup(processes, (uint64_t)
(124,type)
(125,msg.origin)
(126,break;)
(127,msg.data.p)
(128,str_msgtype(msg.type)
(129,p)
(130,case OPEN_INPUT:)
(131,msg)
(132,msg.type)
(133,wd)
(134,case READ:)
(135,msg.data)
(136,msg)
(137,default:)
(138,msg)
(139,p->wd)
(140,rmonitor_check_limits(summary)
(141,if( msg.type == END_WAIT )
(142,rmonitor_track_process(msg.origin)
(143,p)
(144,case CHDIR:)
(145,break;)
(146,msg)
(147,default:)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^