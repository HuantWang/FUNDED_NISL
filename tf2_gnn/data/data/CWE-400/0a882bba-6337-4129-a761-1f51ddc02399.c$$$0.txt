-----label-----
0
-----code-----
void rmonitor_dispatch_msg(void)
{
	struct rmonitor_msg msg;
	struct rmonitor_process_info *p;

	recv_monitor_msg(rmonitor_queue_fd, &msg);

	debug(D_DEBUG,"message \"%s\" from %d\n", str_msgtype(msg.type), msg.origin);

	p = itable_lookup(processes, (uint64_t) msg.origin);

	if(!p)
	{
		/* We either got a malformed message, message from a
		process we are not tracking anymore, or a message from
		a newly created process.  */
		if( msg.type == END_WAIT )
        {
			release_waiting_process(msg.origin);
			return;
        }
		else if(msg.type != BRANCH)
			return;
	}

    switch(msg.type)
    {
        case BRANCH:
            rmonitor_track_process(msg.origin);
            if(summary->max_concurrent_processes < itable_size(processes))
                summary->max_concurrent_processes = itable_size(processes);
            break;
        case END_WAIT:
            p->waiting = 1;
            break;
        case END:
            rmonitor_untrack_process(msg.data.p);
            break;
        case CHDIR:
            p->wd = lookup_or_create_wd(p->wd, msg.data.s);
            break;
        case OPEN_INPUT:
            debug(D_DEBUG, "File %s has been opened as input.\n", msg.data.s);
            rmonitor_add_file_watch(msg.data.s, 0);
            break;
        case OPEN_OUTPUT:
            debug(D_DEBUG, "File %s has been opened as output.\n", msg.data.s);
            rmonitor_add_file_watch(msg.data.s, 1);
            break;
        case READ:
            break;
        case WRITE:
            break;
        default:
            break;
    };

	if(!rmonitor_check_limits(summary))
		rmonitor_final_cleanup(SIGTERM);

}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
9,10
9,11
9,12
9,13
9,14
9,15
9,16
9,17
9,18
10,11
11,12
11,13
12,13
14,15
16,17
17,18
17,19
18,19
20,21
20,22
23,24
24,25
24,26
24,27
25,26
27,28
29,30
30,31
32,33
33,34
33,35
33,36
33,37
33,38
34,35
36,37
39,40
39,41
40,41
42,43
42,44
43,44
46,47
46,48
47,48
50,51
51,52
51,53
52,53
54,55
54,56
54,57
55,56
57,58
59,60
59,61
60,61
60,62
61,62
64,65
64,66
65,66
68,69
68,70
69,70
70,71
72,73
73,74
73,75
73,76
74,75
74,76
75,76
75,77
76,77
79,80
81,82
81,83
82,83
83,84
83,85
84,85
86,87
86,88
87,88
91,92
91,93
92,93
92,94
93,94
93,95
94,95
97,98
100,101
100,102
101,102
101,103
102,103
105,106
105,107
105,108
105,109
105,110
105,111
105,112
105,113
105,114
105,115
105,116
105,117
105,118
105,119
105,120
105,121
105,122
105,123
105,124
105,125
105,126
105,127
105,128
105,129
105,130
105,131
105,132
106,107
107,108
109,110
110,111
110,112
111,112
113,114
113,115
114,115
117,118
117,119
118,119
118,120
119,120
119,121
120,121
123,124
123,125
124,125
126,127
128,129
129,130
129,131
130,131
130,132
131,132
134,135
134,136
135,136
137,138
140,141
141,142
143,144
144,145
144,146
145,146
145,147
146,147
151,152
152,153
154,155
155,156
155,157
156,157
158,159
158,160
159,160
159,161
160,161
165,166
166,167
168,169
169,170
169,171
170,171
170,172
171,172
174,175
174,176
174,177
175,176
177,178
177,179
178,179
181,182
181,183
182,183
182,184
183,184
188,189
189,190
191,192
192,193
192,194
192,195
192,196
193,194
195,196
198,199
198,200
199,200
199,201
200,201
204,205
205,206
205,207
205,208
206,207
208,209
208,210
209,210
209,211
210,211
216,217
217,218
219,220
220,221
220,222
220,223
220,224
221,222
223,224
226,227
226,228
227,228
227,229
228,229
232,233
233,234
233,235
233,236
234,235
236,237
236,238
237,238
237,239
238,239
244,245
245,246
248,249
249,250
255,256
255,257
256,257
257,258
257,259
258,259
260,261
262,263
263,264
263,265
264,265
266,267
267,268
-----nextToken-----
2,4,6,8,13,15,19,21,22,26,28,31,35,37,38,41,44,45,48,49,53,56,58,62,63,66,67,71,77,78,80,85,88,89,90,95,96,98,99,103,104,108,112,115,116,121,122,125,127,132,133,136,138,139,142,147,148,149,150,153,157,161,162,163,164,167,172,173,176,179,180,184,185,186,187,190,194,196,197,201,202,203,207,211,212,213,214,215,218,222,224,225,229,230,231,235,239,240,241,242,243,246,247,250,251,252,253,254,259,261,265,268
-----computeFrom-----
51,52
51,53
74,75
74,76
92,93
92,94
118,119
118,120
129,130
129,131
144,145
144,146
169,170
169,171
-----guardedBy-----
77,88
121,132
127,138
122,133
125,136
-----guardedByNegation-----
77,95
78,96
-----lastLexicalUse-----
77,95
-----jump-----
77,95
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;BreakStatement;DefaultStatement;BreakStatement;NullStatement;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;
-----ast_node-----
void rmonitor_dispatch_msg(void){	struct rmonitor_msg msg;	struct rmonitor_process_info *p;	recv_monitor_msg(rmonitor_queue_fd, &msg);	debug(D_DEBUG,"message \"%s\" from %d\n", str_msgtype(msg.type), msg.origin);	p = itable_lookup(processes, (uint64_t) msg.origin);	if(!p)	{		/* We either got a malformed message, message from a		process we are not tracking anymore, or a message from		a newly created process.  */		if( msg.type == END_WAIT )        {			release_waiting_process(msg.origin);			return;        }		else if(msg.type != BRANCH)			return;	}    switch(msg.type)    {        case BRANCH:            rmonitor_track_process(msg.origin);            if(summary->max_concurrent_processes < itable_size(processes))                summary->max_concurrent_processes = itable_size(processes);            break;        case END_WAIT:            p->waiting = 1;            break;        case END:            rmonitor_untrack_process(msg.data.p);            break;        case CHDIR:            p->wd = lookup_or_create_wd(p->wd, msg.data.s);            break;        case OPEN_INPUT:            debug(D_DEBUG, "File %s has been opened as input.\n", msg.data.s);            rmonitor_add_file_watch(msg.data.s, 0);            break;        case OPEN_OUTPUT:            debug(D_DEBUG, "File %s has been opened as output.\n", msg.data.s);            rmonitor_add_file_watch(msg.data.s, 1);            break;        case READ:            break;        case WRITE:            break;        default:            break;    };	if(!rmonitor_check_limits(summary))		rmonitor_final_cleanup(SIGTERM);}
void
rmonitor_dispatch_msg(void)
rmonitor_dispatch_msg
void
void


{	struct rmonitor_msg msg;	struct rmonitor_process_info *p;	recv_monitor_msg(rmonitor_queue_fd, &msg);	debug(D_DEBUG,"message \"%s\" from %d\n", str_msgtype(msg.type), msg.origin);	p = itable_lookup(processes, (uint64_t) msg.origin);	if(!p)	{		/* We either got a malformed message, message from a		process we are not tracking anymore, or a message from		a newly created process.  */		if( msg.type == END_WAIT )        {			release_waiting_process(msg.origin);			return;        }		else if(msg.type != BRANCH)			return;	}    switch(msg.type)    {        case BRANCH:            rmonitor_track_process(msg.origin);            if(summary->max_concurrent_processes < itable_size(processes))                summary->max_concurrent_processes = itable_size(processes);            break;        case END_WAIT:            p->waiting = 1;            break;        case END:            rmonitor_untrack_process(msg.data.p);            break;        case CHDIR:            p->wd = lookup_or_create_wd(p->wd, msg.data.s);            break;        case OPEN_INPUT:            debug(D_DEBUG, "File %s has been opened as input.\n", msg.data.s);            rmonitor_add_file_watch(msg.data.s, 0);            break;        case OPEN_OUTPUT:            debug(D_DEBUG, "File %s has been opened as output.\n", msg.data.s);            rmonitor_add_file_watch(msg.data.s, 1);            break;        case READ:            break;        case WRITE:            break;        default:            break;    };	if(!rmonitor_check_limits(summary))		rmonitor_final_cleanup(SIGTERM);}
struct rmonitor_msg msg;
struct rmonitor_msg msg;
struct rmonitor_msg
rmonitor_msg
msg
msg
struct rmonitor_process_info *p;
struct rmonitor_process_info *p;
struct rmonitor_process_info
rmonitor_process_info
*p
*
p
recv_monitor_msg(rmonitor_queue_fd, &msg);
recv_monitor_msg(rmonitor_queue_fd, &msg)
recv_monitor_msg
recv_monitor_msg
rmonitor_queue_fd
rmonitor_queue_fd
&msg
msg
msg
debug(D_DEBUG,"message \"%s\" from %d\n", str_msgtype(msg.type), msg.origin);
debug(D_DEBUG,"message \"%s\" from %d\n", str_msgtype(msg.type), msg.origin)
debug
debug
D_DEBUG
D_DEBUG
"message \"%s\" from %d\n"
str_msgtype(msg.type)
str_msgtype
str_msgtype
msg.type
msg
msg
type
msg.origin
msg
msg
origin
p = itable_lookup(processes, (uint64_t) msg.origin);
p = itable_lookup(processes, (uint64_t) msg.origin)
p
p
itable_lookup(processes, (uint64_t) msg.origin)
itable_lookup
itable_lookup
processes
processes
(uint64_t) msg.origin
uint64_t
uint64_t
uint64_t

msg.origin
msg
msg
origin
if(!p)	{		/* We either got a malformed message, message from a		process we are not tracking anymore, or a message from		a newly created process.  */		if( msg.type == END_WAIT )        {			release_waiting_process(msg.origin);			return;        }		else if(msg.type != BRANCH)			return;	}
!p
p
p
{		/* We either got a malformed message, message from a		process we are not tracking anymore, or a message from		a newly created process.  */		if( msg.type == END_WAIT )        {			release_waiting_process(msg.origin);			return;        }		else if(msg.type != BRANCH)			return;	}
if( msg.type == END_WAIT )        {			release_waiting_process(msg.origin);			return;        }		else if(msg.type != BRANCH)			return;
msg.type == END_WAIT
msg.type
msg
msg
type
END_WAIT
END_WAIT
{			release_waiting_process(msg.origin);			return;        }
release_waiting_process(msg.origin);
release_waiting_process(msg.origin)
release_waiting_process
release_waiting_process
msg.origin
msg
msg
origin
return;
if(msg.type != BRANCH)			return;
msg.type != BRANCH
msg.type
msg
msg
type
BRANCH
BRANCH
return;
switch(msg.type)    {        case BRANCH:            rmonitor_track_process(msg.origin);            if(summary->max_concurrent_processes < itable_size(processes))                summary->max_concurrent_processes = itable_size(processes);            break;        case END_WAIT:            p->waiting = 1;            break;        case END:            rmonitor_untrack_process(msg.data.p);            break;        case CHDIR:            p->wd = lookup_or_create_wd(p->wd, msg.data.s);            break;        case OPEN_INPUT:            debug(D_DEBUG, "File %s has been opened as input.\n", msg.data.s);            rmonitor_add_file_watch(msg.data.s, 0);            break;        case OPEN_OUTPUT:            debug(D_DEBUG, "File %s has been opened as output.\n", msg.data.s);            rmonitor_add_file_watch(msg.data.s, 1);            break;        case READ:            break;        case WRITE:            break;        default:            break;    }
msg.type
msg
msg
type
{        case BRANCH:            rmonitor_track_process(msg.origin);            if(summary->max_concurrent_processes < itable_size(processes))                summary->max_concurrent_processes = itable_size(processes);            break;        case END_WAIT:            p->waiting = 1;            break;        case END:            rmonitor_untrack_process(msg.data.p);            break;        case CHDIR:            p->wd = lookup_or_create_wd(p->wd, msg.data.s);            break;        case OPEN_INPUT:            debug(D_DEBUG, "File %s has been opened as input.\n", msg.data.s);            rmonitor_add_file_watch(msg.data.s, 0);            break;        case OPEN_OUTPUT:            debug(D_DEBUG, "File %s has been opened as output.\n", msg.data.s);            rmonitor_add_file_watch(msg.data.s, 1);            break;        case READ:            break;        case WRITE:            break;        default:            break;    }
case BRANCH:
BRANCH
BRANCH
rmonitor_track_process(msg.origin);
rmonitor_track_process(msg.origin)
rmonitor_track_process
rmonitor_track_process
msg.origin
msg
msg
origin
if(summary->max_concurrent_processes < itable_size(processes))                summary->max_concurrent_processes = itable_size(processes);
summary->max_concurrent_processes < itable_size(processes)
summary->max_concurrent_processes
summary
summary
max_concurrent_processes
itable_size(processes)
itable_size
itable_size
processes
processes
summary->max_concurrent_processes = itable_size(processes);
summary->max_concurrent_processes = itable_size(processes)
summary->max_concurrent_processes
summary
summary
max_concurrent_processes
itable_size(processes)
itable_size
itable_size
processes
processes
break;
case END_WAIT:
END_WAIT
END_WAIT
p->waiting = 1;
p->waiting = 1
p->waiting
p
p
waiting
1
break;
case END:
END
END
rmonitor_untrack_process(msg.data.p);
rmonitor_untrack_process(msg.data.p)
rmonitor_untrack_process
rmonitor_untrack_process
msg.data.p
msg.data
msg
msg
data
p
break;
case CHDIR:
CHDIR
CHDIR
p->wd = lookup_or_create_wd(p->wd, msg.data.s);
p->wd = lookup_or_create_wd(p->wd, msg.data.s)
p->wd
p
p
wd
lookup_or_create_wd(p->wd, msg.data.s)
lookup_or_create_wd
lookup_or_create_wd
p->wd
p
p
wd
msg.data.s
msg.data
msg
msg
data
s
break;
case OPEN_INPUT:
OPEN_INPUT
OPEN_INPUT
debug(D_DEBUG, "File %s has been opened as input.\n", msg.data.s);
debug(D_DEBUG, "File %s has been opened as input.\n", msg.data.s)
debug
debug
D_DEBUG
D_DEBUG
"File %s has been opened as input.\n"
msg.data.s
msg.data
msg
msg
data
s
rmonitor_add_file_watch(msg.data.s, 0);
rmonitor_add_file_watch(msg.data.s, 0)
rmonitor_add_file_watch
rmonitor_add_file_watch
msg.data.s
msg.data
msg
msg
data
s
0
break;
case OPEN_OUTPUT:
OPEN_OUTPUT
OPEN_OUTPUT
debug(D_DEBUG, "File %s has been opened as output.\n", msg.data.s);
debug(D_DEBUG, "File %s has been opened as output.\n", msg.data.s)
debug
debug
D_DEBUG
D_DEBUG
"File %s has been opened as output.\n"
msg.data.s
msg.data
msg
msg
data
s
rmonitor_add_file_watch(msg.data.s, 1);
rmonitor_add_file_watch(msg.data.s, 1)
rmonitor_add_file_watch
rmonitor_add_file_watch
msg.data.s
msg.data
msg
msg
data
s
1
break;
case READ:
READ
READ
break;
case WRITE:
WRITE
WRITE
break;
default:
break;
;
if(!rmonitor_check_limits(summary))		rmonitor_final_cleanup(SIGTERM);
!rmonitor_check_limits(summary)
rmonitor_check_limits(summary)
rmonitor_check_limits
rmonitor_check_limits
summary
summary
rmonitor_final_cleanup(SIGTERM);
rmonitor_final_cleanup(SIGTERM);
rmonitor_final_cleanup
rmonitor_final_cleanup
(SIGTERM)
SIGTERM
SIGTERM
-----joern-----
(75,90,0)
(133,57,0)
(66,91,0)
(116,36,0)
(6,128,0)
(26,145,0)
(15,105,0)
(73,31,0)
(8,48,0)
(146,36,0)
(100,121,0)
(105,47,0)
(50,36,0)
(74,36,0)
(73,110,0)
(11,82,0)
(78,47,0)
(127,37,0)
(7,79,0)
(21,90,0)
(121,100,0)
(27,60,0)
(63,42,0)
(9,36,0)
(51,36,0)
(144,116,0)
(99,134,0)
(34,2,0)
(140,144,0)
(94,39,0)
(85,36,0)
(83,36,0)
(128,0,0)
(138,148,0)
(59,55,0)
(87,36,0)
(16,113,0)
(33,36,0)
(130,143,0)
(84,36,0)
(103,7,0)
(39,94,0)
(146,1,0)
(57,133,0)
(22,36,0)
(3,112,0)
(10,39,0)
(1,146,0)
(136,148,0)
(53,24,0)
(131,145,0)
(44,143,0)
(126,31,0)
(18,36,0)
(112,99,0)
(91,100,0)
(89,134,0)
(43,144,0)
(27,36,0)
(20,73,0)
(90,60,0)
(56,110,0)
(92,134,0)
(72,88,0)
(70,44,0)
(12,42,0)
(147,36,0)
(79,93,0)
(106,59,0)
(119,42,0)
(17,24,0)
(1,2,0)
(61,97,0)
(99,112,0)
(131,5,0)
(121,82,0)
(79,47,0)
(101,31,0)
(82,121,0)
(4,7,0)
(31,36,0)
(13,14,0)
(64,36,0)
(77,97,0)
(125,42,0)
(40,91,0)
(28,112,0)
(68,29,0)
(112,42,0)
(129,36,0)
(58,82,0)
(32,109,0)
(114,27,0)
(137,42,0)
(35,2,0)
(122,110,0)
(69,74,0)
(69,95,0)
(71,36,0)
(74,69,0)
(47,105,0)
(12,88,0)
(107,15,0)
(24,17,0)
(0,111,0)
(98,36,0)
(62,105,0)
(31,73,0)
(127,65,0)
(79,7,0)
(25,60,0)
(123,48,0)
(117,12,0)
(93,79,0)
(0,128,0)
(55,59,0)
(47,79,0)
(139,36,0)
(143,44,0)
(5,131,0)
(57,29,0)
(52,30,0)
(54,133,0)
(132,36,0)
(2,1,0)
(60,27,0)
(96,57,0)
(67,143,0)
(45,95,0)
(97,112,0)
(120,42,0)
(100,64,0)
(17,36,0)
(64,100,0)
(38,113,0)
(41,121,0)
(112,97,0)
(108,133,0)
(19,55,0)
(144,105,0)
(115,95,0)
(105,42,0)
(110,73,0)
(37,111,0)
(91,105,0)
(49,1,0)
(29,57,0)
(81,36,0)
(124,145,0)
(145,131,0)
(100,91,0)
(23,109,0)
(142,116,0)
(134,99,0)
(86,69,0)
(95,69,0)
(80,24,0)
(60,90,0)
(104,74,0)
(102,55,0)
(141,5,0)
(148,138,0)
(76,36,0)
(46,27,0)
(29,36,0)
(48,138,0)
(135,36,0)
(88,12,0)
(109,105,0)
(118,128,0)
(109,64,0)
(83,113,1)
(85,29,1)
(19,15,1)
(127,65,1)
(60,25,1)
(48,123,1)
(28,12,1)
(123,8,1)
(131,145,1)
(130,59,1)
(138,148,1)
(112,97,1)
(47,79,1)
(17,24,1)
(10,98,1)
(107,105,1)
(116,142,1)
(112,99,1)
(39,10,1)
(103,4,1)
(144,105,1)
(1,2,1)
(124,17,1)
(121,82,1)
(34,113,1)
(74,104,1)
(113,16,1)
(73,110,1)
(69,86,1)
(133,108,1)
(129,113,1)
(10,132,1)
(91,66,1)
(121,41,1)
(142,144,1)
(148,136,1)
(82,11,1)
(37,0,1)
(49,2,1)
(139,146,1)
(68,57,1)
(131,5,1)
(100,121,1)
(2,35,1)
(75,21,1)
(59,106,1)
(12,88,1)
(118,6,1)
(100,91,1)
(10,129,1)
(109,105,1)
(64,100,1)
(61,99,1)
(88,72,1)
(72,117,1)
(145,26,1)
(26,124,1)
(105,47,1)
(27,60,1)
(0,128,1)
(52,94,1)
(54,31,1)
(73,20,1)
(71,131,1)
(43,140,1)
(114,46,1)
(38,44,1)
(146,1,1)
(31,73,1)
(144,43,1)
(90,75,1)
(102,19,1)
(11,58,1)
(108,54,1)
(101,126,1)
(66,40,1)
(110,122,1)
(15,107,1)
(25,90,1)
(65,44,1)
(40,109,1)
(96,133,1)
(7,103,1)
(106,55,1)
(29,57,1)
(1,49,1)
(141,145,1)
(60,90,1)
(79,7,1)
(132,113,1)
(53,80,1)
(143,67,1)
(122,56,1)
(44,143,1)
(128,118,1)
(10,83,1)
(24,53,1)
(10,18,1)
(58,91,1)
(10,50,1)
(71,138,1)
(67,130,1)
(140,113,1)
(77,61,1)
(62,112,1)
(35,34,1)
(5,141,1)
(95,115,1)
(127,30,1)
(15,105,1)
(16,38,1)
(99,134,1)
(78,62,1)
(57,96,1)
(115,45,1)
(10,85,1)
(44,70,1)
(98,116,1)
(97,77,1)
(10,71,1)
(91,105,1)
(57,133,1)
(32,23,1)
(104,69,1)
(126,113,1)
(21,114,1)
(56,101,1)
(41,82,1)
(59,55,1)
(30,52,1)
(50,64,1)
(3,28,1)
(69,95,1)
(94,39,1)
(136,48,1)
(23,113,1)
(29,68,1)
(10,139,1)
(38,15,1)
(46,113,1)
(79,93,1)
(70,143,1)
(20,110,1)
(86,95,1)
(45,27,1)
(55,102,1)
(109,32,1)
(6,59,1)
(8,131,1)
(127,37,1)
(4,78,1)
(18,74,1)
(89,92,1)
(127,94,1)
(134,89,1)
(74,69,1)
(92,3,1)
(80,113,1)
(38,15,2)
(106,15,2)
(10,44,2)
(58,113,2)
(31,73,2)
(136,131,2)
(10,15,2)
(59,55,2)
(130,59,2)
(129,113,2)
(86,113,2)
(39,44,2)
(15,105,2)
(91,105,2)
(29,57,2)
(139,113,2)
(41,113,2)
(26,113,2)
(47,79,2)
(100,91,2)
(73,110,2)
(99,134,2)
(124,113,2)
(73,113,2)
(102,15,2)
(74,113,2)
(64,113,2)
(126,113,2)
(79,7,2)
(46,113,2)
(48,131,2)
(127,37,2)
(112,97,2)
(131,5,2)
(100,113,2)
(6,59,2)
(98,113,2)
(105,47,2)
(34,113,2)
(91,113,2)
(1,113,2)
(19,15,2)
(74,69,2)
(12,88,2)
(143,59,2)
(20,113,2)
(133,113,2)
(66,113,2)
(50,113,2)
(29,113,2)
(96,113,2)
(45,113,2)
(60,113,2)
(148,131,2)
(112,99,2)
(95,113,2)
(67,59,2)
(75,113,2)
(131,113,2)
(30,94,2)
(27,60,2)
(121,113,2)
(100,121,2)
(82,113,2)
(104,113,2)
(11,113,2)
(115,113,2)
(138,131,2)
(113,15,2)
(131,145,2)
(16,44,2)
(109,105,2)
(108,113,2)
(122,113,2)
(16,15,2)
(80,113,2)
(116,113,2)
(27,113,2)
(144,113,2)
(94,44,2)
(145,113,2)
(59,15,2)
(128,59,2)
(57,133,2)
(90,113,2)
(37,59,2)
(132,113,2)
(32,113,2)
(121,82,2)
(25,113,2)
(64,100,2)
(68,113,2)
(44,143,2)
(54,113,2)
(70,59,2)
(55,15,2)
(114,113,2)
(60,90,2)
(31,113,2)
(141,113,2)
(83,113,2)
(94,15,2)
(17,24,2)
(1,2,2)
(40,113,2)
(79,93,2)
(0,128,2)
(21,113,2)
(35,113,2)
(49,113,2)
(146,113,2)
(24,113,2)
(69,95,2)
(8,131,2)
(17,113,2)
(56,113,2)
(52,94,2)
(94,39,2)
(44,59,2)
(142,113,2)
(18,113,2)
(23,113,2)
(0,59,2)
(118,59,2)
(127,65,2)
(2,113,2)
(109,113,2)
(38,44,2)
(146,1,2)
(71,113,2)
(140,113,2)
(113,44,2)
(39,15,2)
(65,44,2)
(144,105,2)
(5,113,2)
(123,131,2)
(53,113,2)
(138,148,2)
(57,113,2)
(43,113,2)
(110,113,2)
(69,113,2)
(101,113,2)
(85,113,2)
-----------------------------------
(0,release_waiting_process(msg.origin)
(1,msg.data.p)
(2,msg.data)
(3,"message \\"%s\\" from %d\\n")
(4,msg)
(5,itable_size(processes)
(6,msg)
(7,msg.origin)
(8,summary)
(9,case READ:)
(10,summary)
(11,data)
(12,recv_monitor_msg(rmonitor_queue_fd, &msg)
(13,if( msg.type == END_WAIT )
(14,)
(15,!p)
(16,type)
(17,rmonitor_track_process(msg.origin)
(18,break;)
(19,msg)
(20,s)
(21,msg)
(22,if(summary->max_concurrent_processes < itable_size(processes)
(23,p)
(24,msg.origin)
(25,s)
(26,max_concurrent_processes)
(27,debug(D_DEBUG, "File %s has been opened as output.\\n", msg.data.s)
(28,D_DEBUG)
(29,rmonitor_add_file_watch(msg.data.s, 0)
(30,rmonitor_final_cleanup(SIGTERM)
(31,debug(D_DEBUG, "File %s has been opened as input.\\n", msg.data.s)
(32,wd)
(33,case CHDIR:)
(34,msg)
(35,data)
(36,)
(37,return;)
(38,msg)
(39,rmonitor_check_limits(summary)
(40,p)
(41,s)
(42,)
(43,waiting)
(44,msg.type != BRANCH)
(45,msg)
(46,D_DEBUG)
(47,itable_lookup(processes, (uint64_t)
(48,summary->max_concurrent_processes)
(49,p)
(50,break;)
(51,case OPEN_OUTPUT:)
(52,SIGTERM)
(53,origin)
(54,msg)
(55,msg.type)
(56,msg)
(57,msg.data.s)
(58,msg)
(59,msg.type == END_WAIT)
(60,msg.data.s)
(61,msg)
(62,p)
(63,switch(msg.type)
(64,p->wd = lookup_or_create_wd(p->wd, msg.data.s)
(65,return;)
(66,wd)
(67,type)
(68,0)
(69,msg.data.s)
(70,BRANCH)
(71,break;)
(72,msg)
(73,msg.data.s)
(74,rmonitor_add_file_watch(msg.data.s, 1)
(75,data)
(76,case END:)
(77,origin)
(78,processes)
(79,(uint64_t)
(80,msg)
(81,case WRITE:)
(82,msg.data)
(83,break;)
(84,case OPEN_INPUT:)
(85,break;)
(86,s)
(87,default:)
(88,&msg)
(89,type)
(90,msg.data)
(91,p->wd)
(92,msg)
(93,uint64_t)
(94,!rmonitor_check_limits(summary)
(95,msg.data)
(96,s)
(97,msg.origin)
(98,break;)
(99,str_msgtype(msg.type)
(100,lookup_or_create_wd(p->wd, msg.data.s)
(101,"File %s has been opened as input.\\n")
(102,type)
(103,origin)
(104,1)
(105,p = itable_lookup(processes, (uint64_t)
(106,END_WAIT)
(107,p)
(108,data)
(109,p->wd)
(110,msg.data)
(111,)
(112,debug(D_DEBUG,"message \\"%s\\" from %d\\n", str_msgtype(msg.type)
(113,msg.type)
(114,"File %s has been opened as output.\\n")
(115,data)
(116,p->waiting = 1)
(117,rmonitor_queue_fd)
(118,origin)
(119,p)
(120,if(!p)
(121,msg.data.s)
(122,data)
(123,max_concurrent_processes)
(124,summary)
(125,msg)
(126,D_DEBUG)
(127,RET)
(128,msg.origin)
(129,break;)
(130,msg)
(131,summary->max_concurrent_processes < itable_size(processes)
(132,break;)
(133,msg.data)
(134,msg.type)
(135,case END_WAIT:)
(136,processes)
(137,if(!rmonitor_check_limits(summary)
(138,summary->max_concurrent_processes = itable_size(processes)
(139,break;)
(140,p)
(141,processes)
(142,1)
(143,msg.type)
(144,p->waiting)
(145,summary->max_concurrent_processes)
(146,rmonitor_untrack_process(msg.data.p)
(147,case BRANCH:)
(148,itable_size(processes)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^