-----label-----
0
-----code-----
void rmonitor_dispatch_msg(void)
{
	struct rmonitor_msg msg;
	struct rmonitor_process_info *p;

	recv_monitor_msg(rmonitor_queue_fd, &msg);

	debug(D_DEBUG,"message \"%s\" from %d\n", str_msgtype(msg.type), msg.origin);

	p = itable_lookup(processes, (uint64_t) msg.origin);

	if(!p)
	{
		/* We either got a malformed message, message from a
		process we are not tracking anymore, or a message from
		a newly created process.  */
		if( msg.type == END_WAIT )
        {
			release_waiting_process(msg.origin);
			return;
        }
		else if(msg.type != BRANCH)
			return;
	}

    switch(msg.type)
    {
        case BRANCH:
            rmonitor_track_process(msg.origin);
            if(summary->max_concurrent_processes < itable_size(processes))
                summary->max_concurrent_processes = itable_size(processes);
            break;
        case END_WAIT:
            p->waiting = 1;
            break;
        case END:
            rmonitor_untrack_process(msg.data.p);
            break;
        case CHDIR:
            p->wd = lookup_or_create_wd(p->wd, msg.data.s);
            break;
		case OPEN_INPUT:
		case OPEN_OUTPUT:
			switch(msg.error) {
				case 0:
					debug(D_DEBUG, "File %s has been opened.\n", msg.data.s);
					rmonitor_add_file_watch(msg.data.s, msg.type == OPEN_OUTPUT);
					break;
				case EMFILE:
					/* Eventually report that we ran out of file descriptors. */
					debug(D_DEBUG, "Process %d ran out of file descriptors.\n", msg.origin);
					break;
				default:
					/* Clear the error, as it is not related to resources. */
					msg.error = 0;
					break;
			}
			break;
        case READ:
            break;
        case WRITE:
			switch(msg.error) {
				case ENOSPC:
					/* Eventually report that we ran out of space. */
					debug(D_DEBUG, "Process %d ran out of disk space.\n", msg.origin);
					break;
				default:
					/* Clear the error, as it is not related to resources. */
					msg.error = 0;
					break;
			}
            break;
        default:
            break;
    };

	summary->last_error = msg.error;

	if(!rmonitor_check_limits(summary))
		rmonitor_final_cleanup(SIGTERM);

}
-----children-----
1,2
1,3
1,4
3,4
3,5
5,6
5,7
7,8
9,10
9,11
9,12
9,13
9,14
9,15
9,16
9,17
9,18
9,19
10,11
11,12
11,13
12,13
14,15
16,17
17,18
17,19
18,19
20,21
20,22
23,24
24,25
24,26
24,27
25,26
27,28
29,30
30,31
32,33
33,34
33,35
33,36
33,37
33,38
34,35
36,37
39,40
39,41
40,41
42,43
42,44
43,44
46,47
46,48
47,48
50,51
51,52
51,53
52,53
54,55
54,56
54,57
55,56
57,58
59,60
59,61
60,61
60,62
61,62
64,65
64,66
65,66
68,69
68,70
69,70
70,71
72,73
73,74
73,75
73,76
74,75
74,76
75,76
75,77
76,77
79,80
81,82
81,83
82,83
83,84
83,85
84,85
86,87
86,88
87,88
91,92
91,93
92,93
92,94
93,94
93,95
94,95
97,98
100,101
100,102
101,102
101,103
102,103
105,106
105,107
105,108
105,109
105,110
105,111
105,112
105,113
105,114
105,115
105,116
105,117
105,118
105,119
105,120
105,121
105,122
105,123
105,124
105,125
105,126
105,127
105,128
105,129
106,107
107,108
109,110
110,111
110,112
111,112
113,114
113,115
114,115
117,118
117,119
118,119
118,120
119,120
119,121
120,121
123,124
123,125
124,125
126,127
128,129
129,130
129,131
130,131
130,132
131,132
134,135
134,136
135,136
137,138
140,141
141,142
143,144
144,145
144,146
145,146
145,147
146,147
151,152
152,153
154,155
155,156
155,157
156,157
158,159
158,160
159,160
159,161
160,161
165,166
166,167
168,169
169,170
169,171
170,171
170,172
171,172
174,175
174,176
174,177
175,176
177,178
177,179
178,179
181,182
181,183
182,183
182,184
183,184
188,189
189,190
191,192
192,193
194,195
194,196
195,196
195,197
196,197
199,200
199,201
199,202
199,203
199,204
199,205
199,206
199,207
199,208
199,209
200,201
202,203
203,204
203,205
203,206
203,207
204,205
206,207
209,210
209,211
210,211
210,212
211,212
215,216
216,217
216,218
216,219
217,218
219,220
219,221
220,221
220,222
221,222
225,226
225,227
226,227
226,228
227,228
230,231
233,234
234,235
236,237
237,238
237,239
237,240
237,241
238,239
240,241
243,244
243,245
244,245
249,250
250,251
250,252
251,252
251,253
252,253
258,259
259,260
262,263
263,264
265,266
265,267
266,267
266,268
267,268
270,271
270,272
270,273
270,274
270,275
270,276
271,272
272,273
274,275
275,276
275,277
275,278
275,279
276,277
278,279
281,282
281,283
282,283
287,288
288,289
288,290
289,290
289,291
290,291
299,300
300,301
300,302
301,302
301,303
302,303
305,306
305,307
306,307
309,310
309,311
310,311
311,312
311,313
312,313
314,315
316,317
317,318
317,319
318,319
320,321
321,322
-----nextToken-----
2,4,6,8,13,15,19,21,22,26,28,31,35,37,38,41,44,45,48,49,53,56,58,62,63,66,67,71,77,78,80,85,88,89,90,95,96,98,99,103,104,108,112,115,116,121,122,125,127,132,133,136,138,139,142,147,148,149,150,153,157,161,162,163,164,167,172,173,176,179,180,184,185,186,187,190,193,197,198,201,205,207,208,212,213,214,218,222,223,224,228,229,231,232,235,239,241,242,245,246,247,248,253,254,255,256,257,260,261,264,268,269,273,277,279,280,283,284,285,286,291,292,293,294,295,296,297,298,303,304,307,308,313,315,319,322
-----computeFrom-----
51,52
51,53
74,75
74,76
92,93
92,94
118,119
118,120
129,130
129,131
144,145
144,146
169,170
169,171
225,226
225,227
250,251
250,252
288,289
288,290
300,301
300,302
-----guardedBy-----
77,88
121,132
127,138
122,133
125,136
-----guardedByNegation-----
77,95
78,96
-----lastLexicalUse-----
77,95
-----jump-----
77,95
-----attribute-----
FunctionDefinition;SimpleDeclSpecifier;FunctionDeclarator;Name;ParameterDeclaration;SimpleDeclSpecifier;Declarator;Name;CompoundStatement;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Name;DeclarationStatement;SimpleDeclaration;ElaboratedTypeSpecifier;Name;Declarator;Pointer;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;UnaryExpression;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;ExpressionStatement;BinaryExpression;IdExpression;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;CastExpression;TypeId;NamedTypeSpecifier;Name;Declarator;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;IdExpression;Name;CompoundStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;CompoundStatement;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;ReturnStatement;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;ReturnStatement;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;IfStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FunctionCallExpression;IdExpression;Name;FieldReference;IdExpression;Name;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;BreakStatement;CaseStatement;IdExpression;Name;CaseStatement;IdExpression;Name;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;LiteralExpression;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;FieldReference;IdExpression;Name;Name;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;FieldReference;FieldReference;IdExpression;Name;Name;Name;BinaryExpression;FieldReference;IdExpression;Name;Name;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;BreakStatement;DefaultStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;BreakStatement;BreakStatement;CaseStatement;IdExpression;Name;BreakStatement;CaseStatement;IdExpression;Name;SwitchStatement;FieldReference;IdExpression;Name;Name;CompoundStatement;CaseStatement;IdExpression;Name;ExpressionStatement;FunctionCallExpression;IdExpression;Name;IdExpression;Name;LiteralExpression;FieldReference;IdExpression;Name;Name;BreakStatement;DefaultStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;LiteralExpression;BreakStatement;BreakStatement;DefaultStatement;BreakStatement;NullStatement;ExpressionStatement;BinaryExpression;FieldReference;IdExpression;Name;Name;FieldReference;IdExpression;Name;Name;IfStatement;UnaryExpression;FunctionCallExpression;IdExpression;Name;IdExpression;Name;DeclarationStatement;SimpleDeclaration;NamedTypeSpecifier;Name;Declarator;Declarator;Name;
-----ast_node-----
void rmonitor_dispatch_msg(void){	struct rmonitor_msg msg;	struct rmonitor_process_info *p;	recv_monitor_msg(rmonitor_queue_fd, &msg);	debug(D_DEBUG,"message \"%s\" from %d\n", str_msgtype(msg.type), msg.origin);	p = itable_lookup(processes, (uint64_t) msg.origin);	if(!p)	{		/* We either got a malformed message, message from a		process we are not tracking anymore, or a message from		a newly created process.  */		if( msg.type == END_WAIT )        {			release_waiting_process(msg.origin);			return;        }		else if(msg.type != BRANCH)			return;	}    switch(msg.type)    {        case BRANCH:            rmonitor_track_process(msg.origin);            if(summary->max_concurrent_processes < itable_size(processes))                summary->max_concurrent_processes = itable_size(processes);            break;        case END_WAIT:            p->waiting = 1;            break;        case END:            rmonitor_untrack_process(msg.data.p);            break;        case CHDIR:            p->wd = lookup_or_create_wd(p->wd, msg.data.s);            break;		case OPEN_INPUT:		case OPEN_OUTPUT:			switch(msg.error) {				case 0:					debug(D_DEBUG, "File %s has been opened.\n", msg.data.s);					rmonitor_add_file_watch(msg.data.s, msg.type == OPEN_OUTPUT);					break;				case EMFILE:					/* Eventually report that we ran out of file descriptors. */					debug(D_DEBUG, "Process %d ran out of file descriptors.\n", msg.origin);					break;				default:					/* Clear the error, as it is not related to resources. */					msg.error = 0;					break;			}			break;        case READ:            break;        case WRITE:			switch(msg.error) {				case ENOSPC:					/* Eventually report that we ran out of space. */					debug(D_DEBUG, "Process %d ran out of disk space.\n", msg.origin);					break;				default:					/* Clear the error, as it is not related to resources. */					msg.error = 0;					break;			}            break;        default:            break;    };	summary->last_error = msg.error;	if(!rmonitor_check_limits(summary))		rmonitor_final_cleanup(SIGTERM);}
void
rmonitor_dispatch_msg(void)
rmonitor_dispatch_msg
void
void


{	struct rmonitor_msg msg;	struct rmonitor_process_info *p;	recv_monitor_msg(rmonitor_queue_fd, &msg);	debug(D_DEBUG,"message \"%s\" from %d\n", str_msgtype(msg.type), msg.origin);	p = itable_lookup(processes, (uint64_t) msg.origin);	if(!p)	{		/* We either got a malformed message, message from a		process we are not tracking anymore, or a message from		a newly created process.  */		if( msg.type == END_WAIT )        {			release_waiting_process(msg.origin);			return;        }		else if(msg.type != BRANCH)			return;	}    switch(msg.type)    {        case BRANCH:            rmonitor_track_process(msg.origin);            if(summary->max_concurrent_processes < itable_size(processes))                summary->max_concurrent_processes = itable_size(processes);            break;        case END_WAIT:            p->waiting = 1;            break;        case END:            rmonitor_untrack_process(msg.data.p);            break;        case CHDIR:            p->wd = lookup_or_create_wd(p->wd, msg.data.s);            break;		case OPEN_INPUT:		case OPEN_OUTPUT:			switch(msg.error) {				case 0:					debug(D_DEBUG, "File %s has been opened.\n", msg.data.s);					rmonitor_add_file_watch(msg.data.s, msg.type == OPEN_OUTPUT);					break;				case EMFILE:					/* Eventually report that we ran out of file descriptors. */					debug(D_DEBUG, "Process %d ran out of file descriptors.\n", msg.origin);					break;				default:					/* Clear the error, as it is not related to resources. */					msg.error = 0;					break;			}			break;        case READ:            break;        case WRITE:			switch(msg.error) {				case ENOSPC:					/* Eventually report that we ran out of space. */					debug(D_DEBUG, "Process %d ran out of disk space.\n", msg.origin);					break;				default:					/* Clear the error, as it is not related to resources. */					msg.error = 0;					break;			}            break;        default:            break;    };	summary->last_error = msg.error;	if(!rmonitor_check_limits(summary))		rmonitor_final_cleanup(SIGTERM);}
struct rmonitor_msg msg;
struct rmonitor_msg msg;
struct rmonitor_msg
rmonitor_msg
msg
msg
struct rmonitor_process_info *p;
struct rmonitor_process_info *p;
struct rmonitor_process_info
rmonitor_process_info
*p
*
p
recv_monitor_msg(rmonitor_queue_fd, &msg);
recv_monitor_msg(rmonitor_queue_fd, &msg)
recv_monitor_msg
recv_monitor_msg
rmonitor_queue_fd
rmonitor_queue_fd
&msg
msg
msg
debug(D_DEBUG,"message \"%s\" from %d\n", str_msgtype(msg.type), msg.origin);
debug(D_DEBUG,"message \"%s\" from %d\n", str_msgtype(msg.type), msg.origin)
debug
debug
D_DEBUG
D_DEBUG
"message \"%s\" from %d\n"
str_msgtype(msg.type)
str_msgtype
str_msgtype
msg.type
msg
msg
type
msg.origin
msg
msg
origin
p = itable_lookup(processes, (uint64_t) msg.origin);
p = itable_lookup(processes, (uint64_t) msg.origin)
p
p
itable_lookup(processes, (uint64_t) msg.origin)
itable_lookup
itable_lookup
processes
processes
(uint64_t) msg.origin
uint64_t
uint64_t
uint64_t

msg.origin
msg
msg
origin
if(!p)	{		/* We either got a malformed message, message from a		process we are not tracking anymore, or a message from		a newly created process.  */		if( msg.type == END_WAIT )        {			release_waiting_process(msg.origin);			return;        }		else if(msg.type != BRANCH)			return;	}
!p
p
p
{		/* We either got a malformed message, message from a		process we are not tracking anymore, or a message from		a newly created process.  */		if( msg.type == END_WAIT )        {			release_waiting_process(msg.origin);			return;        }		else if(msg.type != BRANCH)			return;	}
if( msg.type == END_WAIT )        {			release_waiting_process(msg.origin);			return;        }		else if(msg.type != BRANCH)			return;
msg.type == END_WAIT
msg.type
msg
msg
type
END_WAIT
END_WAIT
{			release_waiting_process(msg.origin);			return;        }
release_waiting_process(msg.origin);
release_waiting_process(msg.origin)
release_waiting_process
release_waiting_process
msg.origin
msg
msg
origin
return;
if(msg.type != BRANCH)			return;
msg.type != BRANCH
msg.type
msg
msg
type
BRANCH
BRANCH
return;
switch(msg.type)    {        case BRANCH:            rmonitor_track_process(msg.origin);            if(summary->max_concurrent_processes < itable_size(processes))                summary->max_concurrent_processes = itable_size(processes);            break;        case END_WAIT:            p->waiting = 1;            break;        case END:            rmonitor_untrack_process(msg.data.p);            break;        case CHDIR:            p->wd = lookup_or_create_wd(p->wd, msg.data.s);            break;		case OPEN_INPUT:		case OPEN_OUTPUT:			switch(msg.error) {				case 0:					debug(D_DEBUG, "File %s has been opened.\n", msg.data.s);					rmonitor_add_file_watch(msg.data.s, msg.type == OPEN_OUTPUT);					break;				case EMFILE:					/* Eventually report that we ran out of file descriptors. */					debug(D_DEBUG, "Process %d ran out of file descriptors.\n", msg.origin);					break;				default:					/* Clear the error, as it is not related to resources. */					msg.error = 0;					break;			}			break;        case READ:            break;        case WRITE:			switch(msg.error) {				case ENOSPC:					/* Eventually report that we ran out of space. */					debug(D_DEBUG, "Process %d ran out of disk space.\n", msg.origin);					break;				default:					/* Clear the error, as it is not related to resources. */					msg.error = 0;					break;			}            break;        default:            break;    }
msg.type
msg
msg
type
{        case BRANCH:            rmonitor_track_process(msg.origin);            if(summary->max_concurrent_processes < itable_size(processes))                summary->max_concurrent_processes = itable_size(processes);            break;        case END_WAIT:            p->waiting = 1;            break;        case END:            rmonitor_untrack_process(msg.data.p);            break;        case CHDIR:            p->wd = lookup_or_create_wd(p->wd, msg.data.s);            break;		case OPEN_INPUT:		case OPEN_OUTPUT:			switch(msg.error) {				case 0:					debug(D_DEBUG, "File %s has been opened.\n", msg.data.s);					rmonitor_add_file_watch(msg.data.s, msg.type == OPEN_OUTPUT);					break;				case EMFILE:					/* Eventually report that we ran out of file descriptors. */					debug(D_DEBUG, "Process %d ran out of file descriptors.\n", msg.origin);					break;				default:					/* Clear the error, as it is not related to resources. */					msg.error = 0;					break;			}			break;        case READ:            break;        case WRITE:			switch(msg.error) {				case ENOSPC:					/* Eventually report that we ran out of space. */					debug(D_DEBUG, "Process %d ran out of disk space.\n", msg.origin);					break;				default:					/* Clear the error, as it is not related to resources. */					msg.error = 0;					break;			}            break;        default:            break;    }
case BRANCH:
BRANCH
BRANCH
rmonitor_track_process(msg.origin);
rmonitor_track_process(msg.origin)
rmonitor_track_process
rmonitor_track_process
msg.origin
msg
msg
origin
if(summary->max_concurrent_processes < itable_size(processes))                summary->max_concurrent_processes = itable_size(processes);
summary->max_concurrent_processes < itable_size(processes)
summary->max_concurrent_processes
summary
summary
max_concurrent_processes
itable_size(processes)
itable_size
itable_size
processes
processes
summary->max_concurrent_processes = itable_size(processes);
summary->max_concurrent_processes = itable_size(processes)
summary->max_concurrent_processes
summary
summary
max_concurrent_processes
itable_size(processes)
itable_size
itable_size
processes
processes
break;
case END_WAIT:
END_WAIT
END_WAIT
p->waiting = 1;
p->waiting = 1
p->waiting
p
p
waiting
1
break;
case END:
END
END
rmonitor_untrack_process(msg.data.p);
rmonitor_untrack_process(msg.data.p)
rmonitor_untrack_process
rmonitor_untrack_process
msg.data.p
msg.data
msg
msg
data
p
break;
case CHDIR:
CHDIR
CHDIR
p->wd = lookup_or_create_wd(p->wd, msg.data.s);
p->wd = lookup_or_create_wd(p->wd, msg.data.s)
p->wd
p
p
wd
lookup_or_create_wd(p->wd, msg.data.s)
lookup_or_create_wd
lookup_or_create_wd
p->wd
p
p
wd
msg.data.s
msg.data
msg
msg
data
s
break;
case OPEN_INPUT:
OPEN_INPUT
OPEN_INPUT
case OPEN_OUTPUT:
OPEN_OUTPUT
OPEN_OUTPUT
switch(msg.error) {				case 0:					debug(D_DEBUG, "File %s has been opened.\n", msg.data.s);					rmonitor_add_file_watch(msg.data.s, msg.type == OPEN_OUTPUT);					break;				case EMFILE:					/* Eventually report that we ran out of file descriptors. */					debug(D_DEBUG, "Process %d ran out of file descriptors.\n", msg.origin);					break;				default:					/* Clear the error, as it is not related to resources. */					msg.error = 0;					break;			}
msg.error
msg
msg
error
{				case 0:					debug(D_DEBUG, "File %s has been opened.\n", msg.data.s);					rmonitor_add_file_watch(msg.data.s, msg.type == OPEN_OUTPUT);					break;				case EMFILE:					/* Eventually report that we ran out of file descriptors. */					debug(D_DEBUG, "Process %d ran out of file descriptors.\n", msg.origin);					break;				default:					/* Clear the error, as it is not related to resources. */					msg.error = 0;					break;			}
case 0:
0
debug(D_DEBUG, "File %s has been opened.\n", msg.data.s);
debug(D_DEBUG, "File %s has been opened.\n", msg.data.s)
debug
debug
D_DEBUG
D_DEBUG
"File %s has been opened.\n"
msg.data.s
msg.data
msg
msg
data
s
rmonitor_add_file_watch(msg.data.s, msg.type == OPEN_OUTPUT);
rmonitor_add_file_watch(msg.data.s, msg.type == OPEN_OUTPUT)
rmonitor_add_file_watch
rmonitor_add_file_watch
msg.data.s
msg.data
msg
msg
data
s
msg.type == OPEN_OUTPUT
msg.type
msg
msg
type
OPEN_OUTPUT
OPEN_OUTPUT
break;
case EMFILE:
EMFILE
EMFILE
debug(D_DEBUG, "Process %d ran out of file descriptors.\n", msg.origin);
debug(D_DEBUG, "Process %d ran out of file descriptors.\n", msg.origin)
debug
debug
D_DEBUG
D_DEBUG
"Process %d ran out of file descriptors.\n"
msg.origin
msg
msg
origin
break;
default:
msg.error = 0;
msg.error = 0
msg.error
msg
msg
error
0
break;
break;
case READ:
READ
READ
break;
case WRITE:
WRITE
WRITE
switch(msg.error) {				case ENOSPC:					/* Eventually report that we ran out of space. */					debug(D_DEBUG, "Process %d ran out of disk space.\n", msg.origin);					break;				default:					/* Clear the error, as it is not related to resources. */					msg.error = 0;					break;			}
msg.error
msg
msg
error
{				case ENOSPC:					/* Eventually report that we ran out of space. */					debug(D_DEBUG, "Process %d ran out of disk space.\n", msg.origin);					break;				default:					/* Clear the error, as it is not related to resources. */					msg.error = 0;					break;			}
case ENOSPC:
ENOSPC
ENOSPC
debug(D_DEBUG, "Process %d ran out of disk space.\n", msg.origin);
debug(D_DEBUG, "Process %d ran out of disk space.\n", msg.origin)
debug
debug
D_DEBUG
D_DEBUG
"Process %d ran out of disk space.\n"
msg.origin
msg
msg
origin
break;
default:
msg.error = 0;
msg.error = 0
msg.error
msg
msg
error
0
break;
break;
default:
break;
;
summary->last_error = msg.error;
summary->last_error = msg.error
summary->last_error
summary
summary
last_error
msg.error
msg
msg
error
if(!rmonitor_check_limits(summary))		rmonitor_final_cleanup(SIGTERM);
!rmonitor_check_limits(summary)
rmonitor_check_limits(summary)
rmonitor_check_limits
rmonitor_check_limits
summary
summary
rmonitor_final_cleanup(SIGTERM);
rmonitor_final_cleanup(SIGTERM);
rmonitor_final_cleanup
rmonitor_final_cleanup
(SIGTERM)
SIGTERM
SIGTERM
-----joern-----
(118,122,0)
(155,65,0)
(165,29,0)
(108,29,0)
(133,21,0)
(149,33,0)
(1,163,0)
(11,173,0)
(141,50,0)
(47,173,0)
(100,71,0)
(116,0,0)
(70,141,0)
(107,174,0)
(88,87,0)
(64,29,0)
(99,84,0)
(86,20,0)
(182,33,0)
(114,29,0)
(63,13,0)
(2,29,0)
(74,40,0)
(106,76,0)
(134,22,0)
(35,63,0)
(161,57,0)
(180,8,0)
(6,7,0)
(161,168,0)
(154,36,0)
(60,119,0)
(140,81,0)
(137,173,0)
(81,131,0)
(143,30,0)
(65,184,0)
(115,173,0)
(46,182,0)
(69,37,0)
(159,29,0)
(129,133,0)
(85,75,0)
(19,144,0)
(76,106,0)
(124,173,0)
(13,33,0)
(10,131,0)
(163,91,0)
(53,3,0)
(111,106,0)
(183,76,0)
(166,141,0)
(147,185,0)
(97,96,0)
(61,131,0)
(135,66,0)
(84,99,0)
(13,37,0)
(170,29,0)
(20,182,0)
(4,152,0)
(121,39,0)
(174,90,0)
(105,40,0)
(174,131,0)
(164,101,0)
(142,29,0)
(127,109,0)
(139,29,0)
(128,29,0)
(39,119,0)
(44,131,0)
(21,133,0)
(167,144,0)
(148,185,0)
(134,15,0)
(110,29,0)
(145,76,0)
(120,164,0)
(25,36,0)
(125,29,0)
(5,119,0)
(171,80,0)
(185,66,0)
(22,134,0)
(17,133,0)
(82,150,0)
(44,142,0)
(45,160,0)
(152,90,0)
(96,115,0)
(7,29,0)
(136,122,0)
(109,144,0)
(77,33,0)
(160,182,0)
(57,142,0)
(153,15,0)
(8,37,0)
(71,100,0)
(156,52,0)
(27,21,0)
(24,16,0)
(104,92,0)
(66,135,0)
(162,132,0)
(79,92,0)
(99,29,0)
(28,29,0)
(36,47,0)
(49,173,0)
(179,61,0)
(15,134,0)
(142,57,0)
(101,122,0)
(121,29,0)
(57,161,0)
(151,135,0)
(176,173,0)
(184,65,0)
(68,33,0)
(168,161,0)
(67,29,0)
(103,122,0)
(94,3,0)
(43,29,0)
(50,141,0)
(16,30,0)
(172,21,0)
(48,29,0)
(126,115,0)
(117,33,0)
(158,168,0)
(39,121,0)
(90,152,0)
(112,29,0)
(172,33,0)
(75,131,0)
(138,115,0)
(31,150,0)
(169,160,0)
(102,172,0)
(123,152,0)
(57,81,0)
(58,22,0)
(72,75,0)
(20,47,0)
(26,81,0)
(115,96,0)
(47,20,0)
(1,178,0)
(90,34,0)
(30,16,0)
(16,173,0)
(87,3,0)
(90,174,0)
(13,63,0)
(131,174,0)
(78,122,0)
(38,84,0)
(56,29,0)
(83,0,0)
(20,101,0)
(32,65,0)
(18,161,0)
(95,71,0)
(177,8,0)
(40,105,0)
(175,33,0)
(21,172,0)
(3,87,0)
(146,52,0)
(63,0,0)
(93,172,0)
(54,29,0)
(75,7,0)
(14,44,0)
(81,57,0)
(37,8,0)
(12,29,0)
(42,109,0)
(55,29,0)
(37,13,0)
(119,39,0)
(50,91,0)
(59,84,0)
(0,63,0)
(34,90,0)
(23,40,0)
(73,184,0)
(89,184,0)
(144,109,0)
(9,96,0)
(98,168,0)
(113,39,0)
(105,115,0)
(144,33,0)
(115,105,0)
(181,44,0)
(62,164,0)
(51,15,0)
(157,20,0)
(65,122,0)
(131,173,0)
(41,33,0)
(130,101,0)
(80,171,1)
(149,144,1)
(6,75,1)
(174,90,1)
(87,88,1)
(134,22,1)
(15,153,1)
(81,131,1)
(134,15,1)
(109,42,1)
(102,52,1)
(87,3,1)
(140,44,1)
(38,92,1)
(68,182,1)
(94,53,1)
(4,107,1)
(73,155,1)
(172,21,1)
(141,70,1)
(66,135,1)
(147,134,1)
(27,133,1)
(161,18,1)
(170,92,1)
(131,174,1)
(179,131,1)
(82,31,1)
(79,61,1)
(1,80,1)
(120,150,1)
(150,82,1)
(83,37,1)
(8,177,1)
(135,151,1)
(138,16,1)
(45,169,1)
(96,97,1)
(154,25,1)
(106,111,1)
(30,143,1)
(59,38,1)
(164,62,1)
(41,13,1)
(42,127,1)
(105,40,1)
(63,35,1)
(16,30,1)
(43,68,1)
(93,102,1)
(5,60,1)
(44,131,1)
(37,69,1)
(22,58,1)
(25,159,1)
(169,52,1)
(62,120,1)
(25,170,1)
(129,93,1)
(25,110,1)
(25,12,1)
(181,92,1)
(61,131,1)
(148,147,1)
(10,115,1)
(13,37,1)
(58,15,1)
(182,46,1)
(95,47,1)
(159,7,1)
(106,76,1)
(127,19,1)
(111,76,1)
(151,185,1)
(7,6,1)
(90,34,1)
(160,45,1)
(177,180,1)
(115,105,1)
(89,73,1)
(50,141,1)
(178,87,1)
(39,113,1)
(25,54,1)
(156,146,1)
(53,106,1)
(161,168,1)
(103,101,1)
(97,9,1)
(47,20,1)
(78,65,1)
(57,81,1)
(36,154,1)
(75,72,1)
(101,130,1)
(43,41,1)
(121,39,1)
(92,104,1)
(44,14,1)
(63,0,1)
(25,43,1)
(65,184,1)
(35,0,1)
(144,109,1)
(184,89,1)
(157,86,1)
(146,92,1)
(81,26,1)
(61,179,1)
(69,8,1)
(130,164,1)
(115,96,1)
(1,178,1)
(113,119,1)
(185,148,1)
(123,4,1)
(20,101,1)
(166,106,1)
(116,83,1)
(110,142,1)
(180,172,1)
(84,59,1)
(76,145,1)
(88,3,1)
(32,150,1)
(25,114,1)
(152,123,1)
(51,99,1)
(99,84,1)
(171,100,1)
(39,119,1)
(114,66,1)
(37,8,1)
(158,98,1)
(142,57,1)
(74,126,1)
(167,52,1)
(23,74,1)
(43,149,1)
(54,78,1)
(25,108,1)
(9,105,1)
(70,166,1)
(145,183,1)
(14,181,1)
(85,92,1)
(31,92,1)
(119,5,1)
(54,103,1)
(20,157,1)
(143,24,1)
(71,95,1)
(153,51,1)
(100,71,1)
(114,134,1)
(86,36,1)
(75,131,1)
(60,92,1)
(168,158,1)
(155,32,1)
(21,27,1)
(13,63,1)
(1,100,1)
(133,17,1)
(98,81,1)
(1,163,1)
(18,168,1)
(40,23,1)
(57,161,1)
(20,182,1)
(17,129,1)
(46,160,1)
(72,85,1)
(19,167,1)
(52,156,1)
(126,138,1)
(183,61,1)
(107,10,1)
(26,140,1)
(21,133,1)
(163,50,1)
(108,92,1)
(0,116,1)
(79,87,1)
(12,121,1)
(104,79,1)
(90,152,1)
(3,94,1)
(115,96,2)
(133,52,2)
(103,150,2)
(148,134,2)
(0,52,2)
(171,100,2)
(87,3,2)
(99,84,2)
(22,92,2)
(158,92,2)
(147,134,2)
(157,87,2)
(44,92,2)
(146,92,2)
(8,52,2)
(134,92,2)
(141,106,2)
(180,52,2)
(86,61,2)
(134,22,2)
(68,52,2)
(90,34,2)
(183,61,2)
(19,52,2)
(95,87,2)
(142,92,2)
(73,150,2)
(15,92,2)
(181,92,2)
(86,87,2)
(134,15,2)
(20,182,2)
(94,106,2)
(102,52,2)
(87,106,2)
(1,178,2)
(153,92,2)
(144,109,2)
(59,92,2)
(60,92,2)
(57,81,2)
(45,52,2)
(81,131,2)
(120,150,2)
(116,52,2)
(26,92,2)
(92,87,2)
(37,52,2)
(62,150,2)
(114,92,2)
(121,39,2)
(66,134,2)
(21,133,2)
(110,92,2)
(182,52,2)
(99,92,2)
(14,92,2)
(172,52,2)
(84,92,2)
(164,150,2)
(76,61,2)
(72,92,2)
(42,52,2)
(151,134,2)
(65,150,2)
(44,131,2)
(174,90,2)
(65,184,2)
(178,87,2)
(163,106,2)
(61,131,2)
(104,87,2)
(69,52,2)
(37,8,2)
(105,40,2)
(57,92,2)
(79,87,2)
(144,52,2)
(166,106,2)
(111,61,2)
(167,52,2)
(50,141,2)
(81,92,2)
(32,150,2)
(31,92,2)
(140,92,2)
(184,150,2)
(38,92,2)
(35,52,2)
(3,106,2)
(160,52,2)
(66,135,2)
(95,61,2)
(6,92,2)
(93,52,2)
(115,105,2)
(82,92,2)
(159,92,2)
(71,61,2)
(63,0,2)
(154,87,2)
(47,20,2)
(142,57,2)
(145,61,2)
(79,61,2)
(20,61,2)
(149,52,2)
(170,92,2)
(161,92,2)
(41,52,2)
(157,61,2)
(52,92,2)
(119,92,2)
(46,52,2)
(109,52,2)
(85,92,2)
(101,150,2)
(168,92,2)
(25,87,2)
(71,87,2)
(177,52,2)
(53,106,2)
(131,174,2)
(1,163,2)
(106,76,2)
(57,161,2)
(18,92,2)
(185,134,2)
(113,92,2)
(16,30,2)
(106,61,2)
(17,52,2)
(58,92,2)
(39,119,2)
(39,92,2)
(13,52,2)
(80,100,2)
(89,150,2)
(169,52,2)
(78,150,2)
(54,92,2)
(20,87,2)
(155,150,2)
(129,52,2)
(12,92,2)
(98,92,2)
(63,52,2)
(75,131,2)
(13,63,2)
(90,152,2)
(172,21,2)
(135,134,2)
(13,37,2)
(47,87,2)
(108,92,2)
(36,87,2)
(47,61,2)
(161,168,2)
(156,92,2)
(5,92,2)
(20,101,2)
(154,61,2)
(121,92,2)
(70,106,2)
(130,150,2)
(25,61,2)
(50,106,2)
(21,52,2)
(100,71,2)
(75,92,2)
(150,92,2)
(100,61,2)
(88,106,2)
(36,61,2)
(43,92,2)
(127,52,2)
(104,61,2)
(83,52,2)
(51,92,2)
(27,52,2)
(7,92,2)
(100,87,2)
(92,61,2)
-----------------------------------
(0,msg.type)
(1,RET)
(2,switch(msg.error)
(3,msg.type)
(4,msg)
(5,data)
(6,1)
(7,p->waiting = 1)
(8,msg.data)
(9,msg)
(10,p)
(11,if(!rmonitor_check_limits(summary)
(12,break;)
(13,rmonitor_add_file_watch(msg.data.s, msg.type == OPEN_OUTPUT)
(14,wd)
(15,summary->max_concurrent_processes)
(16,recv_monitor_msg(rmonitor_queue_fd, &msg)
(17,data)
(18,s)
(19,"Process %d ran out of file descriptors.\\n")
(20,msg.error)
(21,msg.data.s)
(22,itable_size(processes)
(23,type)
(24,rmonitor_queue_fd)
(25,summary)
(26,wd)
(27,s)
(28,case BRANCH:)
(29,)
(30,&msg)
(31,msg)
(32,D_DEBUG)
(33,)
(34,uint64_t)
(35,OPEN_OUTPUT)
(36,summary->last_error)
(37,msg.data.s)
(38,msg)
(39,msg.data.p)
(40,msg.type)
(41,break;)
(42,origin)
(43,break;)
(44,p->wd)
(45,error)
(46,0)
(47,summary->last_error = msg.error)
(48,case END_WAIT:)
(49,switch(msg.type)
(50,release_waiting_process(msg.origin)
(51,summary)
(52,msg.error)
(53,msg)
(54,break;)
(55,case READ:)
(56,case OPEN_OUTPUT:)
(57,lookup_or_create_wd(p->wd, msg.data.s)
(58,processes)
(59,origin)
(60,msg)
(61,!p)
(62,error)
(63,msg.type == OPEN_OUTPUT)
(64,if(summary->max_concurrent_processes < itable_size(processes)
(65,debug(D_DEBUG, "Process %d ran out of disk space.\\n", msg.origin)
(66,summary->max_concurrent_processes = itable_size(processes)
(67,case CHDIR:)
(68,break;)
(69,s)
(70,origin)
(71,rmonitor_check_limits(summary)
(72,waiting)
(73,msg)
(74,msg)
(75,p->waiting)
(76,msg.type)
(77,default:)
(78,break;)
(79,msg)
(80,rmonitor_final_cleanup(SIGTERM)
(81,p->wd)
(82,error)
(83,msg)
(84,msg.origin)
(85,p)
(86,msg)
(87,msg.type != BRANCH)
(88,BRANCH)
(89,origin)
(90,(uint64_t)
(91,)
(92,msg.type)
(93,"File %s has been opened.\\n")
(94,type)
(95,summary)
(96,msg.origin)
(97,origin)
(98,msg)
(99,rmonitor_track_process(msg.origin)
(100,!rmonitor_check_limits(summary)
(101,msg.error = 0)
(102,D_DEBUG)
(103,break;)
(104,type)
(105,str_msgtype(msg.type)
(106,msg.type == END_WAIT)
(107,processes)
(108,break;)
(109,msg.origin)
(110,break;)
(111,END_WAIT)
(112,case WRITE:)
(113,p)
(114,break;)
(115,debug(D_DEBUG,"message \\"%s\\" from %d\\n", str_msgtype(msg.type)
(116,type)
(117,case EMFILE:)
(118,case ENOSPC:)
(119,msg.data)
(120,msg)
(121,rmonitor_untrack_process(msg.data.p)
(122,)
(123,origin)
(124,msg)
(125,case OPEN_INPUT:)
(126,"message \\"%s\\" from %d\\n")
(127,msg)
(128,case END:)
(129,msg)
(130,0)
(131,p = itable_lookup(processes, (uint64_t)
(132,)
(133,msg.data)
(134,summary->max_concurrent_processes < itable_size(processes)
(135,itable_size(processes)
(136,default:)
(137,if(!p)
(138,D_DEBUG)
(139,switch(msg.error)
(140,p)
(141,msg.origin)
(142,p->wd = lookup_or_create_wd(p->wd, msg.data.s)
(143,msg)
(144,debug(D_DEBUG, "Process %d ran out of file descriptors.\\n", msg.origin)
(145,type)
(146,msg)
(147,summary)
(148,max_concurrent_processes)
(149,break;)
(150,msg.error)
(151,processes)
(152,msg.origin)
(153,max_concurrent_processes)
(154,last_error)
(155,"Process %d ran out of disk space.\\n")
(156,error)
(157,error)
(158,data)
(159,break;)
(160,msg.error)
(161,msg.data.s)
(162,if( msg.type == END_WAIT )
(163,return;)
(164,msg.error)
(165,default:)
(166,msg)
(167,D_DEBUG)
(168,msg.data)
(169,msg)
(170,break;)
(171,SIGTERM)
(172,debug(D_DEBUG, "File %s has been opened.\\n", msg.data.s)
(173,)
(174,itable_lookup(processes, (uint64_t)
(175,case 0:)
(176,p)
(177,data)
(178,return;)
(179,p)
(180,msg)
(181,p)
(182,msg.error = 0)
(183,msg)
(184,msg.origin)
(185,summary->max_concurrent_processes)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^